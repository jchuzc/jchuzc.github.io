{"posts":[{"title":"ML System Design FrameWork","text":"A systematic approach to crack ML system design interviews. References https://bytebytego.com/courses/machine-learning-system-design-interview/visual-search-system","link":"/interview/MLSystemDesignFrameWork/"},{"title":"Collection of common behaviroal questions","text":"The most common and popular technique to crack behavirol interviews is to use STAR method. Situation: Set the scene and give the necessary details of your example. Task: Describe what your responsibility was in that situation. Action: Explain exactly what steps you took to address it. Result: Share what outcomes your actions achieved. Here are some common questions during an interview: Describe a time when you managed to deal with deadlines. Describe a time when you handled disagreement/conflicts with your colleagues. Describe a time when you worked with a difficult teammate. Describe a time when you failed at your work. Why do you leave your last job? Where do you see yourself in 5 years? Why choose X company? What is your biggest weakness? What is your biggest strength? Describe a time when you dealt with an ambiguous task and how you solved it. Describe a time when you had different opinions with your manager.","link":"/interview/behaviroalQuestions/"},{"title":"Data Structures","text":"Most common algorithms and data structures. Most common algorithms: Sort Linked List Heap Stack Queue Hash Map Binary Search Two pointer (sliding window) BFS DFS DP Prefix Sum Tree Others: Union Find Trie Monotone Stack Sweep Line","link":"/interview/algorithm/"},{"title":"十一月龄","text":"正式开启人生上学之路 之 - 托儿所","link":"/life/baby-11-month/"},{"title":"Camera Intrinsic and Extrinsic","text":"Deriving the Camera Intrinsic and Extrinsic Matrices.","link":"/CGV/cgv-camera-intrinsic-extrinsic/"},{"title":"Barycentric Rasterization","text":"Achieving rasterization with BaryCentric Coordinate. 1. Introduction 2. ImplementationWe are implementing barycentric-based rasterization using Vulkan compute shader.Code is available at: https://github.com/chuzcjoe/CORE/tree/master/examples/vulkan/ComputeBarycentricRasterizer The core part is the shader implementation. This is identical to the math above. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#version 450layout(binding = 0) uniform UniformBufferObject { int width; int height; vec2 vertex_a; vec2 vertex_b; vec2 vertex_c;}ubo;layout(std430, binding = 1) buffer rasterize_in_out { int rasterize[]; };layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;int CalArea(ivec2 p1, ivec2 p2, ivec2 p3) { return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);}bool BaryCentric(ivec2 pos) { ivec2 p1 = ivec2(ubo.vertex_a); ivec2 p2 = ivec2(ubo.vertex_b); ivec2 p3 = ivec2(ubo.vertex_c); int area1 = CalArea(p1, p2, pos); int area2 = CalArea(p2, p3, pos); int area3 = CalArea(p3, p1, pos); return area1 &gt;= 0 &amp;&amp; area2 &gt;= 0 &amp;&amp; area3 &gt;= 0;}void main() { ivec2 gid = ivec2(gl_GlobalInvocationID.xy); const int row = gid.y; const int col = gid.x; if (row &gt;= ubo.height || col &gt;= ubo.width) return; int ax = ivec2(ubo.vertex_a).x; int ay = ivec2(ubo.vertex_a).y; int bx = ivec2(ubo.vertex_b).x; int by = ivec2(ubo.vertex_b).y; int cx = ivec2(ubo.vertex_c).x; int cy = ivec2(ubo.vertex_c).y; int top = min(min(ay, by), cy); int bottom = max(max(ay, by), cy); int left = min(min(ax, bx), cx); int right = max(max(ax, bx), cx); if (row &lt; top || row &gt; bottom || col &lt; left || col &gt; right) return; // rasterize bool in_triangle = BaryCentric(ivec2(col, row)); if (in_triangle) { rasterize[row * ubo.width + col] = 1; }} We write white color(255) to the rasterized pixels and the rest remain black.","link":"/CGV/cgv-barycentric-rasterization/"},{"title":"Common Techniques for Defining Shader Code","text":"Introducing three common techniques. 1. Using Variadic Macros123456789101112131415161718#define VERTEX_SHADER(...) &quot;#version 300 es\\n&quot; #__VA_ARGS__#define FRAGMENT_SHADER(...) &quot;#version 300 es\\n&quot; #__VA_ARGS__// Triangle Shaderconst char* TriangleVertexShader = VERTEX_SHADER( layout(location = 0) in vec4 vPosition; void main() { gl_Position = vPosition; });const char* TriangleFragmentShader = FRAGMENT_SHADER( precision mediump float; out vec4 FragColor; void main() { FragColor = vec4(0.0, 1.0, 0.0, 1.0); }); 2. Using Raw String Literal1234567const char* vertexShaderSource = R&quot;( #version 330 core layout(location = 0) in vec3 aPos; void main() { gl_Position = vec4(aPos, 1.0); })&quot;; 3. Shader FilesvertexShader.glsl12345#version 330 corelayout(location = 0) in vec3 aPos;void main() { gl_Position = vec4(aPos, 1.0);} Read file in C++: 1234std::ifstream file(&quot;vertexShader.glsl&quot;);std::stringstream buffer;buffer &lt;&lt; file.rdbuf();std::string vertexShaderSource = buffer.str();","link":"/CGV/cgv-define-shaders/"},{"title":"Color Transfer Function","text":"OETF, EOTF &amp; OOTF 1. What is Color Transfer Function?Our eyes perceive light differently from cameras do. A camera will yield linear output with respect to the input light intensity. However, human vision has its non-linearity property and is more sensetive to color differences especially in dark regions. In order to mimic how human vision system responds to light, we need color transfer function to adapt camera out or display brightness. 2. OETF, EOTF and OOTFOETF(Opto-Electronic Transfer Function) describes how light information captured by a camera or image sensor is converted into an electrical signal, which is then encoded into a digital image signal. Essentially, the OETF defines the relationship between the light intensity captured by the sensor and the corresponding signal output used for storage, processing, or transmission. EOTF(Electro-Optical Transfer Function) describes how the digital image data (electrical signals) are converted back into light (optical signals) by a display device. OOTF stands for Opto-Optical Transfer Function. It represents the overall transfer function from the scene light captured by a camera to the light emitted by a display, combining both the Opto-Electronic Transfer Function (OETF) and the Electro-Optical Transfer Function (EOTF). The encoded digital signal is in non-linear space. Sometimes, when we need to performan certain operations such as color space conversion, we must first linearize the signal and do the operations within the linear space. 3. sRGBsRGB color space is non-linear and is encoded using a non-linear transfer function. OETF $$V^{\\prime} = \\begin{cases}12.92 \\cdot V &amp; V \\leq 0.0031308 \\\\1.055 \\cdot V^{1/2.4} - 0.055 &amp; V &gt; 0.0031308\\end{cases}$$ EOTF $$V = \\begin{cases}\\frac{V^{\\prime}}{12.92} &amp; V^{\\prime} \\leq 0.04045 \\\\(\\frac{V^{\\prime}+0.055}{1.055})^{2.4} &amp; V^{\\prime} &gt; 0.04045\\end{cases}$$ More details can be found at khronos specifications: https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.inline.html#TRANSFER_HLG:~:text=0.081242858298635-,13.3.%C2%A0sRGB%20transfer%20functions,-13.3.1.%C2%A0sRGB%20EOTF 4. Hybrid-Log-GammaThe hybrid log–gamma (HLG) transfer function is a transfer function jointly developed by the BBC and NHK for high dynamic range (HDR) display. OETF The BT.2100-2 Hybrid Log Gamma description defines the following OETF for linear scene light: $$V^{\\prime} = \\begin{cases}\\sqrt{3V} &amp; 0 \\leq V \\leq \\frac{1}{12} \\\\aln(12V-b)+c &amp; \\frac{1}{12} &lt; V \\leq 1\\end{cases}$$ Where $a=0.17883277$, $b=0.28466892$, c=$0.55991073$ More details can be found at: https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.inline.html#TRANSFER_HLG:~:text=lift%20(legacy%20%E2%80%9Cbrightness%E2%80%9D)-,13.5.%C2%A0BT.2100%20HLG%20transfer%20functions,-HLG%20(and%20PQ Referenceshttps://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.inline.html#TRANSFER_HLGhttps://en.wikipedia.org/wiki/Hybrid_log%E2%80%93gammahttps://blogs.telestream.net/2022/11/transfer-functions-and-their-functions-in-high-dynamic-range-workflow/","link":"/CGV/cgv-color-transfer-function/"},{"title":"BT709 and BT2020","text":"SDR and HDR, and more. 1. IntroductionHDR (High Dynamic Range) and SDR (Standard Dynamic Range) are two distinct methods of displaying video content, each utilizing different color spaces. HDR employs the BT.2020 color space standard, whereas SDR uses BT.709. Compared to BT.709, BT.2020 encompasses a significantly wider color gamut, as illustrated in the figure below. The BT.2020 color space can reproduce colors that BT.709 cannot. Figure 1. CIE 1931 BT.2020 covers 75.8% of the colors in the CIE 1931 color space, while BT.709 covers 35.9%. The entire CIE 1931 color space represents all the colors that human eyes can perceive. The wavelength of the BT2020 primary colors is 630 nm for the red primary color, 532 nm for the green primary color, and 467 nm for the blue primary color. Here are some details regarding color primaries and white points for BT709 and BT2020 respectively. .tg {border-collapse:collapse;border-color:#ccc;border-spacing:0;} .tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle} .tg .tg-75rw{background-color:#F8F9FA;border-color:inherit;color:#202122;text-align:center;vertical-align:middle} Color Space White point Primaries Xw Yw Xr Yr Xg Yg Xb Yb BT709 0.3127 0.3290 0.64 0.33 0.30 0.60 0.15 0.06 BT2020 0.3127 0.3290 0.708 0.292 0.170 0.797 0.131 0.046 Table 1. 2. XYZ Color SpaceSo far, we can see that the color range(gamut) that BT709(or BT2020) can represent is decided by the primaries and white points. If we project the color spaces in XYZ color space, we can get their corresponding irregular, polyhedral 3D shape objects. It is important to understand the difference between xyz and XYZ coordinates. xyz is normalized and xy represents the chromaticity. XYZ is also called Tristimulus values. Y is the luminance, Z is quasi-equal to blue (of CIE RGB), and X is a mix of the three CIE RGB curves chosen to be nonnegative. xyz is obtained by normalizing XYZ. And $x + y + z = 1$. $$\\begin{equation}\\begin{cases}x = \\frac{X}{X+Y+Z} \\\\y = \\frac{Y}{X+Y+Z} \\\\z = \\frac{Z}{X+Y+Z}\\end{cases}\\end{equation}$$ Then, we can have: $ \\begin{equation} \\begin{cases} R_X = \\frac{R_x}{R_y}*R_Y \\\\\\\\ R_Y = R_Y \\\\\\\\ R_Z = \\frac{R_z}{R_y}*R_Y \\end{cases} \\end{equation} $ $ \\begin{equation} \\begin{cases} G_X = \\frac{G_x}{G_y}*G_Y \\\\\\\\ G_Y = G_Y \\\\\\\\ G_Z = \\frac{G_z}{G_y}*G_Y \\end{cases} \\end{equation} $ $ \\begin{equation} \\begin{cases} B_X = \\frac{B_x}{B_y}*B_Y \\\\\\\\ B_Y = B_Y \\\\\\\\ B_Z = \\frac{B_z}{B_y}*B_Y \\end{cases} \\end{equation} $ $ \\begin{equation} \\begin{cases} W_X = \\frac{W_x}{W_y}*W_Y \\\\\\\\ W_Y = W_Y \\\\\\\\ W_Z = \\frac{W_z}{W_y}*W_Y \\end{cases} \\end{equation} $ The white point is defined such that when red, green, and blue components are combined at their full intensities, they produce white. The tristimulus values of the white point $W_X, W_Y, W_Z$ are the sums of the individual contributions from the red, green, and blue components $R_X, G_X, B_X$. $$\\begin{equation}\\begin{cases}W_X = R_X + G_X + B_X \\\\W_Y = R_Y + G_Y + B_Y \\\\W_Z = R_Z + G_Z + B_Z\\end{cases}\\end{equation}$$ Let’s combine these equations and we can get: $$\\begin{equation}\\begin{cases}\\frac{W_x}{W_y} * W_Y = \\frac{R_x}{R_y} * R_Y + \\frac{G_x}{G_y} * G_Y + \\frac{B_x}{B_y} * B_Y \\\\W_Y = R_Y + G_Y + B_Y = 1 \\\\\\frac{W_z}{W_y} * W_Y = \\frac{R_z}{R_y} * R_Y + \\frac{G_z}{G_y} * G_Y + \\frac{B_z}{B_y} * B_Y\\end{cases}\\end{equation}$$ Because $R_{xyz}, G_{xyz}, B_{xyz}$ are given as primaries and $W_Y = 1$, we can solve these linear euqations and get $R_{XYZ}, G_{XYZ}, B_{XYZ}$. These form orthogonal basis for RGB in XYZ space. $$\\begin{equation}\\left[\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right]=\\left[\\begin{array}{lll}R_X &amp; R_Y &amp; R_Z \\\\G_X &amp; G_Y &amp; G_Z \\\\B_X &amp; B_Y &amp; B_Z\\end{array}\\right]\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]\\end{equation}$$ Let’s use a simple example to illusrate why $RGB_{XYZ}$ is the conversion matrix we need. In this simplified case, the problem can be formulated as: Given (1) Linear Space $O_1 = \\{(1,0), (0,1)\\}$ (2) $P$ in $O_1$: (3,3) (3) $P$ in $O_2$: (0, $3\\sqrt{2}$), $O_2$ is unknown. Solve: Conversion matrix from $O_1$ to $O_2$. The analogy here is: $P$ is the white points(and primaries) in $XYZ$ space, $O_1$ is the $XYZ$ color space and $O_2$ is the $RGB$ basis in $XYZ$ space. We also have additional information about $P$ coordinates with respect to $RGB$ basis. We can easily compute $O_2$. $$O_2 = \\{(\\frac{1}{\\sqrt{2}}, -\\frac{1}{\\sqrt{2}}), (\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}})\\}$$ The conversion matrix is: $$\\begin{equation}\\left[\\begin{array}{l}X^{\\prime} \\\\Y^{\\prime}\\end{array}\\right]=\\left[\\begin{array}{lll}\\frac{1}{\\sqrt{2}} &amp; -\\frac{1}{\\sqrt{2}} \\\\\\frac{1}{\\sqrt{2}} &amp; \\frac{1}{\\sqrt{2}}\\end{array}\\right]\\left[\\begin{array}{l}X \\\\Y\\end{array}\\right]\\end{equation}$$ $O_2$ is exactly the conversion matrix that we need. So, the $RGB$ basis in $XYZ$ space $RGB_{XYZ}$ is our conversion matrix. 3. BT2020 to BT709BT2020 and BT709 can be both projected into $XYZ$ space. The distinction is that they form different $RGB$ basis in $XYZ$ space. To convert between these two color spaces, we can utilize the $XYZ$ space as an intermediary. This involves calculating two conversion matrices, one for each color space, and then obtaining the final conversion matrix through matrix multiplication. 3.1 BT2020 to XYZAccording to Table 1, we have: \\begin{equation*} \\begin{cases} R_x = 0.708 \\\\\\\\ R_y = 0.292 \\\\\\\\ R_z = 0.000 \\\\\\\\ \\end{cases} \\quad \\begin{cases} G_x = 0.170 \\\\\\\\ G_y = 0.797 \\\\\\\\ G_z = 0.033 \\\\\\\\ \\end{cases} \\quad \\begin{cases} B_x = 0.131 \\\\\\\\ B_y = 0.046 \\\\\\\\ B_z = 0.823 \\\\\\\\ \\end{cases} \\quad \\begin{cases} W_x = 0.3127 \\\\\\\\ W_y = 0.3290 \\\\\\\\ W_z = 0.3583 \\\\\\\\ \\end{cases} \\end{equation*} Substitue them to: \\begin{equation} \\begin{cases} \\frac{W_x}{W_y} * W_Y = \\frac{R_x}{R_y} * R_Y + \\frac{G_x}{G_y} * G_Y + \\frac{B_x}{B_y} * B_Y \\\\\\\\ W_Y = R_Y + G_Y + B_Y = 1 \\\\\\\\ \\frac{W_z}{W_y} * W_Y = \\frac{R_z}{R_y} * R_Y + \\frac{G_z}{G_y} * G_Y + \\frac{B_z}{B_y} * B_Y \\end{cases} \\end{equation} We can get $R_Y, G_Y, B_Y$. Then, solve the rest. \\begin{equation*} \\begin{cases} R_X = \\frac{0.708}{0.292} * R_Y \\\\\\\\ R_Y = R_Y \\\\\\\\ R_Z = \\frac{0.000}{0.292} * R_Y \\\\\\\\ \\end{cases} \\quad \\begin{cases} G_X = \\frac{0.170}{0.797} * G_Y \\\\\\\\ G_Y = G_Y \\\\ G_Z = \\frac{0.033}{0.797} * G_Y \\\\\\\\ \\end{cases} \\quad \\begin{cases} B_X = \\frac{0.131}{0.046} * B_Y \\\\\\\\ B_Y = B_y \\\\ B_Z = \\frac{0.823}{0.046} * B_Y \\\\\\\\ \\end{cases} \\end{equation*} The conversion matrix would be: $$\\begin{equation}\\left[\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right]=\\left[\\begin{array}{lll}0.636958 &amp; 0.144617 &amp; 0.168881 \\\\0.262700 &amp; 0.677998 &amp; 0.059302 \\\\0.000000 &amp; 0.028073 &amp; 1.060985\\end{array}\\right]\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]\\end{equation}$$ 3.2 XYZ to BT709Similar to BT2020 to XYZ, we can first compute the conversion matrix from BT709 to XYZ, then compute the inverse matrix. The inverse matrix is the matrix that we need to transform XYZ to BT709. $$\\begin{equation}\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]=\\left[\\begin{array}{lll}3.240970 &amp; −1.537383 &amp; −0.498611 \\\\−0.969244 &amp; 1.875968 &amp; 0.041555 \\\\0.055630 &amp; −0.203977 &amp; 1.056972\\end{array}\\right]\\left[\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right]\\end{equation}$$ 3.3 BT2020 to BT709$M_{BT2020-&gt;BT709} = M_{XYZ-&gt;BT709} * M_{BT2020-&gt;XYZ}$ $$M_{BT2020-&gt;BT709} = \\left[\\begin{array}{lll}1.660491 &amp; −0.587641 &amp; −0.072850 \\\\−0.124550 &amp; 1.132900 &amp; −0.008349 \\\\−0.018151 &amp; −0.100579 &amp; 1.118730\\end{array}\\right]$$ References https://en.wikipedia.org/wiki/Rec._2020 https://en.wikipedia.org/wiki/Rec._709 https://fujiwaratko.sakura.ne.jp/infosci/colorspace/colorspace3_e.html https://en.wikipedia.org/wiki/CIE_1931_color_space https://horizon-lab.org/colorvis/xyz.html","link":"/CGV/cgv-bt709-bt2020/"},{"title":"Exposure Value in Photography","text":"In photography, exposure value represents the combination of shutter speed and aperture size. 1. IntroductionExposure Value (EV) in photography is a single number that represents the combination of aperture and shutter speed that determine how much light reaches your camera’s sensor. It’s a handy way to quantify exposure across different settings, making it easier to adjust or compare them. EV measures exposure on a logarithmic scale where each step (1 EV) corresponds to a doubling or halving of light—also called a “stop.” EV can be calculated using this formula: $$\\begin{equation}EV = log_2\\frac{N^2}{t}\\end{equation}$$ where: $N$ is the f-number (aperture size). $t$ is the shutter speed (in seconds). EV 0 is standardized as the exposure from an aperture of f/1, a shutter speed of 1 second. A higher EV indicates a brighter scene requiring smaller apertures (higher f-numbers) or faster shutter speeds, while a lower EV indicates a darker scene requiring wider apertures or slower shutter speeds. EV 1 can be achieved by changing either aperture or shutter speed, or both. Change aperture:Aperture is controlled by the f-number (N) and the amount of light entering the camera is proportional to $1/N^2$$$\\begin{equation}LightIntensity \\propto \\frac{1}{N^2}\\end{equation}$$ This means that to double the light (increase by 1 EV) or halve the light (decrease by 1 EV), the relationship between the old and new f-numbers must satisfy:$$\\begin{equation}\\frac{1}{N\\prime^2} = 2 * \\frac{1}{N^2}\\end{equation}$$ Taking the square root on both sides:$$\\begin{equation}N\\prime = \\frac{N}{\\sqrt{2}}\\end{equation}$$ This means a 1 EV change in aperture corresponds to multiplying or dividing the f-number by $\\sqrt{2} \\approx 1.414$ Change shutter speed:To change exposure by 1 EV, we must double or halve the light intensity. Since light is directly proportional to shutter speed, we can multiply or divide the exposure time by 2. You can achieve the same EV with different settings: f/2.8, 1/125s$$\\begin{equation}EV = log_2\\frac{2.8^2}{\\frac{1}{125}} \\approx 9.9\\end{equation}$$ f/4, 1/60s$$\\begin{equation}EV = log_2\\frac{4^2}{\\frac{1}{60}} \\approx 9.9\\end{equation}$$ Common EV values and their corresponding lighting conditions: EV Lighting Condition -6 to -3 Night with minimal light sources 0 to 3 Indoor lighting or dimly lit streets 4 to 7 Overcast days or indoors with bright windows 8 to 11 Open shade or indoor well-lit areas 12 to 15 Bright daylight or sunny conditions 16+ Snowy landscapes, beach scenes, or direct sunlight 2. EV StepAn EV step (or stop) refers to a change in exposure value by a factor of 2× or 1/2× in terms of light intensity. Each step up doubles the amount of light, while each step down halves it. Increase by 1 EV: Doubles the light (e.g., brighter image). Decrease by 1 EV: Halves the light (e.g., darker image). A 1 EV step can be achieved by adjusting one of the exposure settings: Aperture (f-stop): Changing the f-number by a factor of $\\sqrt(2) \\approx 1.4$ Example: f/2 → f/2.8 (1 EV decrease), f/5.6 → f/4 (1 EV increase). Shutter Speed: Doubling or halving the duration. Example: 1/60s → 1/30s (1 EV increase), 1/250s → 1/500s (1 EV decrease). Modern cameras often let you fine-tune in smaller increments such as 1/3 EV and 1/2 EV. Since the Exposure Value (EV) is defined in a logarithmic scale, we need to change aperture size and shutter speed by the factor of 2. In order to change 1/3 EV, we need to adjust: Aperture $N^{\\prime} = \\frac{N}{\\sqrt[6]{2}}$ Shutter speed $t^{\\prime} = t * 2^{\\frac{1}{3}}$ 3. Mobile Phone CamerasSince mobile cameras have fixed apertures, the primary ways they control EV are by adjusting shutter speed (exposure time) and ISO sensitivity. They may also use HDR and computational techniques to balance exposure across different parts of the image. For example, if the camera needs to brighten the image (increase EV), it can slow down the shutter speed, increase ISO, or combine multiple exposures in HDR.To decrease EV (darken the image), it can speed up the shutter, decrease ISO, or merge less-exposed images. References https://en.wikipedia.org/wiki/Exposure_value","link":"/CGV/cgv-exposure-value/"},{"title":"Learn OpenGLES 1","text":"Environment setup in Android Studio and draw our first triangle. Source code: https://github.com/chuzcjoe/learnopengles 1. Project OverviewOpenGL ES is a subset of the OpenGL computer graphics rendering application programming interface (API) designed for embedded devices such as mobile phones, tablets, and gaming consoles. OpenGL ES serves as the primary low-level graphics API for Android. It’s used for rendering 2D and 3D graphics on Android devices. Android provides GLSurfaceView, a specialized view for OpenGL ES rendering, making it easier to integrate OpenGL ES content into Android UI. This project leverages an excellent learning resource available at https://github.com/githubhaohao/NDK_OpenGLES_3_0. Thanks the author for make it open souce. Building upon the original code, this project introduces several customizations, including the use of the more modern Kotlin language for development and modifications to some native C++ APIs to better align with the project’s requirements. Additionally, the learning approach has been slightly adjusted. The primary aim of this project is educational. 2. Environment SetupThe UI is simple. On the top right corner, we have a menu that allows us to select the GL demo we want to render on the center screen. For example, here we only have one option which is to render a triangle on the screen. As we continue to make progress, more samples will be added to the list. 3. Design MyGLSurfaceView inherits from GLSurfaceView, configs EGL and set Render. 123456789101112131415161718192021222324252627282930313233343536373839class MyGLSurfaceView(context: Context?, private val mGLRender: MyGLRender, attrs: AttributeSet? = null) : GLSurfaceView(context) { private val TAG = &quot;MyGLSurfaceView&quot; private var mRatioWidth: Int = 0 private var mRatioHeight: Int = 0 init { setEGLContextClientVersion(3) setEGLConfigChooser(8, 8, 8, 8, 16, 8) setRenderer(mGLRender) renderMode = RENDERMODE_WHEN_DIRTY } override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { super.onMeasure(widthMeasureSpec, heightMeasureSpec) val width = MeasureSpec.getSize(widthMeasureSpec) val height = MeasureSpec.getSize(heightMeasureSpec) if (0 == mRatioWidth || 0 == mRatioHeight) { setMeasuredDimension(width, height) } else { if (width &lt; height * mRatioWidth / mRatioHeight) { setMeasuredDimension(width, width * mRatioHeight / mRatioWidth) } else { setMeasuredDimension(height * mRatioWidth / mRatioHeight, height) } } } fun setAspectRatio(width: Int, height: Int) { Log.d(TAG, &quot;setAspectRatio() called with: width = [$width], height = [$height]&quot;) require(!(width &lt; 0 || height &lt; 0)) { &quot;Size cannot be negative.&quot; } mRatioWidth = width mRatioHeight = height requestLayout() } fun getRender() : MyGLRender { return mGLRender } MyGLRender implements three override functions that handle different MyGLSurfaceView events. 12345678910111213141516171819class MyGLRender : GLSurfaceView.Renderer { private val mNativeRender: MyNativeRender = MyNativeRender() override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) { mNativeRender.native_SurfaceCreated() } override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) { mNativeRender.native_SurfaceChanged(width, height) } override fun onDrawFrame(gl: GL10?) { mNativeRender.native_DrawFrame() } fun initRenderContext() { mNativeRender.native_init() }} We also have a very important MyNativeRender class that loads native C++ library and can direcly call native functions. 12345678910111213141516171819class MyNativeRender { companion object { init { System.loadLibrary(&quot;opengles&quot;) } } external fun native_init() external fun native_uninit() external fun native_SurfaceCreated() external fun native_SurfaceChanged(width: Int, height: Int) external fun native_DrawFrame() external fun native_setSample(sample: Int)} On the native code side, we have a GLContext class that manages the rendering context. It is designed to be singleton pattern, since we only want one instance of the context. 123456789101112131415161718192021// Singleton classclass GLContext {private: GLContext(); ~GLContext();public: void OnSurfaceCreated(); void OnSurfaceChanged(int width, int height); void OnDrawFrame(); void setSample(int sample); static GLContext* getInstance(); static void destroyInstance();private: static GLContext* mContext; GLBase* mSample = nullptr; int mWidth; int mHeight;}; GLBase is the base class for all the other rendering classes. Derived classes must implement init(), draw(), destroy(). 1234567891011121314151617class GLBase {public: GLBase() {} virtual ~GLBase() {} // must implement in samples virtual void init() = 0; virtual void draw() = 0; virtual void destroy() = 0;protected: GLuint mVertexShader; GLuint mFragmentShader; GLuint mShaderProgram; int mSurfaceWidth; int mSurfaceHeight;}; TriangleSample loads shaders and creates a shader program. The draw() function will render a triangle. 12345678910111213141516171819202122232425262728293031void TriangleSample::init() { mShaderProgram = GLUtils::CreateProgram(TriangleVertexShader, TriangleFragmentShader, mVertexShader, mFragmentShader);}void TriangleSample::draw() { GLfloat vVertices[] = { 0.0f, 0.5f, 0.0f, -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, }; glClear(GL_STENCIL_BUFFER_BIT | GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glClearColor(1.0, 1.0, 1.0, 1.0); // Use the program object glUseProgram (mShaderProgram); // Load the vertex data glVertexAttribPointer (0, 3, GL_FLOAT, GL_FALSE, 0, vVertices ); glEnableVertexAttribArray (0); glDrawArrays (GL_TRIANGLES, 0, 3); glUseProgram (GL_NONE);}void TriangleSample::destroy() { if (mShaderProgram) { glDeleteProgram(mShaderProgram); mShaderProgram = GL_NONE; }} All the shaders will be defined in GLShaderSources.h 1234567891011121314151617#define VERTEX_SHADER(...) &quot;#version 300 es\\n&quot; #__VA_ARGS__#define FRAGMENT_SHADER(...) &quot;#version 300 es\\n&quot; #__VA_ARGS__const char* TriangleVertexShader = VERTEX_SHADER( layout(location = 0) in vec4 vPosition; void main() { gl_Position = vPosition; });const char* TriangleFragmentShader = FRAGMENT_SHADER( precision mediump float; out vec4 FragColor; void main() { FragColor = vec4 (0.0, 1.0, 0.0, 1.0); } ); References https://github.com/githubhaohao/NDK_OpenGLES_3_0","link":"/CGV/cgv-learn-opengles1/"},{"title":"Make atomicAdd Faster in Vulkan","text":"Global counter, shared counter and subgroup optimization. atomic ensures only one GPU thread can write to the memory, preventing others from writing at the same time. If many threads hit at once, a single global atomic can become a hotspot, often introducing performance bottleneck. 1. Global CounterGlobal counter is visible to all workgroups. Thread contention will happen and cause performance degradation. 12345678910111213141516#version 450layout(local_size_x = 128) in;// SSBO with a single 32-bit counterlayout(std430, binding = 0) buffer CounterBuf { uint counter;};void main() { bool hit = /* your condition from the computed value */; if (hit) { // Atomically add 1 atomicAdd(counter, 1u); }} 2. Shared CounterCount within the workgroup using shared memory, then do one atomic to the global counter. 1234567891011121314151617181920212223242526#version 450layout(local_size_x = 128) in;layout(std430, binding = 0) buffer CounterBuf { uint globalCounter;};shared uint wgCounter;void main() { // One lane initializes the shared counter if (gl_LocalInvocationIndex == 0u) wgCounter = 0u; barrier(); // synchronize shared memory initialization bool hit = /* your condition */; if (hit) { atomicAdd(wgCounter, 1u); // fast, within workgroup } barrier(); // ensure all increments are done // One lane publishes to global if (gl_LocalInvocationIndex == 0u) { atomicAdd(globalCounter, wgCounter); }} 3. Subgroup OptimizationWe can go further and do one atomic per subgroup. Threads in a workgroup are not executed individually, in fact, they are executed as batches and each batch is what we call subgroup. It often refers to a warp (NVIDIA) or wavefront/wave (AMD). Typical sizes: 32 (NVIDIA), 64 (AMD), 8/16/32 (Intel/ARM). It’s hardware-dependent and can vary by devices. subgroupAdd() reduces the per-lane values within the subgroup.subgroupElect() is true for exactly one lane in the subgroup. To enable this feature, you need Vulkan 1.1+, and compile your shaders like this: 12glslc --target-env=vulkan1.1 -mfmt=c shader.comp -o shader.spv 12345678910111213#version 450#extension GL_KHR_shader_subgroup_arithmetic : requirelayout(local_size_x = 128) in;layout(std430, binding = 0) buffer CounterBuf { uint globalCounter; };void main() { bool hit = /* your condition */; uint subgroupSum = subgroupAdd(hit ? 1u : 0u); if (subgroupElect()) { // exactly one lane per subgroup atomicAdd(globalCounter, subgroupSum); }} More resources: https://www.khronos.org/blog/vulkan-subgroup-tutorial","link":"/CGV/cgv-make-atomic-op-faster-vulkan/"},{"title":"Learn OpenGLES 2","text":"Use an image as texture map and render it on the screen. Source code: https://github.com/chuzcjoe/learnopengles 2D texture is the most common texture type in OpenGLES. It is essentially a 2D image that adds details to the surface of an object. Texture coordinates range from 0 to 1. The figure below shows the texture coordinates and vertex coordinates in OpenGLES. If we want to render a texture image, we can set the vertices and texture coordinates to be: 12345678910111213GLfloat vertices[] = { -1.0f, 0.5f, 0.0f, // Top left -1.0f, -0.5f, 0.0f, // Bottom left 1.0f, -0.5f, 0.0f, // Bottom right 1.0f, 0.5f, 0.0f, // Top right};GLfloat textureCoords[] = { 0.0f, 0.0f, // top left 0.0f, 1.0f, // bottom left 1.0f, 1.0f, // bottom right 1.0f, 0.0f // top right}; OpenGL uses the winding order of the vertices to determine the “front” and “back” faces of a triangle. The default winding order is counter-clockwise (CCW) for front faces. So, when drawing a rectangle using two triangles, we can specify the order to be: 1GLushort indices[] = { 0, 1, 2, 0, 2, 3 }; Generate 2D texture in OpenGL 12345678910// generate a textureglGenTextures(1, &amp;mTextureID);// set the texture object as the current activate texture objectglBindTexture(GL_TEXTURE_2D, mTextureID);// set texture wrappingglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glBindTexture(GL_TEXTURE_2D, GL_NONE); Load an RGBA image as texture. On Kotlin side, we will load an jpeg as a bitmap, convert it to byteArray, and pass it down to native C++. 123456789101112private fun loadBitmap(resId: Int): Bitmap? { val fileStream = this.resources.openRawResource(resId) val bitmap: Bitmap? = BitmapFactory.decodeStream(fileStream) if (bitmap != null) { val buf = ByteBuffer.allocate(bitmap.byteCount) bitmap.copyPixelsToBuffer(buf) val byteArray = buf.array() mGLRender.setImageData(IMAGE_FORMAT_RGBA, bitmap.width, bitmap.height, byteArray) Log.d(TAG, &quot;image width: ${bitmap.width}, image height: ${bitmap.height}&quot;) } return bitmap} 123456789extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_example_opengles_gl_MyNativeRender_native_1setImageData(JNIEnv *env, jobject thiz, jint pixel_format, jint width, jint height, jbyteArray bytes) { jsize length = env-&gt;GetArrayLength(bytes); uint8_t* buffer = new uint8_t[length]; env-&gt;GetByteArrayRegion(bytes, 0, length, reinterpret_cast&lt;jbyte*&gt;(buffer)); GLContext::getInstance()-&gt;setImageData(pixel_format, width, height, buffer); delete[] buffer;} We define a NativeImage struct to hold our image data. 123456789101112131415struct NativeImage { int width; int height; int format; uint8_t* planes[3]; NativeImage() { width = 0; height = 0; format = 0; planes[0] = nullptr; planes[1] = nullptr; planes[2] = nullptr; }}; Generate texture image. 1234glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, mTextureID);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mImage.width, mImage.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, mImage.planes[0]);glBindTexture(GL_TEXTURE_2D, GL_NONE); Vertex/Fragment shaders 1234567891011121314151617181920// Texture Load Shaderconst char* TextureLoadVertexShader = VERTEX_SHADER( layout(location = 0) in vec3 aPosition; layout(location = 1) in vec2 aTexCoord; out vec2 vTexCoord; void main() { gl_Position = vec4(aPosition, 1.); vTexCoord = aTexCoord; });const char* TextureLoadFragmentShader = FRAGMENT_SHADER( precision mediump float; in vec2 vTexCoord; uniform sampler2D sTexture; out vec4 FragColor; void main() { FragColor = texture(sTexture, vTexCoord); }); We added a new item in the sample selection. The image will be rendered as a texture map. References https://github.com/githubhaohao/NDK_OpenGLES_3_0","link":"/CGV/cgv-learn-opengles2/"},{"title":"Learn OpenGLES 3","text":"VAO, VBO and EBO Source code: https://github.com/chuzcjoe/learnopengles 1. Vertex Buffer Object (VBO)In our first demo, where we render a triangle in the center of the screen, we define the vertices and store them on the CPU. When glDrawArrays is called, this data is transferred from the CPU to the GPU for rendering. While this method works well for small data sizes, it can become a performance bottleneck if large amounts of data need to be loaded from the CPU to the GPU. VBO is designed to address such issue. VBO manages large batches of data on GPU memory and keep it there if enough space left on GPU. Once the data is in GPU memory, shader programs can have instant access to it. 123456789101112GLfloat vertices[4 * (3 + 4)] = { // Vertex positions followed by color attributes -0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, // v0, c0 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, // v1, c1 0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, // v2, c2 0.5f, 0.5f, 0.0f, 0.5f, 1.0f, 1.0f, 1.0f // v3, c3};// Generate VBO and load dataglGenBuffers(1, &amp;mVBO);glBindBuffer(GL_ARRAY_BUFFER, mVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 2. Vertex Array Object (VAO)A Vertex Array Object (VAO) in OpenGL is a container object that encapsulates the state needed to specify vertex data to the GPU. It essentially keeps track of multiple vertex buffer objects (VBOs) and their associated vertex attribute configurations, allowing you to easily switch between different vertex data sets and attribute setups. After a VAO is bound, any subsequent vertex attribute calls will be stored in VAO. 12345678910111213141516// Generate VAO and define how data is storedglGenVertexArrays(1, &amp;mVAO);glBindVertexArray(mVAO);// Generate VBO, EBO and bind them for VAO to capture// ...// Specify the layout of the vertex dataglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(0));glEnableVertexAttribArray(0);glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(3 * sizeof(float)));glEnableVertexAttribArray(1);// Unbind the VAO (it's a good practice to unbind any VAO to prevent accidental modification)glBindVertexArray(GL_NONE); 3. Element Buffer Object (EBO)Element Buffer Objects (EBOs), also known as Index Buffer Objects (IBOs), are an essential feature in OpenGL used for indexing vertex data. They allow you to specify indices that define the order in which vertices are processed, making it possible to reuse vertex data to draw multiple primitives (such as triangles, lines, etc.), which can significantly reduce the amount of memory required and improve performance. 1234567891011121314151617181920212223// without EBOfloat vertices[] = { // first triangle 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, 0.5f, 0.0f, // top left // second triangle 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left};// with EBOfloat vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left };unsigned int indices[] = { // note that we start from 0! 0, 1, 3, // first triangle 1, 2, 3 // second triangle}; To use EBO: 12345678910111213141516GLfloat vertices[4 * (3 + 4)] = { // Vertex positions followed by color attributes -0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, // v0, c0 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, // v1, c1 0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, // v2, c2 0.5f, 0.5f, 0.0f, 0.5f, 1.0f, 1.0f, 1.0f // v3, c3};GLushort indices[6] = {0, 1, 2, 0, 2, 3};// Generate EBO and load dataglGenBuffers(1, &amp;mEBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (void*)(0)); 4. ShadersThe vertex shader takes two inputs because we defined two attribute pointers in VAO with location 0(position) and 1(color). 12345678910111213141516171819// VAO VBO Shaderconst char* VAOVBOVertexShader = VERTEX_SHADER( layout(location = 0) in vec3 aPosition; layout(location = 1) in vec4 aColor; out vec4 vColor; void main() { gl_Position = vec4(aPosition, 1.0); vColor = aColor; });const char* VAOVBOFragmentShader = FRAGMENT_SHADER( precision mediump float; in vec4 vColor; out vec4 FragColor; void main() { FragColor = vColor; }); 5. DemoComplete code to setup VAO, VBO and EBO. 123456789101112131415161718192021222324252627282930313233343536GLfloat vertices[4 * (3 + 4)] = { // Vertex positions followed by color attributes -0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, // v0, c0 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, // v1, c1 0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, // v2, c2 0.5f, 0.5f, 0.0f, 0.5f, 1.0f, 1.0f, 1.0f // v3, c3};GLushort indices[6] = {0, 1, 2, 0, 2, 3};LOGD(&quot;VAOVBO sample creates shader.&quot;);mShaderProgram = GLUtils::CreateProgram(VAOVBOVertexShader, VAOVBOFragmentShader, mVertexShader, mFragmentShader);// Generate VAO and define how data is storedglGenVertexArrays(1, &amp;mVAO);glBindVertexArray(mVAO);// Generate VBO and load dataglGenBuffers(1, &amp;mVBO);glBindBuffer(GL_ARRAY_BUFFER, mVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// Generate EBO and load dataglGenBuffers(1, &amp;mEBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// Specify the layout of the vertex dataglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(0));glEnableVertexAttribArray(0);glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(3 * sizeof(float)));glEnableVertexAttribArray(1);// Unbind the VAO (it's a good practice to unbind any VAO to prevent accidental modification)glBindVertexArray(GL_NONE); Drawing code 123456glClear(GL_STENCIL_BUFFER_BIT | GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);glClearColor(1.0, 1.0, 1.0, 1.0);glUseProgram(mShaderProgram);glBindVertexArray(mVAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (void*)(0));glBindVertexArray(GL_NONE); References https://github.com/githubhaohao/NDK_OpenGLES_3_0 https://learnopengl.com/Getting-started/Hello-Triangle","link":"/CGV/cgv-learn-opengles3/"},{"title":"Learn OpenGLES 4","text":"Framebuffer. Source code: https://github.com/chuzcjoe/learnopengles 1. FrameBuffersFramebuffer is a portion of memory in GPU that contains data(color buffer, depth buffer and stencil buffer) representing all pixels in a video frame. It is an off-screen rendering destination where you can render images or perform post-processing effects before displaying the final result on the screen. What we have done so far are on top of the render buffers attached to the default framebuffer. OpenGLES allows us to define our own framebuffer. 2. Create framebuffer123GLuint mFBO;glGenFramebuffers(1, &amp;mFBO);glBindFramebuffer(GL_FRAMEBUFFER, mFBO); After binding to a framebuffer, all the read &amp; write operations will affect the current bound framebuffer. 3. AttachmentA valid framebuffer needs to: Attach at least one buffer(color, depth, stencil) At least one color attachment. Attachments should have reserved memory. Each buffer should have the same number of samples. 1234567891011121314GLuint mFBO;GLuint mOnScreenTextureID;glGenFramebuffers(1, &amp;mFBO);glBindFramebuffer(GL_FRAMEBUFFER, mFBO);glGenTextures(1, &amp;mOnScreenTextureID);glBindTexture(GL_TEXTURE_2D, mOnScreenTextureID);glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mImage.width, mImage.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);// attach texture to framebufferglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mOnScreenTextureID, 0); 4. Config VAO, VBO and EBO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283GLfloat vertices[] = { -1.0f, 1.0f, 0.0f, // Top left -1.0f, -1.0f, 0.0f, // Bottom left 1.0f, -1.0f, 0.0f, // Bottom right 1.0f, 1.0f, 0.0f, // Top right};GLfloat onScreenTexCoords[] = { 0.0f, 0.0f, // top left 0.0f, 1.0f, // bottom left 1.0f, 1.0f, // bottom right 1.0f, 0.0f // top right};GLfloat offScreenTexCoords[] = { 0.0f, 1.0f, // top left 0.0f, 0.0f, // bottom left 1.0f, 0.0f, // bottom right 1.0f, 1.0f // top right};GLushort indices[] = {0, 1, 2, 0, 2, 3 };glGenVertexArrays(2, mVAO);// bind first VAO for offscreen renderingglBindVertexArray(mVAO[0]);glGenBuffers(3, mVBO);glBindBuffer(GL_ARRAY_BUFFER, mVBO[0]);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(0));glEnableVertexAttribArray(0);glBindBuffer(GL_ARRAY_BUFFER, mVBO[1]);glBufferData(GL_ARRAY_BUFFER, sizeof(offScreenTexCoords), offScreenTexCoords, GL_STATIC_DRAW);glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(0));glEnableVertexAttribArray(2);glGenBuffers(1, &amp;mEBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// end of first VAO// bind second VAO for onscreen renderingglBindVertexArray(mVAO[1]);glBindBuffer(GL_ARRAY_BUFFER, mVBO[0]);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(0));glEnableVertexAttribArray(0);glBindBuffer(GL_ARRAY_BUFFER, mVBO[2]);glBufferData(GL_ARRAY_BUFFER, sizeof(onScreenTexCoords), onScreenTexCoords, GL_STATIC_DRAW);glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(0));glEnableVertexAttribArray(1);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEBO);glBindVertexArray(GL_NONE);// end of second VAO// image textureglGenTextures(1, &amp;mOffScreenTextureID);glBindTexture(GL_TEXTURE_2D, mOffScreenTextureID);glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mImage.width, mImage.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, mImage.planes[0]);glBindTexture(GL_TEXTURE_2D, GL_NONE);// FrameBufferglGenFramebuffers(1, &amp;mFBO);glBindFramebuffer(GL_FRAMEBUFFER, mFBO);glGenTextures(1, &amp;mOnScreenTextureID);glBindTexture(GL_TEXTURE_2D, mOnScreenTextureID);glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mImage.width, mImage.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mOnScreenTextureID, 0);if (glCheckFramebufferStatus(GL_FRAMEBUFFER)!= GL_FRAMEBUFFER_COMPLETE) { LOGE(&quot;FBOSample::CreateFrameBufferObj glCheckFramebufferStatus status != GL_FRAMEBUFFER_COMPLETE&quot;); return;}glBindTexture(GL_TEXTURE_2D, GL_NONE);glBindFramebuffer(GL_FRAMEBUFFER, GL_NONE); 4. Shaders12345678910111213141516171819202122232425262728293031323334353637383940414243// FrameBuffer Shaderconst char* FBOOFFScreenVertexShader = VERTEX_SHADER( layout(location = 0) in vec3 aPosition; layout(location = 2) in vec2 aTexCoord; out vec2 vTexCoord; void main() { gl_Position = vec4(aPosition, 1.); vTexCoord = aTexCoord; });const char* FBOOFFScreenFragmentShader = FRAGMENT_SHADER( precision mediump float; in vec2 vTexCoord; uniform sampler2D offScreenTexture; out vec4 FragColor; void main() { vec4 color = texture(offScreenTexture, vTexCoord); float gray = color.r * 0.299 + color.g * 0.587 + color.b * 0.114; FragColor = vec4(vec3(gray), 1.0); });const char* FBOONScreenVertexShader = VERTEX_SHADER( layout(location = 0) in vec3 aPosition; layout(location = 1) in vec2 aTexCoord; out vec2 vTexCoord; void main() { gl_Position = vec4(aPosition, 1.); vTexCoord = aTexCoord; });const char* FBOONScreenFragmentShader = FRAGMENT_SHADER( precision mediump float; in vec2 vTexCoord; uniform sampler2D onScreenTexture; out vec4 FragColor; void main() { FragColor = texture(onScreenTexture, vTexCoord); // FragColor = vec4(0.0, 1.0, 0.0, 1.0); }); 5. DrawTo use framebuffer for off-screen rendering, we need two passes(draw twice). 123456789101112131415161718192021222324252627282930313233343536glViewport(0, 0, mImage.width, mImage.height);// Off-screen renderingglBindFramebuffer(GL_FRAMEBUFFER, mFBO);glClearColor(0.1f, 0.1f, 0.1f, 1.0f);glClear(GL_COLOR_BUFFER_BIT);glUseProgram(mFBOProgram);glBindVertexArray(mVAO[0]);glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, mOffScreenTextureID);glUniform1i(mOffScreenSamplerLoc, 0);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (void*)(0));glBindVertexArray(GL_NONE);glBindTexture(GL_TEXTURE_2D, GL_NONE);GLenum error = glGetError();if (error != GL_NO_ERROR) { LOGE(&quot;OpenGL error after off-screen rendering: %d&quot;, error);}// On-screen renderingglBindFramebuffer(GL_FRAMEBUFFER, 0);glViewport(0, 0, width, height);glUseProgram(mShaderProgram);glBindVertexArray(mVAO[1]);glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, mOnScreenTextureID);glUniform1i(mOnScreenSamplerLoc, 0);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (void*)(0));glBindTexture(GL_TEXTURE_2D, GL_NONE);glBindVertexArray(GL_NONE);error = glGetError();if (error != GL_NO_ERROR) { LOGE(&quot;OpenGL error after on-screen rendering: %d&quot;, error);} References https://learnopengl.com/Advanced-OpenGL/Framebuffers https://github.com/githubhaohao/NDK_OpenGLES_3_0?tab=readme-ov-file","link":"/cpp/cgv-learn-opengles-4/"},{"title":"Mu Transform","text":"Mu transform is an image enhancement technique. In this post, we will introduce 3 variants of mu transform. In image processing, Mu Transform (μ-Transform) is a non-linear transformation used to enhance image contrast, particularly in applications like medical imaging and remote sensing. It is a type of contrast enhancement technique that adjusts pixel intensities to improve visibility of details in an image. 1. Generalized Mu Transform$$\\begin{equation}I^{\\prime} = \\frac{I^{\\mu}}{I^{\\mu} + \\lambda(1 - I)^{\\mu}}\\end{equation}$$ where: $I$ is the normalized input pixel intensity (ranging from 0 to 1). $I^{\\prime}$ is the transformed output pixel intensity. $\\mu$ is the transformation parameter that controls the contrast enhancement. $\\lambda$ controls the balance between bright and dark regions. When $\\lambda &gt; 1$, it increases contrast in bright regions. When $\\lambda &lt; 1$, it enhances dark regions. 2. Log-Mu TransformThis variant combines the logarithmic transformation with the Mu Transform to enhance details in both dark and bright regions: $$\\begin{equation}I^{\\prime} = log(1 + c \\times \\frac{I^{\\mu}}{I^{\\mu} + (1 - I)^{\\mu}})\\end{equation}$$ where $c$ is a scaling constant. This variant is useful for HDR (High Dynamic Range) imaging. 3. Adaptive Mu TransformInstead of using a fixed $\\mu$ for the entire image, an adaptive version computes $\\mu$ based on local image statistics (like mean or variance). A common approach is: $$\\begin{equation}\\mu(x, y) = \\alpha + \\beta \\times Var(I_{local})\\end{equation}$$ where: $\\alpha$ and $\\beta$ are user-defined parameters. $Var(I_{local})$ is the local variance around pixel $(x,y)$. This allows spatially adaptive contrast enhancement, which is useful in medical imaging and low-light conditions. 4. Exampleexmaple.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import cv2import numpy as npimport matplotlib.pyplot as pltdef apply_mu_transform(image, transform_func, **kwargs): &quot;&quot;&quot;Applies Mu Transform to each RGB channel separately.&quot;&quot;&quot; channels = cv2.split(image) # Split into R, G, B transformed_channels = [transform_func(ch, **kwargs) for ch in channels] return cv2.merge(transformed_channels) # Merge back to RGBdef generalized_mu_transform(image, mu=2.0, lambda_=1.0): &quot;&quot;&quot;Generalized Mu Transform for RGB images.&quot;&quot;&quot; I = image.astype(np.float32) / 255.0 # Normalize I_transformed = (I**mu) / (I**mu + lambda_ * (1 - I)**mu) return (I_transformed * 255).astype(np.uint8) # Convert backdef log_mu_transform(image, mu=2.0, c=1.0): &quot;&quot;&quot;Log-Mu Transform for RGB images.&quot;&quot;&quot; I = image.astype(np.float32) / 255.0 I_mu = (I**mu) / (I**mu + (1 - I)**mu) I_transformed = np.log1p(c * I_mu) I_transformed /= np.max(I_transformed) # Normalize return (I_transformed * 255).astype(np.uint8)def adaptive_mu_transform(image, alpha=1.0, beta=10.0): &quot;&quot;&quot;Adaptive Mu Transform for RGB images (local contrast-based).&quot;&quot;&quot; I = image.astype(np.float32) / 255.0 kernel_size = 7 mean_local = cv2.blur(I, (kernel_size, kernel_size)) variance_local = cv2.blur(I**2, (kernel_size, kernel_size)) - mean_local**2 mu_adaptive = alpha + beta * variance_local I_transformed = (I**mu_adaptive) / (I**mu_adaptive + (1 - I)**mu_adaptive) return (I_transformed * 255).astype(np.uint8)# Load RGB imageimage = cv2.imread(&quot;save.jpg&quot;)image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # Convert BGR to RGB# Apply Mu Transformsgen_mu_img = apply_mu_transform(image, generalized_mu_transform, mu=3.0, lambda_=1.0)log_mu_img = apply_mu_transform(image, log_mu_transform, mu=3.0, c=2.0)adaptive_mu_img = apply_mu_transform(image, adaptive_mu_transform, alpha=1.0, beta=5.0)# Plot results in a 2x2 gridplt.figure(figsize=(10, 10))plt.subplot(2, 2, 1)plt.imshow(image)plt.title(&quot;Original&quot;)plt.axis(&quot;off&quot;)plt.subplot(2, 2, 2)plt.imshow(gen_mu_img)plt.title(&quot;Generalized Mu Transform&quot;)plt.axis(&quot;off&quot;)plt.subplot(2, 2, 3)plt.imshow(log_mu_img)plt.title(&quot;Log-Mu Transform&quot;)plt.axis(&quot;off&quot;)plt.subplot(2, 2, 4)plt.imshow(adaptive_mu_img)plt.title(&quot;Adaptive Mu Transform&quot;)plt.axis(&quot;off&quot;)plt.tight_layout() # Adjust layout for better spacingplt.show()","link":"/CGV/cgv-mu-transform/"},{"title":"Rendering Using Native OpenGL on Android - 1","text":"Use Android SurfaceView for rendering surface. In native code, create a rendering thread and call OpenGL for rendering in the same thread. 1. Workflow 2. DemoSource code can be found on my github page: https://github.com/chuzcjoe/nativegl On Android side, we start/stop rendering at different stages of the SurfaceView lifecycle. 1234567891011121314151617class SurfaceViewHolder : SurfaceHolder.Callback { override fun surfaceChanged(holder: SurfaceHolder, format: Int, w: Int, h: Int) { JNIProxy.setSurface(holder.surface) JNIProxy.startRender() } override fun surfaceCreated(holder: SurfaceHolder) { JNIProxy.calPixel() JNIProxy.setSurface(holder.surface) JNIProxy.startRender() } override fun surfaceDestroyed(holder: SurfaceHolder) { JNIProxy.stopRender() JNIProxy.setSurface(null) }} To start rendering, we will start a new rendering thread. In this new thread, we will initialize EGL settings and start drawing with OpenGL APIs. 123456789101112131415161718192021222324252627282930313233343536373839404142434445void GLBase::StartRenderThread(){ if (!init){ _th = std::thread(RenderThread, this); init = !init; } running = true;}void GLBase::RenderThread(GLBase* obj){ obj-&gt;RenderLoop();}void GLBase::RenderLoop(){ bool rendering = true; while (rendering) { if (running){ // process incoming messages if (eglSetting._msg == EGLSetting::RenderThreadMessage::MSG_WINDOW_SET) { initEGL(); } if (eglSetting._msg == EGLSetting::RenderThreadMessage::MSG_RENDER_LOOP_EXIT) { rendering = false; DestroyRender(); } eglSetting._msg = EGLSetting::RenderThreadMessage::MSG_NONE; if (!window_set) { usleep(16000); continue; } if (eglSetting._display) { std::lock_guard&lt;std::mutex&gt; lock(eglSetting._mutex); DrawFrame(); if (!eglSwapBuffers(eglSetting._display, eglSetting._surface)) { LOG_INFO(&quot;GLrenderS::eglSwapBuffers() returned error %d&quot;, eglGetError()); } } else { usleep(16000); } } else { usleep(16000); } }} If everything works well, you should see a green triangle at the center of the screen.","link":"/CGV/cgv-native-opengl-android/"},{"title":"Context, State and Resource in OpenGL","text":"OpenGL is fundamentally a state machine, and these three concepts—Context, State, and Resource—play a crucial role in its operation. 1. IntroductionContextAn OpenGL context is an encapsulation of the OpenGL state and resources tied to a specific rendering instance (like a window). It is created and managed by the windowing system (e.g., GLFW, GLUT, WGL, GLX, EGL). StateOpenGL is a state machine, meaning it remembers configurations until explicitly changed. ResourceOpenGL resources refer to objects that get created on GPU and store data used for rendering. At its core, OpenGL maintains all states and buffer bindings. When a drawing command is issued, it relies on the current state of these settings to determine what and how to render. As illustrated in the flowchart above, modifying its static state or buffer bindings—whether for existing or newly created buffers—directly affects the rendering output. This characteristic makes OpenGL a state machine, as its rendering results depend on its current state. 2. Shared ContextA shared OpenGL context allows multiple OpenGL contexts to share certain GPU resources, such as textures, buffers, shaders, and VAOs, across different threads or windows. This enables efficient resource management and avoids redundant duplication of data. While the context can be shared across threads/windows, each thread/window should maintain its own state, which means that the states are not shared. It is worth noting that FBOs are not shared across OpenGL contexts. They are context-specific objects designed to handle off-screen rendering for a specific OpenGL context.","link":"/CGV/cgv-opengl-context-state-resource/"},{"title":"Rendering Using Native OpenGL on Android - 2","text":"We will load a jpeg file as a texture image and render it on the screen. 1. IntroductionPlease check my previous post to learn how to render a simple triangle on the screen using native OpenGL on Android.https://chuzcjoe.github.io/2024/06/19/cgv-native-opengl-android/ We will continue to use the same codebase to add textures. You can find the source code: https://github.com/chuzcjoe/nativegl/tree/load_texture In this project, we also need third party library(libjpeg) for loading a jpeg image and use it as our texture for rendering. For more details on how to compile libjpeg and add it to our project, please check out my another post: https://chuzcjoe.github.io/2024/06/22/misc-cross-compile-libjpeg-for-android-armv8a/ In my provided source code, I’ve included everything you need. You should be able to run it on most of the armv8a arch Android devices without any issues. 2. DetailsMost part of the code should remain the same except for some additional operations to load and bind textures. A customized function to load a jpeg. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051unsigned char *GLRender::loadJPEG(const char *filename, int &amp;width, int &amp;height) { std::ifstream file(filename, std::ios::binary | std::ios::ate); if (!file.is_open()) { std::cerr &lt;&lt; &quot;Error: Cannot open file &quot; &lt;&lt; filename &lt;&lt; std::endl; return nullptr; } std::streamsize fileSize = file.tellg(); file.seekg(0, std::ios::beg); std::vector&lt;unsigned char&gt; buffer(fileSize); if (!file.read(reinterpret_cast&lt;char*&gt;(buffer.data()), fileSize)) { std::cerr &lt;&lt; &quot;Error: Cannot read file &quot; &lt;&lt; filename &lt;&lt; std::endl; return nullptr; } tjhandle tjInstance = tjInitDecompress(); if (tjInstance == nullptr) { std::cerr &lt;&lt; &quot;Error: tjInitDecompress failed&quot; &lt;&lt; std::endl; return nullptr; } int jpegSubsamp, jpegColorspace; if (tjDecompressHeader3(tjInstance, buffer.data(), buffer.size(), &amp;width, &amp;height, &amp;jpegSubsamp, &amp;jpegColorspace) != 0) { std::cerr &lt;&lt; &quot;Error: tjDecompressHeader3 failed: &quot; &lt;&lt; tjGetErrorStr() &lt;&lt; std::endl; tjDestroy(tjInstance); return nullptr; } std::vector&lt;unsigned char&gt; imageBuffer(width * height * tjPixelSize[TJPF_RGB]); if (tjDecompress2(tjInstance, buffer.data(), buffer.size(), imageBuffer.data(), width, 0, height, TJPF_RGB, 0) != 0) { std::cerr &lt;&lt; &quot;Error: tjDecompress2 failed: &quot; &lt;&lt; tjGetErrorStr() &lt;&lt; std::endl; tjDestroy(tjInstance); return nullptr; } // Flip the image vertically unsigned char *flippedImage = new unsigned char[width * height * tjPixelSize[TJPF_RGB]]; int rowSize = width * tjPixelSize[TJPF_RGB]; for (int y = 0; y &lt; height; ++y) { std::copy( imageBuffer.begin() + (height - 1 - y) * rowSize, imageBuffer.begin() + (height - y) * rowSize, flippedImage + y * rowSize ); } tjDestroy(tjInstance); return flippedImage;} Prepare and config texture. 123456789101112131415161718192021222324252627282930313233343536373839404142434445void GLRender::surfaceCreate() { tProgram = createProgram(vertexShader, fragmentShader); aPositionLocation = glGetAttribLocation(tProgram, &quot;a_Position&quot;); aTexturePosition = glGetAttribLocation(tProgram, &quot;a_Texture&quot;); glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); glBindVertexArray(VAO); int width, height; glGenTextures(1, &amp;_texture); glActiveTexture(GL_TEXTURE0); // activated by default glBindTexture(GL_TEXTURE_2D, _texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); auto data = loadJPEG(&quot;/data/local/tmp/jpeg_demo/hdr.jpg&quot;, width, height); if (data) { // generate texture glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); LOG_INFO(&quot;load texture success, width: %d, height: %d\\n&quot;, width, height); } else { LOG_ERROR(&quot;load texture error&quot;); } glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); glVertexAttribPointer(aPositionLocation, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(aPositionLocation); glVertexAttribPointer(aTexturePosition, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(aTexturePosition); glUseProgram(tProgram); glUniform1i(glGetUniformLocation(tProgram, &quot;texture_load&quot;), 0);} Modify shaders. 123456789101112131415161718const char* vertexShader = VERTEX_SHADER( attribute vec3 a_Position; attribute vec2 a_Texture; varying vec2 TexCoord; void main() { gl_Position = vec4(a_Position, 1.0); TexCoord = a_Texture; });const char* fragmentShader = FRAGMENT_SHADER( precision mediump float; varying vec2 TexCoord; uniform sampler2D texture_load; void main() { gl_FragColor = texture2D(texture_load, TexCoord); }); If you run the demo app, you should see a nice image on the entire screen. The result looks really simple, however, we managed everything with OpenGL.","link":"/CGV/cgv-texture-render-android/"},{"title":"Setting up Vulkan on MacOS","text":"Setting up Vulkan development environment on MacOS using Xcode. Download the latest SDK from the LunarG website Extract the downloaded file and install SDK. Remember your installed path. Install GLFW 1brew install glfw Install GLM 1brew install glm Configure Xcode Start a new project and choose Command Line Tool. For the language, select C++. Add the following code example to main.cpp. main.cpp1234567891011121314151617181920212223242526272829303132333435#define GLFW_INCLUDE_VULKAN#include &lt;GLFW/glfw3.h&gt;#define GLM_FORCE_RADIANS#define GLM_FORCE_DEPTH_ZERO_TO_ONE#include &lt;glm/vec4.hpp&gt;#include &lt;glm/mat4x4.hpp&gt;#include &lt;iostream&gt;int main() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); GLFWwindow* window = glfwCreateWindow(800, 600, &quot;Vulkan window&quot;, nullptr, nullptr); uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, nullptr); std::cout &lt;&lt; extensionCount &lt;&lt; &quot; extensions supported\\n&quot;; glm::mat4 matrix; glm::vec4 vec; auto test = matrix * vec; while(!glfwWindowShouldClose(window)) { glfwPollEvents(); } glfwDestroyWindow(window); glfwTerminate(); return 0;} You will see a lot of error messages at the beginning. We need to configure the project. Select the project and go to Build Settings. Find Header Search Paths and Library Search Paths. For Header Search Paths, add links: /usr/local/include [your_vk_location]/macOS/include For Library Search Paths, add links: /usr/local/lib [your_vk_location]/macOS/lib Then go to Build Phases tab and add glfw3 and vulkan dynamic libraries. After adding these libraries, in the same tab, open Copy Files, change Destination to “Frameworks”, clear the subpath and uncheck “Copy only when installing”. Click “+” and add all the three libraries here. Run demo Run the project and you should see a Vulkan window displaying on your screen. Reference https://vulkan-tutorial.com/Development_environment#page_MacOS","link":"/CGV/cgv-vulkan-setup-macos/"},{"title":"Data Transfer in Vulkan","text":"In this post, we will discuss how data is transferred between hosts and devices. In Vulkan, there are two main types of resources: VkBuffer and VkImage. Each resource has a VkDeviceMemory associated with it, which is bound using either vkBindBufferMemory or vkBindImageMemory.` To upload or transfer data to GPU memory for compute or rendering, we typically use an intermediate data layer called a staging buffer. A staging buffer is not a special hardware type; it’s simply a VkBuffer created with memory properties that make it Host (CPU) Visible, allowing us to upload or read data from the host. Vulkan provides a way to write to a VkBuffer through vkMapMemory, which lets us access a specified range of VkDeviceMemory via a pointer. Once mapped, we can use memcpy() to write data directly. As illustrated above, staging buffers usually reside in system RAM for discrete GPUs, whereas on integrated GPUs, the same physical RAM is shared between the CPU and GPU. For a staging buffer to be host-visible, its memory must be allocated with VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT. The second flag is optional but ensures that the host and device see updated data without explicitly calling vkFlushMappedMemoryRanges or vkInvalidateMappedMemoryRanges. After writing data to a staging buffer, we can transfer it to GPU memory. The most common Vulkan commands for this are vkCmdCopyBuffer and vkCmdCopyBufferToImage. For VkDeviceMemory allocated on the device side, the recommended property is VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT. To retrieve compute or rendering results from the GPU, we can use vkCmdCopyImageToBuffer to copy data from a GPU VkImage into a staging buffer that is CPU-visible, making it easy to read the results in C++. Likewise, vkCmdCopyBuffer can be used to copy data between a staging buffer and a GPU buffer, as long as both are of type VkBuffer. There is one special case. Data doesn’t have to be in GPU memory for shader programs to fetch the resources. For example, as the figure shown above, staging buffer can also be used directly as descriptor sets for shaders to use. In other words, we can bind a host-visible “staging” buffer directly to shaders as a uniform/storage/vertex/index buffer. Vulkan lets shaders read from any buffer as long as: the buffer was created with the right usage flags (UNIFORM_BUFFER_BIT, STORAGE_BUFFER_BIT, VERTEX_BUFFER_BIT, etc.). GPU can access host-visible memory via PCIe. Ideally, it is not a good idea to directly bind staging buffer for shaders to use, though it should be fine for small amount of data(like UBO). More Vulkan visualizations: https://chuzcjoe.github.io/CGV/cgv-vulkan-visualization/","link":"/CGV/cgv-vulkan-data-transfer/"},{"title":"YUV Color Format","text":"What is YUV?How is it stored?What are the variants? 1. What is YUV?YUV format represents an image as three planes: Y, U and V. Y is the luma plane. U and V are reffered to as the chroma planes, which are basically the colors. All the YUV formats have these three planes, and differ by the different orderings of them. YUV is also referred as YCbCr (Y, color blue, color red). Note: U-Cb, V-Cr. 2. Chroma SubsamplingVarious YUV formats, like 420, 422, and others, are often mentioned. This is because downsampling is typically applied to chroma planes, considering that the human eye is less perceptive to color than luminance. So, we could save more space by keeping less information about colors. The subsampling scheme is commonly expressed as a three-part ratio J:a:b (e.g. 4:2:2), that describe the number of luminance and chrominance samples in a conceptual region that is J pixels wide and 2 pixels high. J: horizontal sampling reference (width of the conceptual region). Usually, 4. a: number of chrominance samples (Cr, Cb) in the first row of J pixels. b: number of changes of chrominance samples (Cr, Cb) between first and second row of J pixels. b has to be either zero or equal to a. Let’s assume that: Image resolution is W∗HW*H W∗H. J:a:b = 4:2:0 (YUV420) For YUV420, each U(V) corresponds to a 2x2 Y block. In other words, one pair of UV corresponds to 4(2x2) Y pixels. Then we have resolutions for Cb and Cr planes: Cb plane: W/2∗H/2W/2 * H/2 W/2∗H/2. Cr plane: W/2∗H/2W/2 * H/2 W/2∗H/2. 3. Pixel OrderYUV formats are either: Packed (or interleaved) Planar (the names of those formats often end with “p”) Semi-planar (the names of those formats often end with “sp”) 3.1 Packed(interleaved)Y1U1Y2V1 Y3U2Y4V2 ... ... 3.2 Planar[Y1Y2......][Cb1Cb2......][Cr1Cr2.......] 3.3 Semi-planar[Y1Y2......][Cb1Cr1Cb2Cr2......] 3.4 Different types of YUV420 YUV420 format Order Detail i420 Y+U+V Three planes are separated. U comes before V. YV12 Y+V+U Three planes are separated. V comes before U. NV12 Y+UV Y plane is separated from UV plane. UVs are interleaved. U comes before V. NV21 Y+U+V Y plane is separated from UV plane. UVs are interleaved. V comes before U. 4. YUV420 to YUV A general YUV420 example and its YUV conversion. Based on the above figure, let’s say we want to get YUV(5,2)YUV(5,2) YUV(5,2), which is Y33U8V8Y_{33}U_{8}V_{8} Y33​U8​V8​. What we need from i420i420 i420 are: Y33→i420(5,2)U8→i420(7,1)V8→i420(8,4)Y_{33} \\rightarrow i420(5,2) \\\\ U_8 \\rightarrow i420(7,1) \\\\ V_8 \\rightarrow i420(8,4)Y33​→i420(5,2)U8​→i420(7,1)V8​→i420(8,4) The position of Y in i420 should keep the same as in YUV. So we have: Y(x,y)=i420(x,y)Y(x,y) = i420(x,y) Y(x,y)=i420(x,y) Then, in order to get the position of U8U_8 U8​ in i420, let’s first compute the offset in U plane given x,y,wx, y, w x,y,w i=x2∗w2+y2i = \\frac{x}{2} * \\frac{w}{2} + \\frac{y}{2}i=2x​∗2w​+2y​ In this case, i=52∗62+22=7i = \\frac{5}{2} * \\frac{6}{2} + \\frac{2}{2} = 7 i=25​∗26​+22​=7, which is expected due to zero indexing. Then, we can get the position of U8U_8 U8​ in i420 as: U(x,y)=i420(i+w∗hw,(i+w∗h)%w)U(x, y) = i420(\\frac{i + w * h}{w}, (i + w * h) \\% w)U(x,y)=i420(wi+w∗h​,(i+w∗h)%w) To get the position of V8V_8 V8​ in i420, we need to skip the U plane and repeat the same compute. V(x,y)=i420(i+w∗h∗1.25w,(i+w∗h∗1.25)%w)V(x, y) = i420(\\frac{i + w * h * 1.25}{w}, (i + w * h * 1.25) \\% w)V(x,y)=i420(wi+w∗h∗1.25​,(i+w∗h∗1.25)%w) Other YUV420 formats such as YV12, NV12 and NV21 can also be converted to YUV in similar approaches. References https://en.wikipedia.org/wiki/Chroma_subsampling#Sampling_systems_and_ratios https://juejin.cn/post/7207637337572606007","link":"/CGV/cgv-yuv-format/"},{"title":"YUV and RGB Color Space Conversion","text":"YUV to RGB, RGB to YUV 1. IntroductionIn the YUV color format: Y (Luminance): Represents the brightness or intensity of the color. It carries the grayscale image information. U (Chrominance Blue): Represents the blue color difference, which is the difference between the blue component and the luminance (Y). It adds the blue color information to the image. V (Chrominance Red): Represents the red color difference, which is the difference between the red component and the luminance (Y). It adds the red color information to the image. 2. RGB to YUVBased on the definition above, converting RGB to YUV involves combining the RGB channels in specific proportions. $$ Y = K_r * R + K_g * G + K_b * B \\\\ U = \\frac{1}{2} * \\frac{B-Y}{1-K_b} \\\\ V = \\frac{1}{2} * \\frac{R-Y}{1-K_r} $$ $ K_r, K_g, K_b $ are different ratios to blend RGB channels. NoteLet’s assume the input RGB image has values ranging from 0 to 1. $ K_r + K_g + K_b = 1$ $ U \\in [-0.5, 0.5] $ $ V \\in [-0.5, 0.5] $ Several reasons for UV ranging from -0.5 to 0.5: Benifit Detail Centering Around Zero Zero represents no color difference from the luminance. Color Balance Allows for a balanced representation of color differences. This range is symmetric, ensuring equal representation for both positive and negative deviations from the luminance, which helps in accurately reconstructing the color during the conversion back to RGB. Normalization The range is normalized to fit within a compact interval, which is efficient for encoding and transmission. 3. XYZ Color SpaceThe XYZ color space, also known as the CIE 1931 color space, is a color space defined by the International Commission on Illumination (CIE) in 1931. It is based on human vision and is designed to be a device-independent representation of color. Here are the key components: The CIE color space has been transformed to a two-dimensional, horseshoe-shaped graph of the luminance (brightness) and chromaticity (color) values perceived by humans. The chromaticity coordinates of any point on the graph are labeled x and y (or Cx and Cy). XYZ and RGB color spaces can be converted interchangeably. From RGB to XYZ $$\\begin{equation}\\left[\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right]=\\left[\\begin{array}{lll}0.4124564 &amp; 0.3575761 &amp; 0.1804375 \\\\0.2126729 &amp; 0.7151522 &amp; 0.0721750 \\\\0.0193339 &amp; 0.1191920 &amp; 0.9503041\\end{array}\\right]\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]\\end{equation}$$ From XYZ to RGB $$\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]=\\left[\\begin{array}{ccc}3.2404542 &amp; -1.5371385 &amp; -0.4985314 \\\\-0.9692660 &amp; 1.8760108 &amp; 0.0415560 \\\\0.0556434 &amp; -0.2040259 &amp; 1.0572252\\end{array}\\right]\\left[\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right]$$ 4. BT709 and BT2020BT.709 and BT.2020 are standards developed by the International Telecommunication Union (ITU) for different aspects of video technology, specifically for encoding and broadcasting high-definition television (HDTV) and ultra-high-definition television (UHDTV), respectively. 4.1 BT.709(Rec.709) Detail Definition It is the standard for HDTV. Resolutio Typically used for 1080p (1920x1080 pixels) and 720p (1280x720 pixels) resolutions. Color Space Defines the color space used for HD video, specifying the RGB color primaries, white point (D65), and the transfer function (gamma curve). Color Primaries Red: (0.640, 0.330)Green: (0.300, 0.600)Blue: (0.150, 0.060) Transfer Function optical-electro transfer function: $$ V = 1.099L ^{0.45} - 0.099, V &gt; 0.018 $$ $$ V = 0.45L, V \\leq 0.018 $$ where V is the digital signal and L is the luminance, and both are in the range [0,1]. Bit Depth Usually 8-bit or 10-bit per channel. 4.2 BT.2020(Rec.2020) Detail Definition It is the standard for UHDTV, including 4K (3840x2160 pixels) and 8K (7680x4320 pixels) resolutions. Color Space Defines a wider color gamut compared to BT.709, aiming to cover a broader range of colors visible to the human eye. Color Primaries Red: (0.708, 0.292)Green: (0.170, 0.797)Blue: (0.131, 0.046) Transfer Function $$ \\begin{equation} E^{\\prime} = \\begin{cases} 4.5 E &amp; 0 \\leq E&lt;\\beta \\\\ \\alpha E^{0.45}-(\\alpha-1) &amp; \\beta \\leq E \\leq 1 \\\\ \\end{cases} \\end{equation} $$ 1. where E is the signal proportional to camera-input light intensity and E′ is the corresponding nonlinear signal. 2. where α = 1 + 5.5 * β ≈ 1.09929682680944 and β ≈ 0.018053968510807 (values chosen to achieve a continuous function with a continuous first derivative) Bit Depth Typically 10-bit or 12-bit per channel, allowing for higher color precision and better handling of HDR content. HDR Supports HDR, providing greater contrast and more vivid colors. 5. YUV and RGB Conversion5.1 For BT709As previously mentioned, the relationship between YUV and RGB can be defined as: $$Y = K_r * R + K_g * G + K_b * B \\\\U = \\frac{1}{2} * \\frac{B-Y}{1-K_b} \\\\V = \\frac{1}{2} * \\frac{R-Y}{1-K_r}$$ And RGB to XYZ can be defined as: $$\\begin{equation}\\left[\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right]=\\left[\\begin{array}{lll}0.4124 &amp; 0.3576 &amp; 0.1805 \\\\0.2126 &amp; 0.7152 &amp; 0.0722 \\\\0.0193 &amp; 0.1192 &amp; 0.9505\\end{array}\\right]\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]\\end{equation}$$ $Y$ in XYZ is essentially the luminance. So, $K_r=0.2126, K_g=0.7152, K_b=0.0722$. And we substitue the values to RGB-YUV euqation. $$\\begin{aligned}&amp; Y=0.2126 \\cdot R+0.7152 \\cdot G+0.0722 \\cdot B \\\\&amp; U=\\frac{B-Y}{1.8556} \\\\&amp; V=\\frac{R-Y}{1.5748}\\end{aligned}$$ By substituting $Y$ to the other two equations. $$\\begin{aligned}&amp; Y=0.212600 \\cdot R+0.715200 \\cdot G+0.072200 \\cdot B \\\\&amp; U=-0.114572 \\cdot R-0.385428 \\cdot G+0.5 \\cdot B \\\\&amp; V=0.5 \\cdot R-0.454153 \\cdot G-0.045847 \\cdot B\\end{aligned}$$ We can get the conversion matrix $M$ rom RGB to YUV, $$\\left[\\begin{array}{l}Y \\\\U \\\\V\\end{array}\\right]=\\left[\\begin{array}{ccc}0.212600 &amp; 0.715200 &amp; 0.072200 \\\\-0.114572 &amp; -0.385428 &amp; 0.500000 \\\\0.500000 &amp; -0.454153 &amp; -0.045847\\end{array}\\right] \\cdot\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]$$ To get the conversion matrix from YUV to RGB, we compute the inverse matrix $M^{-1}$ $$\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]=\\left[\\begin{array}{ccc}1.000000 &amp; -0.000000 &amp; 1.574800 \\\\1.000000 &amp; -0.187324 &amp; -0.468124 \\\\1.000000 &amp; 1.855600 &amp; -0.000000\\end{array}\\right] *\\left[\\begin{array}{l}Y \\\\U \\\\V\\end{array}\\right]$$ 5.2 For BT2020Similar to BT709, except that the conversion matrix from RGB to XYZ becomes: $$\\begin{equation}\\left[\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right]=\\left[\\begin{array}{lll}0.636958 &amp; 0.144617 &amp; 0.168881 \\\\0.262700 &amp; 0.678000 &amp; 0.059300 \\\\0.000000 &amp; 0.028073 &amp; 1.060985\\end{array}\\right]\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]\\end{equation}$$ I will start a new chapter to discuss how we can compute this conversion matrix. If we repeat the previous steps, we can get: $$\\left[\\begin{array}{l}Y \\\\U \\\\V\\end{array}\\right]=\\left[\\begin{array}{ccc}0.262700 &amp; 0.678000 &amp; 0.059300 \\\\-0.139630 &amp; -0.360370 &amp; 0.500000 \\\\0.500000 &amp; -0.459786 &amp; -0.040214\\end{array}\\right] *\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]$$ $$\\left[\\begin{array}{l}R \\\\G \\\\B\\end{array}\\right]=\\left[\\begin{array}{ccc}1.000000 &amp; -0.000000 &amp; 1.474600 \\\\1.000000 &amp; -0.164553 &amp; -0.571353 \\\\1.000000 &amp; 1.881400 &amp; -0.000000\\end{array}\\right] *\\left[\\begin{array}{l}Y \\\\U \\\\V\\end{array}\\right]$$ Refernce https://luminusdevices.zendesk.com/hc/en-us/articles/4414846186253-What-is-the-CIE-Color-Space-What-s-the-difference-between-CIE-1931-and-CIE-1976 https://www.oceanopticsbook.info/view/photometry-and-visibility/from-xyz-to-rgb https://www.color.org/chardata/rgb/BT709.xalter http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html","link":"/CGV/cgv-yuv-to-rgb/"},{"title":"Add GTest to C++ Projects","text":"Add GoogleTest framework to any C++ projects using CMake. 1. IntroductionThis tutorial demonstrates the seamless integration of the GoogleTest framework into your pre-existing C++ project to facilitate unit testing. Its user-friendly nature simplifies the process and allows for straightforward inclusion within your CMakeLists.txt for easy compilation. 2. Project StructureFor demonstration purpose, we created a simple project. 12345678910111213141516171819202122232425.├── CMakeLists.txt├── build├── googletest│ ├── BUILD.bazel│ ├── CMakeLists.txt│ ├── CONTRIBUTING.md│ ├── CONTRIBUTORS│ ├── LICENSE│ ├── MODULE.bazel│ ├── README.md│ ├── WORKSPACE│ ├── WORKSPACE.bzlmod│ ├── ci│ ├── docs│ ├── fake_fuchsia_sdk.bzl│ ├── googlemock│ ├── googletest│ └── googletest_deps.bzl├── src│ ├── main.cpp│ └── mathop.h└── tests ├── main.cpp └── test.cpp build/Generate build files. googletest/ 1git clone https://github.com/google/googletest.git src/mathop.hDefinitions of some simple math operations. 1234567891011121314151617181920212223242526#pragma once#include &lt;iostream&gt;template&lt;typename T&gt;class Math {public: T add(T a, T b) { return a + b; } T subtract(T a, T b) { return a - b; } T multiply(T a, T b) { return a * b; } T divide(T a, T b) { if (b == 0) { throw std::invalid_argument(&quot;Division by zero&quot;); } return a / b; }}; tests/main.cppEntrance for running all the unit test cases. 123456#include &quot;gtest/gtest.h&quot;int main(int argc, char **argv) { ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS();} tests/test.cppUnit test cases. 12345678910111213141516171819202122232425262728#include &lt;gtest/gtest.h&gt;#include &quot;mathop.h&quot;TEST(MathTest, Add) { Math&lt;int&gt; math; EXPECT_EQ(math.add(3, 4), 7); EXPECT_EQ(math.add(-1, -1), -2);}TEST(MathTest, Subtract) { Math&lt;int&gt; math; EXPECT_EQ(math.subtract(7, 5), 2); EXPECT_EQ(math.subtract(-1, -1), 0);}TEST(MathTest, Multiply) { Math&lt;int&gt; math; EXPECT_EQ(math.multiply(6, 2), 12); EXPECT_EQ(math.multiply(-1, -1), 1);}TEST(MathTest, Divide) { Math&lt;int&gt; math; EXPECT_EQ(math.divide(8, 2), 4); EXPECT_THROW(math.divide(8, 0), std::invalid_argument);} CMakeLists.txt 1234567891011121314151617181920212223242526272829cmake_minimum_required(VERSION 3.10)project(gtest_demo)# Specify the C++ standardset(CMAKE_CXX_STANDARD 14)set(CMAKE_CXX_STANDARD_REQUIRED True)# Add source filesset(SOURCES src/main.cpp)# Add main executableadd_executable(main ${SOURCES})# Add GoogleTestadd_subdirectory(googletest)include_directories(${gtest_SOURCE_DIR}/include ${gtest_SOURCE_DIR})include_directories(${CMAKE_SOURCE_DIR}/src)# Add test filesset(TEST_SOURCES tests/main.cpp tests/test.cpp)# Add an executable for testsadd_executable(runTests ${TEST_SOURCES})target_link_libraries(runTests gtest gtest_main) 3. Test12# Run all test cases./runTests 12345678910111213141516[==========] Running 4 tests from 1 test suite.[----------] Global test environment set-up.[----------] 4 tests from MathTest[ RUN ] MathTest.Add[ OK ] MathTest.Add (0 ms)[ RUN ] MathTest.Subtract[ OK ] MathTest.Subtract (0 ms)[ RUN ] MathTest.Multiply[ OK ] MathTest.Multiply (0 ms)[ RUN ] MathTest.Divide[ OK ] MathTest.Divide (0 ms)[----------] 4 tests from MathTest (0 ms total)[----------] Global test environment tear-down[==========] 4 tests from 1 test suite ran. (0 ms total)[ PASSED ] 4 tests. 12# Run single test./runTests --gtest_filter=MathTest.Add 1234567891011Note: Google Test filter = MathTest.Add[==========] Running 1 test from 1 test suite.[----------] Global test environment set-up.[----------] 1 test from MathTest[ RUN ] MathTest.Add[ OK ] MathTest.Add (0 ms)[----------] 1 test from MathTest (0 ms total)[----------] Global test environment tear-down[==========] 1 test from 1 test suite ran. (0 ms total)[ PASSED ] 1 test.","link":"/misc/cpp-add-gtest-to-cpp-project/"},{"title":"Design An Allocator","text":"Control how memory is allocated and deallocated. 1. IntroductionCustom allocators in C++ allow developers to control how memory is allocated and deallocated, providing opportunities for optimization and resource management tailored to specific needs. The Standard Template Library (STL) uses allocators to manage memory, and by default, it uses std::allocator, but we can provide our own allocator for customized behavior. 2. Example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstring&gt;template&lt;typename T&gt;class Allocator {public: Allocator() noexcept { std::cout &lt;&lt; &quot;Allocator()\\n&quot;; } ~Allocator() noexcept { std::cout &lt;&lt; &quot;~Allocator()\\n&quot;; } T* allocate(std::size_t n) { std::cout &lt;&lt; &quot;allocating &quot; &lt;&lt; n &lt;&lt; &quot; element(s) of size &quot; &lt;&lt; sizeof(T) &lt;&lt; '\\n'; return static_cast&lt;T*&gt;(::operator new(n * sizeof(T))); } void deallocate(T* p, std::size_t n) noexcept { std::cout &lt;&lt; &quot;deallocating &quot; &lt;&lt; n &lt;&lt; &quot; elements of size &quot; &lt;&lt; sizeof(T) &lt;&lt; &quot;.\\n&quot;; ::operator delete(p); } // Construct an element of type U at the given memory location template &lt;typename U, typename... Args&gt; void construct(U* p, Args&amp;&amp;... args) { std::cout &lt;&lt; &quot;Constructing element.\\n&quot;; new (p) U(std::forward&lt;Args&gt;(args)...); } // Destroy an element of type U at the given memory location template &lt;typename U&gt; void destroy(U* p) { std::cout &lt;&lt; &quot;Destroying element: &quot; &lt;&lt; *p &lt;&lt; '\\n'; p-&gt;~U(); }};template &lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;class Array {public: using allocator_type = Alloc; using value_type = T; using size_type = std::size_t; using pointer = T*; using const_pointer = const T*; using reference = value_type&amp;; using const_reference = const value_type&amp;; Array(size_type size) : _size(size), _data(_alloc.allocate(_size)), _pos(0){ for (size_type i = 0; i &lt; _size; ++i) { _alloc.construct(_data + i); } } ~Array() { for (size_type i = 0; i &lt; _size; ++i) { _alloc.destroy(_data + i); } _alloc.deallocate(_data, _size); } void add(T&amp;&amp; val) { new (&amp;_data[_pos++]) T(std::move(val)); } reference operator[](size_type index) { return _data[index]; } const_reference operator[](size_type index) const { return _data[index]; } size_type size() const noexcept { return _size; }private: size_type _size; pointer _data; allocator_type _alloc; int _pos;};int main() { /* Example 1: String allocation */ std::cout &lt;&lt; &quot;Example 1\\n&quot;; Allocator&lt;std::string&gt; allocator; std::string* p = allocator.allocate(3); allocator.construct(p, &quot;A&quot;); allocator.construct(p + 1, &quot;B&quot;); allocator.construct(p + 2, &quot;C&quot;); for (std::size_t i = 0; i &lt; 3; ++i) { std::cout &lt;&lt; p[i] &lt;&lt; '\\n'; } for (std::size_t i = 0; i &lt; 3; ++i) { allocator.destroy(p + i); } allocator.deallocate(p, 3); /* Example 2: Array allocation */ std::cout &lt;&lt; &quot;Example 2\\n&quot;; Array&lt;int, Allocator&lt;int&gt;&gt; arr(3); arr.add(1); arr.add(2); arr.add(3); for (int i = 0; i &lt; arr.size(); ++i) { std::cout &lt;&lt; arr[i] &lt;&lt; '\\n'; }} 12345678910111213141516171819202122232425262728Example 1Allocator()allocating 3 element(s) of size 32Constructing element.Constructing element.Constructing element.ABCDestroying element: ADestroying element: BDestroying element: Cdeallocating 3 elements of size 32.Example 2allocating 3 element(s) of size 4Allocator()Constructing element.Constructing element.Constructing element.123Destroying element: 1Destroying element: 2Destroying element: 3deallocating 3 elements of size 4.~Allocator()~Allocator()","link":"/cpp/cpp-allocator/"},{"title":"SFINAE","text":"“Substitution Failure is Not An Error” 1. IntroductionAccording to the definition on cppreference, SFINAE rule applies during overload resolution of function templates: When substituting the explicitly specified or deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error. This feature is used in template metaprogramming. What it means is that: When multiple function templates are available, the compiler attempts to instantiate them one by one. If one instantiation fails due to an invalid substitution, the compiler simply ignores that function instead of generating a compile-time error. The compiler continues searching for another viable function in the overload set. Here is an example of how SFINAE can preventing compilation errors: example.cpp1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;type_traits&gt;// Template function only enabled if T is an integer typetemplate &lt;typename T&gt;std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; foo(T) { std::cout &lt;&lt; &quot;Integer overload\\n&quot;;}// Template function only enabled if T is a floating-point typetemplate &lt;typename T&gt;std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, void&gt; foo(T) { std::cout &lt;&lt; &quot;Floating-point overload\\n&quot;;}int main() { foo(42); // Calls integer overload foo(3.14); // Calls floating-point overload // foo(&quot;hello&quot;); Error: No valid overload (not an integer or floating point)} What Happens in Overload Resolution? foo(42) T = int std::enable_if_t&lt;std::is_integral_v&lt;int&gt;, void&gt; → Valid Integer overload remains in the overload set. Calls the integer overload. foo(3.14) T = double std::enable_if_t&lt;std::is_floating_point_v&lt;double&gt;, void&gt; → Valid Floating-point overload remains in the overload set. Calls the floating-point overload. foo(“hello”) T = const char* std::enable_if_t&lt;std::is_integral_v&lt;int&gt;, void&gt; → Fails (not an integer) std::enable_if_t&lt;std::is_floating_point_v&lt;int&gt;, void&gt; → Fails (not a floating point) Both overloads are discarded. Compilation error: No matching function found. SFINAE (Substitution Failure Is Not An Error) can be achieved in multiple ways in C++. std::enable_if in function return type. Overloaded functions with std::enable_if. Class template specialization. Expression SFINAE (decltype). concept Let’s look at each one of them in the next sections. Before we move on to the next section, it will be helpful to have some basic understanding about common type traits in C++. Type Trait Meaning std::is_integral&lt;T&gt; Checks if T is an integer type (int, char, long, etc.) std::is_floating_point&lt;T&gt; Checks if T is float, double, or long double std::is_pointer&lt;T&gt; Checks if T is a pointer type (T*) std::is_reference&lt;T&gt; Checks if T is a reference type (T&amp; or T&amp;&amp;) std::is_array&lt;T&gt; Checks if T is an array std::is_class&lt;T&gt; Checks if T is a class or struct std::is_enum&lt;T&gt; Checks if T is an enum std::is_same&lt;T, U&gt; Checks if T and U are the same type std::is_convertible&lt;T, U&gt; Checks if T is implicitly convertible to U Since std::enable_if is used frequently to achieve SFINAE, it is necessary to first understand its meaning and usage. std::enable_if is available in &lt;type_traits&gt;. Its possible definition could be: 12345678910template&lt; bool B, class T = void &gt;struct enable_if {};// Partial specialization: Only defined when B is truetemplate&lt; class T &gt;struct enable_if&lt;true, T&gt; { using type = T; };// Helper aliastemplate&lt; bool B, class T = void &gt;using enable_if_t = typename enable_if&lt;B, T&gt;::type; Let’s reuse the example above and include our defined enable_if struct. 123456789template &lt;typename T&gt;enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; foo(T) { std::cout &lt;&lt; &quot;integral overload\\n&quot;;}int main() { foo(42); // OK // foo(3.14); // Error} When we call foo(42): std::is_integral_v&lt;T&gt; evaluates to be true. When true, we have a typename type = void. The function can be expanded to: void foo(int value), which is a valid signiture. When we call foo(3.14): T = double, which is not an integral type. std::is_integral_v&lt;double&gt; == false. Since std::enable_if&lt;false, void&gt; has no type member, the function is discarded. There is no matching function, so the substitution fails. 2. Function return typestd::enable_if allows us to conditionally enable or disable function templates based on type traits by using its associated type alias. 123456789// Helper typestemplate&lt; bool B, class T = void &gt;using enable_if_t = typename enable_if&lt;B,T&gt;::type;template &lt;typename T&gt;std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; foo(T value) { std::cout &lt;&lt; &quot;Integral type: &quot; &lt;&lt; value &lt;&lt; &quot;\\n&quot;;} 12345678// Only enable if T is an integral typetemplate &lt;typename T&gt;std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; foo(T value) { std::cout &lt;&lt; &quot;Integral: &quot; &lt;&lt; value &lt;&lt; &quot;\\n&quot;;}foo(42); // Okfoo(3.14) // error if T is an integral type, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; resolves to void, which is a valid function signiture. However, if T is a double type, substitution fails, and the function discarded, leading to no matching function call. 3. Function overload123456789template &lt;typename T&gt;std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt; print(T value) { std::cout &lt;&lt; &quot;Integral: &quot; &lt;&lt; value &lt;&lt; &quot;\\n&quot;;}template &lt;typename T&gt;std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt; print(T value) { std::cout &lt;&lt; &quot;Floating-point: &quot; &lt;&lt; value &lt;&lt; &quot;\\n&quot;;} 4. Template specialization123456789101112131415// Primary template (disabled by default)template &lt;typename T, typename Enable = void&gt;struct Foo;// Specialization for integral typestemplate &lt;typename T&gt;struct Foo&lt;T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; { static void print() { std::cout &lt;&lt; &quot;Integral type\\n&quot;; }};// Specialization for floating-point typestemplate &lt;typename T&gt;struct Foo&lt;T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;&gt; { static void print() { std::cout &lt;&lt; &quot;Floating-point type\\n&quot;; }}; We leave the primary template undefined for two purposes: Prevents the use of Foo&lt;T&gt; with unsupported types (such as std::string). The default Enable = void parameter allows std::enable_if specializations to work smoothly by using SFINAE. 5. Expression SFINAESFINAE can be applied based on whether an expression is valid. 12345678910111213141516template &lt;typename T&gt;auto has_size(const T&amp; obj) -&gt; decltype(obj.size(), std::true_type{}) { return std::true_type{}; // If `size()` exists, this overload is selected}std::false_type has_size(...) { return std::false_type{}; } // Fallback if `size()` doesn't existint main() { std::vector&lt;int&gt; v; int x = 42; std::cout &lt;&lt; has_size(v).value &lt;&lt; std::endl; // Output: 1 (vector has size()) std::cout &lt;&lt; has_size(x).value &lt;&lt; std::endl; // Output: 0 (int has no size())} decltype(obj.size(), std::true_type{}), if obj.size() is not valid, the compiler can not evaluate and it fails at substitution. This is when SFINEA kicks in and the function is discarded. 6. Using concept (C++20)In C++20, concepts provide a powerful way to constrain template parameters, offering an alternative to traditional SFINAE techniques. Concepts are more readable and expressive than using std::enable_if or other SFINAE tricks. A concept is a predicate that defines a set of requirements for a type. You can think of it as a constraint on the template parameters, which is checked at compile time. Basic usage: 1234567template &lt;typename T&gt;concept Integral = std::is_integral_v&lt;T&gt;; // Concept to check if T is an integral typetemplate &lt;Integral T&gt; // Use the Integral concept to constrain Tvoid print(T value) { std::cout &lt;&lt; &quot;Integral: &quot; &lt;&lt; value &lt;&lt; std::endl;} Multiple concepts: 1234567template &lt;typename T&gt;concept IntegralAndArithmetic = std::is_integral_v&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;T&gt;;template &lt;IntegralAndArithmetic T&gt;void print(T value) { std::cout &lt;&lt; &quot;Integral and Arithmetic: &quot; &lt;&lt; value &lt;&lt; std::endl;} Combined with requires for more complex constraints. The requires clause in C++20 is used to specify constraints on template parameters. It allows you to check conditions on types or expressions at compile time. This is part of the new concept-based feature in C++20, 123456789template &lt;typename T&gt;concept HasSize = requires(T a) { { a.size() } -&gt; std::same_as&lt;std::size_t&gt;; // Check if T has size() returning std::size_t};template &lt;HasSize T&gt;void printSize(T obj) { std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; obj.size() &lt;&lt; std::endl;} 7. ConclusionIn this post, we discussed some common SFINAE implementations. Of course, there are some other techniques such as std::void_t, default template parameters, etc. Interested readers can continue to explore on these topics. References https://en.cppreference.com/w/cpp/language/sfinae https://en.cppreference.com/w/cpp/types/enable_if","link":"/cpp/cpp-SFINAE/"},{"title":"Runtime Memory Error Detection Using ASAN","text":"AddressSanitizer (ASan) is a runtime memory error detector built into LLVM/Clang and GCC. 1. Enable ASANASAN instruments your program at compile time and inserts checks into the generated binary. When you run the program, ASan monitors all memory accesses to catch bugs that normally lead to undefined behavior. Illegal memory access will cause random segmentation fault and most of such memory accesses can be detected by ASAN. In CMake, add a simple helper function to enable ASAN for libs/executables 123456789101112function(enable_asan target) if(CMAKE_CXX_COMPILER_ID STREQUAL &quot;GNU&quot; OR CMAKE_CXX_COMPILER_ID STREQUAL &quot;Clang&quot; OR CMAKE_CXX_COMPILER_ID STREQUAL &quot;AppleClang&quot;) target_compile_options(${target} PRIVATE -g -O1 -fsanitize=address -fno-omit-frame-pointer) target_link_options(${target} PRIVATE -fsanitize=address) target_compile_definitions(${target} PRIVATE ASAN_ENABLED=1) message(STATUS &quot;AddressSanitizer enabled for target: ${target}&quot;) else() message(WARNING &quot;AddressSanitizer is not supported for ${CMAKE_CXX_COMPILER_ID}&quot;) endif()endfunction() 2. Out of Bound Memory AccessLet’s add some illegal memory access code. In this demo, there are two places where illegal memory access will occur. In lib_math.cpp, a[i - 1] tries to access the memory address before the first element. In main.cpp, we are trying to access vec1[-1]. 1234567891011121314// lib_math.cppnamespace math_lib { std::vector&lt;double&gt; add(const std::vector&lt;double&gt;&amp; a, const std::vector&lt;double&gt;&amp; b) { if (a.size() != b.size()) { throw std::invalid_argument(&quot;Vectors must have the same size for addition&quot;); } std::vector&lt;double&gt; result(a.size()); for (size_t i = 0; i &lt; a.size(); ++i) { result[i] = a[i - 1] + b[i]; } return result; }} 12345678910111213// main.cppint main() { // Create some test vectors std::vector&lt;double&gt; vec1 = {1.0, 2.0, 3.0}; std::vector&lt;double&gt; vec2 = {4.0, 5.0, 6.0}; const auto result = math_lib::add(vec1, vec2); std::cout &lt;&lt; vec1[-1] &lt;&lt; std::endl; return 0;} Let’s see if ASAN can detect these two errors. We need to enable ASAN for both math lib and our main executable. 1234567891011121314151617181920212223242526272829303132cmake_minimum_required(VERSION 3.28)project(ASAN_DEMO)# Set C++ standardset(CMAKE_CXX_STANDARD 20)set(CMAKE_CXX_STANDARD_REQUIRED ON)# Function to enable AddressSanitizerfunction(enable_asan target) if(CMAKE_CXX_COMPILER_ID STREQUAL &quot;GNU&quot; OR CMAKE_CXX_COMPILER_ID STREQUAL &quot;Clang&quot; OR CMAKE_CXX_COMPILER_ID STREQUAL &quot;AppleClang&quot;) target_compile_options(${target} PRIVATE -g -O1 -fsanitize=address -fno-omit-frame-pointer) target_link_options(${target} PRIVATE -fsanitize=address) target_compile_definitions(${target} PRIVATE ASAN_ENABLED=1) message(STATUS &quot;AddressSanitizer enabled for target: ${target}&quot;) else() message(WARNING &quot;AddressSanitizer is not supported for ${CMAKE_CXX_COMPILER_ID}&quot;) endif()endfunction()# Create the math libraryadd_library(math_lib STATIC src/math_lib.cpp)target_include_directories(math_lib PUBLIC include)enable_asan(math_lib)# Create the executableadd_executable(demo main.cpp)enable_asan(demo)# Link the math library to the executabletarget_link_libraries(demo math_lib) Let’s try to run the demo. 1./build/demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647===================================================================57371==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x000103001e38 at pc 0x000100353568 bp 0x00016faaee70 sp 0x00016faaee68READ of size 8 at 0x000103001e38 thread T0 #0 0x100353564 in math_lib::add(std::__1::vector&lt;double, std::__1::allocator&lt;double&gt;&gt; const&amp;, std::__1::vector&lt;double, std::__1::allocator&lt;double&gt;&gt; const&amp;) math_lib.cpp:13 #1 0x1003526e8 in main main.cpp:10 #2 0x18a8360dc (&lt;unknown module&gt;)0x000103001e38 is located 8 bytes to the left of 24-byte region [0x000103001e40,0x000103001e58)allocated by thread T0 here: #0 0x100b45370 in wrap__Znwm+0x74 (libclang_rt.asan_osx_dynamic.dylib:arm64e+0x51370) (BuildId: f0a7ac5c49bc3abc851181b6f92b308a32000000200000000100000000000b00) #1 0x10035253c in main main.cpp:7 #2 0x18a8360dc (&lt;unknown module&gt;)SUMMARY: AddressSanitizer: heap-buffer-overflow math_lib.cpp:13 in math_lib::add(std::__1::vector&lt;double, std::__1::allocator&lt;double&gt;&gt; const&amp;, std::__1::vector&lt;double, std::__1::allocator&lt;double&gt;&gt; const&amp;)Shadow bytes around the buggy address: 0x007020620370: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x007020620380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x007020620390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0070206203a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0070206203b0: fa fa fa fa fa fa fa fa fa fa fa fa 00 00 00 fa=&gt;0x0070206203c0: fa fa 00 00 00 fa fa[fa]00 00 00 fa fa fa 00 00 0x0070206203d0: 00 00 fa fa 00 00 00 00 fa fa 00 00 04 fa fa fa 0x0070206203e0: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 0x0070206203f0: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 0x007020620400: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 0x007020620410: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb==57371==ABORTING[1] 57371 abort ./build/demo ASAN successfully detects the error in lib_math.cpp, and it explicitly identifies the line of code where the problem occurs. The full call stack is also shown here. ASAN will abort once illegal memory access is detected, so we won’t see the second memory error. Let’s fix the first one and run the demo again. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546===================================================================57961==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x000107201e38 at pc 0x000104553974 bp 0x00016b8aefd0 sp 0x00016b8aefc8READ of size 8 at 0x000107201e38 thread T0 #0 0x104553970 in main main.cpp:12 #1 0x18a8360dc (&lt;unknown module&gt;)0x000107201e38 is located 8 bytes to the left of 24-byte region [0x000107201e40,0x000107201e58)allocated by thread T0 here: #0 0x104d45370 in wrap__Znwm+0x74 (libclang_rt.asan_osx_dynamic.dylib:arm64e+0x51370) (BuildId: f0a7ac5c49bc3abc851181b6f92b308a32000000200000000100000000000b00) #1 0x1045534e0 in main main.cpp:7 #2 0x18a8360dc (&lt;unknown module&gt;)SUMMARY: AddressSanitizer: heap-buffer-overflow main.cpp:12 in mainShadow bytes around the buggy address: 0x007020e60370: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x007020e60380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x007020e60390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x007020e603a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x007020e603b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa=&gt;0x007020e603c0: fa fa 00 00 00 fa fa[fa]00 00 00 fa fa fa 00 00 0x007020e603d0: 00 00 fa fa 00 00 00 00 fa fa 00 00 04 fa fa fa 0x007020e603e0: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 0x007020e603f0: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 0x007020e60400: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 0x007020e60410: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb==57961==ABORTING[1] 57961 abort ./build/demo vec1[-1] is again being detected by ASAN. And the error message explicitly tells us that we are trying to access the memory (0x000107201e38) which is located 8 bytes to the left of 24-byte region [0x000107201e40,0x000107201e58] 3. Segmentation FaultWhile an illegal memory access may cause a segmentation fault, this isn’t guaranteed; if the access still points to an address inside the system-assigned memory space for the program, it might not crash right away. Let’s turn off the ASAN and run the modified main.cpp. 123456789101112// main.cppint main() { // Create some test vectors std::vector&lt;double&gt; vec1 = {1.0, 2.0, 3.0}; std::cout &lt;&lt; vec1[-10] &lt;&lt; std::endl; std::cout &lt;&lt; vec1[-100] &lt;&lt; std::endl; std::cout &lt;&lt; vec1[-1000] &lt;&lt; std::endl; std::cout &lt;&lt; vec1[-10000] &lt;&lt; std::endl; return 0;} 1234000[1] 58569 segmentation fault ./build/demo 4. llvm-addr2line ToolIf your program runs on Android, enabling ASan won’t give you the same straightforward error messages you’d see on macOS. The output usually contains just the executable or library name along with a memory address, without pointing to the specific line of code. In this situation, you can use a tool like llvm-addr2line to translate those addresses into the corresponding source locations. llvm-addr2line is located inside Android NDK. For example, it is located at: Android/sdk/ndk/26.1.10909125/toolchains/llvm/prebuilt/darwin-x86_64/bin in my local path. The basic usage is: 1llvm-addr2line -e ./demo -f -C -i -p [address_from_asan_message] This should translate your ASAN reported error addresses to the corresponding source code.","link":"/cpp/cpp-asan/"},{"title":"Bitfields","text":"Intoducing bitfileds in C++ Table of Contents Introduction Caveats Example 1. IntroductionIn C++, bitfields are a feature that allows you to specify the exact number of bits a data member in a structure (or class) should occupy, rather than using a full byte or more as standard data types do. This is useful for memory optimization, especially in embedded systems, low-level programming, or when dealing with hardware registers, network protocols, or packed data structures where you need precise control over memory usage. What Are Bitfields? A bitfield is a member of a struct or class declared with a specified number of bits using the : &lt;number&gt; syntax. Bitfields are typically used with integral types (like int, unsigned int, or bool) and allow you to pack multiple fields into fewer bytes by allocating only the exact number of bits needed. 123456789101112131415161718192021struct Flags { unsigned short isActive : 1; // 1 bit (0 or 1) unsigned short mode : 2; // 2 bits (0 to 3) unsigned short priority : 3; // 3 bits (0 to 7) unsigned short reserved : 2; // 2 bits (unused)};int main() { Flags flags; flags.isActive = 1; // Set to true (1) flags.mode = 2; // Set to 2 flags.priority = 5; // Set to 5 flags.reserved = 0; // Set to 0 std::cout &lt;&lt; &quot;Size of Flags: &quot; &lt;&lt; sizeof(Flags) &lt;&lt; &quot; bytes\\n&quot;; std::cout &lt;&lt; &quot;isActive: &quot; &lt;&lt; flags.isActive &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;mode: &quot; &lt;&lt; flags.mode &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;priority: &quot; &lt;&lt; flags.priority &lt;&lt; &quot;\\n&quot;; return 0;} 1234Size of Flags: 2 bytesisActive: 1mode: 2priority: 5 Bitfields can only be declared as Integral Types Only. Other types such as float are not allowed. The total size of a struct(or class) with bitfields is usually the underlying type(e.g., 32 bits for an unsigned int) if the the number of bits used doesn’t exceed the bit limit. When there’s not enough space left in the current allocation unit (like a 16-bit short), the compiler will start a new one, leading to increase size of a struct/class. 1234567struct Flags { unsigned short isActive : 1; // 1 bit (0 or 1) unsigned short mode : 2; // 2 bits (0 to 3) unsigned short priority : 3; // 3 bits (0 to 7) unsigned short reserved : 2; // 2 bits (unused) unsigned short rest : 11;}; // 4 bytes 2. Caveats2.1 Implementation-Defined LayoutThe layout of bitfields (e.g., bit ordering, padding, and alignment) is compiler- and platform-dependent. Different compilers or architectures (e.g., big-endian vs. little-endian) may arrange bits differently, making bitfields non-portable. 2.2 No Type Safety or Overflow ProtectionAssigning a value larger than the bitfield silently truncates the value. 123456789struct Flags { unsigned short isActive : 1; // 1 bit (0 or 1) unsigned short mode : 3; // 3 bits (0 to 7) unsigned short priority : 3; // 3 bits (0 to 7) unsigned short reserved : 2; // 2 bits (unused)};Flags flags;flags.mode = 10; // will be truncated to 2 If we set mode to be 10 by mistake, which exceeds the representation limit of 3 bits. The compiler silently truncates the value to be 0b1010 &amp; 0b0111 = 0b0010 (which is 2) 2.3 Unspecified Signedness of Plain int Bitfields123struct S { int x : 3;}; The signedness (signed vs. unsigned) of x is implementation-defined. Tip: Always use signed int and unsigned int explicitly for clarity. 2.4 Compiler Behavior Compilers may insert padding between bitfields or at the end of a struct to align data to word boundaries, increasing memory usage unexpectedly. Adjacent bitfields may not always be packed tightly; the compiler decides based on the underlying type and alignment rules. Accessing bitfields often requires the compiler to generate additional instructions for masking and shifting, which can be slower than accessing regular variables. The C++ standard leaves many aspects of bitfields (e.g., allocation order, padding) up to the implementation, so code relying on specific behavior may break when compiled with a different compiler or on a different platform. 3. ExampleReal-World Example: IPv4 Header with Bitfields The IPv4 header is a 20-byte (160-bit) structure (without options) that precedes the payload in an IP packet. It contains fields like version, header length, type of service, total length, identification, flags, fragment offset, time to live, protocol, header checksum, source address, and destination address. Many of these fields are smaller than a byte, making bitfields perfect for mapping them. 1234567891011121314struct IPv4Header { uint8_t version : 4; // 4 bits: IP version (4 for IPv4) uint8_t ihl : 4; // 4 bits: Internet Header Length uint8_t typeOfService; // 8 bits: Type of Service uint16_t totalLength; // 16 bits: Total packet length uint16_t identification; // 16 bits: Packet identifier uint8_t flags : 3; // 3 bits: Fragmentation flags uint16_t fragmentOffset : 13; // 13 bits: Fragment offset uint8_t timeToLive; // 8 bits: Time to Live uint8_t protocol; // 8 bits: Protocol (e.g., 6 for TCP) uint16_t headerChecksum; // 16 bits: Header checksum uint32_t sourceAddress; // 32 bits: Source IP address uint32_t destinationAddress; // 32 bits: Destination IP address}; The total size is 1 + 1 + 2 + 2 + 2 + 1 + 1 + 2 + 4 + 4 = 20 bytes.","link":"/cpp/cpp-bitfields/"},{"title":"Avoid Naked Union","text":"To ensure safety, encapsulate the union within a class or struct. 1. Naked UnionA naked union is not encapsulated within a class or struct. nakedUnion.cpp12345union NakedUnion { int intValue; float floatValue; char charValue;}; Explanation of risks Undefined behavior Only one member of the union should be active at a time. Accessing an inactive member results in undefined behavior. No type safety A naked union does not track which member is currently active. If you accidentally access the wrong member, the program may produce incorrect results or crash. 2. Ecapsulation with class/structTo mitigate the risk, we can wrap the union in a class or struct and use an enum to track the active member. safeUnion.cpp12345678910111213141516171819202122232425262728293031323334class SafeUnion {public: enum Type { INT, FLOAT, CHAR }; Type activeType; union { int intValue; float floatValue; char charValue; }; void setInt(int value) { intValue = value; activeType = INT; } void setFloat(float value) { floatValue = value; activeType = FLOAT; } void setChar(char value) { charValue = value; activeType = CHAR; } void print() const { switch (activeType) { case INT: std::cout &lt;&lt; &quot;intValue: &quot; &lt;&lt; intValue &lt;&lt; std::endl; break; case FLOAT: std::cout &lt;&lt; &quot;floatValue: &quot; &lt;&lt; floatValue &lt;&lt; std::endl; break; case CHAR: std::cout &lt;&lt; &quot;charValue: &quot; &lt;&lt; charValue &lt;&lt; std::endl; break; } }}; 3. Use std::variantstd::variant provides a type-safe alternative to unions. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;variant&gt;int main() { // Define a variant that can hold an int, float, or std::string std::variant&lt;int, float, std::string&gt; v; // Assign different types to the variant v = 42; // holds an int v = 3.14f; // holds a float v = &quot;Hello, World!&quot;; // holds a std::string // Check what type the variant currently holds if (std::holds_alternative&lt;int&gt;(v)) { std::cout &lt;&lt; &quot;The variant holds an int: &quot; &lt;&lt; std::get&lt;int&gt;(v) &lt;&lt; std::endl; } else if (std::holds_alternative&lt;float&gt;(v)) { std::cout &lt;&lt; &quot;The variant holds a float: &quot; &lt;&lt; std::get&lt;float&gt;(v) &lt;&lt; std::endl; } else if (std::holds_alternative&lt;std::string&gt;(v)) { std::cout &lt;&lt; &quot;The variant holds a string: &quot; &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl; } return 0;} 4. Summary Naked unions are powerful but risky because they lack type safety and can lead to undefined behavior. Always be cautious when using naked unions and prefer safer alternatives like encapsulation or std::variant. If you must use naked unions, document the code clearly and ensure that only one member is accessed at a time.","link":"/cpp/cpp-avoid-naked-union/"},{"title":"Casting in C++","text":"C-style casting, static casting, dynamic casting, reinterept casting C-style casting1234int main() { int x = 7; std::cout &lt;&lt; (float)x / 2 &lt;&lt; std::endl;} 13.5 When comparing between signed and unsigned types, unexpected behavior could happen. 123456789int main() { int x = -1; unsigned int y = 1; if (x &gt;= y) std::cout &lt;&lt; &quot;x &gt;= y\\n&quot;; else std::cout &lt;&lt; &quot;x &lt; y\\n&quot;;} 1x &gt;= y The reason is that when comparing x and y, they will first be converted to two’s complement representation.for int x = -1;, its two’s complement representation is: 1111 1111 1111 1111 1111 1111 1111 1111.for unsigned int y = 1;, its two’s complement representation is: 0000 0000 0000 0000 0000 0000 0000 0001. The alternative solution is to use std::cmp_greater for better safe comparison. 123456789int main() { int x = -1; unsigned int y = 1; if (std::cmp_greater(x, y)) std::cout &lt;&lt; &quot;x &gt;= y\\n&quot;; else std::cout &lt;&lt; &quot;x &lt; y\\n&quot;;} 1x &lt; y Static castingIt is a compile-time cast. In general, static_cast is used to convert between numeric data types (i.e. int to float).static_cast is not as safe as dynamic_cast as it does no run-time type check. 123456789101112131415161718192021222324252627282930313233class Base {private: int x;public: Base() {x = 1;} virtual void print() { std::cout &lt;&lt; &quot;Base print, x = &quot; &lt;&lt; x &lt;&lt; std::endl; }};class Derived : public Base {private: int x;public: Derived() {x = 2;} void print() override { std::cout &lt;&lt; &quot;Derived print, x = &quot; &lt;&lt; x &lt;&lt; std::endl; }}; int main() { Base b; Derived d; b.print(); d.print(); (static_cast&lt;Base&gt;(d)).print(); // (static_cast&lt;Derived&gt;(b)).print(); Error!} 123Base print, x = 1Derived print, x = 2Base print, x = 1 It is okay to cast an object to its base class type, but not the other way. Continue the above example. 1234567891011121314151617181920212223242526272829class Base {private: int x;public: Base() {x = 1;} virtual void print() { std::cout &lt;&lt; &quot;Base print, x = &quot; &lt;&lt; x &lt;&lt; std::endl; }};class Derived : public Base { // If changed to private/protected, casting will not workprivate: int x;public: Derived() {x = 2;} void print() override { std::cout &lt;&lt; &quot;Derived print, x = &quot; &lt;&lt; x &lt;&lt; std::endl; }}; int main() { Base* b = new Base(); Derived* d = new Derived(); static_cast&lt;Derived*&gt;(b)-&gt;print(); // Not safe, d could have fields and methods that are not in b static_cast&lt;Base*&gt;(d)-&gt;print(); // Safe, d always contains all of b} 12Base print, x = 1Derived print, x = 2 To use static_cast in case of inheritance, the base class must be accessible to the derived classes. In the example above, if Derived is inherited as private/protected, it will not compile. static_cast is able to cast to and from void pointer 12345678int main() { int* i = new int; *i = 10; void* v = static_cast&lt;void*&gt;(i); int* ip = static_cast&lt;int*&gt;(v); std::cout &lt;&lt; *ip; delete i;} 110 Dynamic castingDefinition from cpprefernce: Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.. upcasting and downcasting can be illustrated in the figure below. dynamic_cast does run-time type check so it will introduce runtime overhead. To work with dynamic_cast, there must be one virtual function in the base class. For example: 1234567891011121314151617181920212223242526272829class Base {private: int x;public: Base() {x = 1;} void print() { std::cout &lt;&lt; &quot;Base print, x = &quot; &lt;&lt; x &lt;&lt; std::endl; }};class Derived : public Base {private: int x;public: Derived() {x = 2;} void print() { std::cout &lt;&lt; &quot;Derived print, x = &quot; &lt;&lt; x &lt;&lt; std::endl; }}; int main() { Base* b = new Base(); Derived* d = new Derived(); Base* bc = dynamic_cast&lt;Base*&gt;(d); // Ok, upcasting Derived* dc = dynamic_cast&lt;Derived*&gt;(b); // Error, downcasting} 1234main.cpp:32:19: error: 'Base' is not polymorphic Derived* dc = dynamic_cast&lt;Derived*&gt;(b); ^ ~1 error generated. Reinterpret castIt is used to convert a pointer of some data type into a pointer of another data type. It does not check if the pointer type and data pointed is same or not. You will see some unexpected results. For example: 1234int main() { float pi = 3.14f; std::cout &lt;&lt; *reinterpret_cast&lt;int*&gt;(&amp;pi) &lt;&lt; std::endl; } 11078523331 Let’s see a more comprehensive example. 123456789101112131415161718192021222324struct GameStats { int level; int health; int points; bool GameCompleted; bool BossDefeated;};int main() { GameStats gs = {6, 99, 55, false, false}; char buffer[sizeof(gs)]; memcpy(buffer, &amp;gs, sizeof(gs)); // C-style casting std::cout &lt;&lt; *((int*)(buffer)) &lt;&lt; std::endl; std::cout &lt;&lt; *((int*)(buffer+4)) &lt;&lt; std::endl; std::cout &lt;&lt; *reinterpret_cast&lt;int*&gt;(buffer+0) &lt;&lt; std::endl; std::cout &lt;&lt; *reinterpret_cast&lt;int*&gt;(buffer+4) &lt;&lt; std::endl; std::cout &lt;&lt; *reinterpret_cast&lt;int*&gt;(buffer+8) &lt;&lt; std::endl; std::cout &lt;&lt; *reinterpret_cast&lt;bool*&gt;(buffer+12) &lt;&lt; std::endl; std::cout &lt;&lt; *reinterpret_cast&lt;bool*&gt;(buffer+13) &lt;&lt; std::endl;} 123456786996995500 The memory allocation of buffer can be depicted as follows. Although C-style casting can work, using reinterpret_cast is more readable. Reinterpret_cast can also convert a pointer to a class to another class. 12345678910111213141516171819202122232425class A {public: void fooA() { std::cout &lt;&lt; &quot;in A\\n&quot;; }};class B {private: int m_x;public: B(int x) : m_x(x) {} void fooB() { std::cout &lt;&lt; &quot;in B, m_x = &quot; &lt;&lt; m_x &lt;&lt; std::endl; }};int main() { A* a = new A(); B* b = reinterpret_cast&lt;B*&gt;(a); b-&gt;fooB(); delete a;} 1in B, m_x = 0 References https://en.cppreference.com/w/cpp/utility/intcmp https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines https://learn.microsoft.com/en-us/cpp/cpp/static-cast-operator?view=msvc-170 https://en.cppreference.com/w/cpp/language/dynamic_cast https://www.geeksforgeeks.org/reinterpret_cast-in-c-type-casting-operators/","link":"/cpp/cpp-casting/"},{"title":"Class Functions inlining","text":"Today, while reading a book by Bjarne Stroustrup, I came across an interesting C++ fact that I hadn’t known before. 1. IntroductionFunctions defined in a class are implicitly considered as inline, regardless of whether it it is public, protected, or private(access specifier does not affect). This can be verified through C++ Insights: https://cppinsights.io/s/1a8f7945 source.cpp12345678910111213141516class A {public: void funcA() { return; }protected: void funcB() { return; } private: void funcC() { return; }}; translate.cpp123456789101112131415161718192021222324class A /* size: 1, align: 1 */{ public: inline void funcA() { return; } protected: inline void funcB() { return; } private: inline void funcC() { return; } }; 2. Out-of-Class DefinitionIf you define a function outside the class declaration, it is not inline by default. source.cpp123456789class A { void funcA(); // declaration};// definitionvoid A::funcA() { return;} translate.cpp1234567891011class A /* size: 1, align: 1 */{ void funcA(); };void A::funcA(){ return;} Most of the time, in our project, we separate declarations and definitions into .cpp and .h files. In such case, functions are not inlined by default. To make out-of-class definition inline, we need to use inline keyword explicitly. example.cpp123456789class A {public: inline void funcA(); // Explicitly inline};// Now it is inlineinline void A::funcA() { return;} 3. Link-Time Optimization (LTO)Modern compiler optimize function calls automatically using advanced strategies such as Link-Time Optimization(LTO). LTO enables cross-translation-unit optimizations, allowing functions defined in .cpp files to be inlined when beneficial. To enable LTO, we can add a flag -flto to the build command when using GCC/Clang compilers. 4. Conclusion Functions defined inside a class are implicitly inline. Functions defined outside a class are NOT inline unless explicitly marked inline. To enable inlining, either define inside the class or use inline in the definition.","link":"/cpp/cpp-class-functions-inline/"},{"title":"Auto-type Deduction Rules","text":"Auto-type deduction allows the compiler to deduce the type of a variable from its initializer. Source code on C++ insights 1. Deduction with referenceIf the initializer is a reference, the reference type is stripped, and auto deduces the underlying type. If you want auto to deduce a reference, you must explicitly use auto&amp;. source.cpp1234int a1 = 3;int&amp; ref = a1;auto b1 = ref; // int b1 = ref;auto&amp; c1 = ref; // int&amp; c1 = ref; 2. Deduction with constIf the initializer is const, auto deduces the type without const unless explicitly specified. source.cpp123const int a2 = 3;auto b2 = a2; // int b2 = a2;const auto c2 = a2; // const int c2 = a2; In C++, const can appear in different context, and its role can be categorized as either top-level const or low-level const. Top-level const applies to the object itself, indicating that the object itself cannot be modified. example.cpp12const int x = 42; // `x` is a `const int` (the value of `x` cannot be modified)int* const ptr = &amp;x; // `ptr` is a `const pointer` to `int` (the pointer itself cannot change, but the pointee can) Low-level const applies to the type being referred to or pointed to. It means the value being referred to or pointed to cannot be modified. example.cpp12const int* ptr = &amp;x; // `ptr` is a pointer to a `const int` (the value of the pointee cannot be modified)const int* const cptr = &amp;x; // `cptr2` is a `const pointer` to a `const int`, the left const is low-level const It is important to note that:Top-level const is ignored when using auto-type deduction unless explicitly specified. Low-level const is preserved during auto-type deduction. example.cpp1234const int a2 = 3;const int* const d2 = &amp;a2;auto e2 = d2; // const int*const auto f2 = d2; // const int* const 3. Deduction with pointersIf a pointer is involved, auto deduces the pointer type. example.cpp123int a3 = 3;int* p3 = &amp;a3;auto b3 = p3; // int* 4. Deduction with ArraysFor arrays, auto deduces to a pointer to the first element of the array. auto&amp; deduces the array type. example.cpp123int arr4[] = {1, 2, 3, 4};auto a4 = arr4; // int*auto&amp; b4 = arr4; // int(&amp;)[4] 5. Deduction with FunctionsFor functions, auto deduces to a function pointer. example.cpp12int f5(int a) {return a;}auto a5 = f5; // int(*)int 6. Deduction with auto&amp;&amp;auto&amp;&amp; deduces a reference type. If the initializer is an lvalue, auto&amp;&amp; deduces an lvalue reference. If the initializer is an rvalue, auto&amp;&amp; deduces an rvalue reference. example.cpp1234int a6 = 3;auto&amp;&amp; b6 = a6; // int&amp;auto&amp;&amp; c6 = 3; // int&amp;&amp;auto&amp;&amp; d6 = std::move(a6); // int&amp;&amp; 7. Deduction with Lambdaauto can be used to deduce the return type of a lambda. example.cpp1234567int a7 = 3;auto lm1 = [](int x) {return x;};auto lm2 = [](auto x) {return x;};auto lm3 = [](int x) -&gt; double {return x + 0.5;};auto lm4 = [&amp;]() -&gt; decltype(auto) { return a7; // Returns by reference}; 8. Deduction with decltype(auto)decltype(auto) is used when you want the deduced type to match the initializer’s type exactly, including references. example.cpp123int a8 = 42;int&amp; ref8 = a8;decltype(auto) b8 = ref8; // int&amp; 9. Deduction with auto*auto* is deduced as a pointer type. example.cpp12345678int a9 = 3;auto* p1 = &amp;a9; // int*, error case: auto p1 = a9, since a9 is not a pointer or an addressint arr[] = {1, 2, 3};auto* p2 = arr; // int*const int b9 = 3;auto* p33 = &amp;b9; // const int*int* p4 = &amp;a9;auto* p5 = &amp;p4; // int**","link":"/cpp/cpp-auto-type-deduction-rules/"},{"title":"Builder Design Pattern","text":"Design pattern. 1. IntroductionThe Builder pattern typically consists of the following components: Product: This is the complex object that needs to be constructed. It contains the actual data and behavior of the object. Builder: This is an abstract interface or abstract class that defines the steps required to construct the Product object. It declares a set of methods for building different parts or aspects of the Product. Concrete Builders: These are concrete implementations of the Builder interface or classes that provide the actual implementation for constructing the Product object. Each Concrete Builder constructs the Product differently, depending on the desired representation or configuration. Director: The Director class is responsible for orchestrating the construction process by calling the appropriate methods on the Builder in the correct order. It knows the sequence of steps required to create the Product object. 2. ExampleLet’s create camera objects using the Builder design pattern. Different types of cameras, such as DSLRs, phone cameras, 360-degree cameras, etc., have various specifications, but their fundamental functionalities are similar. We can describe their specifications using common terms such as focus, white balance, stabilization, exposure time, and fps. In this example: The product is a camera. The builder defines the basic camera specifications without providing detailed implementation. The ConcreteBuilder determines the specific specifications each type of camera should have. The Director is responsible for assembling a certain type of camera. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;// Productclass Camera {public: void showSpecs() const { std::cout &lt;&lt; &quot;===Camera Specifications===&quot; &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;Stabilization: &quot; &lt;&lt; (hasStabilization ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;FPS: &quot; &lt;&lt; fps &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;White Balance: &quot; &lt;&lt; whiteBalance &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;Auto Focus: &quot; &lt;&lt; (hasAutoFocus ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;Aperture: f/&quot; &lt;&lt; aperture &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;Denoise: &quot; &lt;&lt; (hasDenoise ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;Sharpening: &quot; &lt;&lt; (hasSharpening ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; '\\n'; } friend class CameraBuilder; friend class CompactCameraBuilder; friend class DSLRCameraBuilder;private: bool hasStabilization; int fps; std::string whiteBalance; bool hasAutoFocus; double aperture; bool hasDenoise; bool hasSharpening; Camera() : hasStabilization(false), fps(0), hasAutoFocus(false), aperture(0.0), hasDenoise(false), hasSharpening(false) {}};// Builder (Abstract Interface)class CameraBuilder {public: virtual ~CameraBuilder() {} virtual void setStabilization() = 0; virtual void setFPS() = 0; virtual void setWhiteBalance() = 0; virtual void setAutoFocus() = 0; virtual void setAperture() = 0; virtual void setDenoise() = 0; virtual void setSharpening() = 0; virtual Camera* getResult() const = 0;};// Concrete Buildersclass CompactCameraBuilder : public CameraBuilder {public: CompactCameraBuilder() { camera = new Camera(); } ~CompactCameraBuilder() { delete camera; } void setStabilization() override { camera-&gt;hasStabilization = true; } void setFPS() override { camera-&gt;fps = 30; } void setWhiteBalance() override { camera-&gt;whiteBalance = &quot;Auto&quot;; } void setAutoFocus() override { camera-&gt;hasAutoFocus = true; } void setAperture() override { camera-&gt;aperture = 2.8; } void setDenoise() override { camera-&gt;hasDenoise = false; } void setSharpening() override { camera-&gt;hasSharpening = false; } Camera* getResult() const override { return camera; }private: Camera* camera;};class DSLRCameraBuilder : public CameraBuilder {public: DSLRCameraBuilder() { camera = new Camera(); } ~DSLRCameraBuilder() { delete camera; } void setStabilization() override { camera-&gt;hasStabilization = true; } void setFPS() override { camera-&gt;fps = 60; } void setWhiteBalance() override { camera-&gt;whiteBalance = &quot;Manual&quot;; } void setAutoFocus() override { camera-&gt;hasAutoFocus = true; } void setAperture() override { camera-&gt;aperture = 1.8; } void setDenoise() override { camera-&gt;hasDenoise = true; } void setSharpening() override { camera-&gt;hasSharpening = true; } Camera* getResult() const override { return camera; }private: Camera* camera;};// Directorclass CameraDirector {public: Camera* getCamera(CameraBuilder&amp; builder) { builder.setStabilization(); builder.setFPS(); builder.setWhiteBalance(); builder.setAutoFocus(); builder.setAperture(); builder.setDenoise(); builder.setSharpening(); return builder.getResult(); }};int main() { CameraDirector director; CompactCameraBuilder compactBuilder; auto compactCamera = director.getCamera(compactBuilder); std::cout &lt;&lt; &quot;Compact Camera:&quot; &lt;&lt; '\\n'; compactCamera-&gt;showSpecs(); std::cout &lt;&lt; '\\n'; DSLRCameraBuilder dslrBuilder; auto dslrCamera = director.getCamera(dslrBuilder); std::cout &lt;&lt; &quot;DSLR Camera:&quot; &lt;&lt; '\\n'; dslrCamera-&gt;showSpecs(); return 0;} 12345678910111213141516171819Compact Camera:===Camera Specifications===Stabilization: YesFPS: 30White Balance: AutoAuto Focus: YesAperture: f/2.8Denoise: NoSharpening: NoDSLR Camera:===Camera Specifications===Stabilization: YesFPS: 60White Balance: ManualAuto Focus: YesAperture: f/1.8Denoise: YesSharpening: Yes","link":"/cpp/cpp-builder/"},{"title":"Class Size, Alignment and Padding","text":"Stop defining/declaring member variables in random order. 1. SizeThe size of a C++ class is primarily determined by its non-static data members, plus any additional memory aligment and padding requirements. Each fundamental types (e.g., char, float, int) has a fixed size and alignment. Smaller types can cause padding if places inefficiently. 123456struct A { char a; // 1 byte int b; // 4 bytes};// total = 1 + 3(padding) + 4 = 8 A pointer is just an address, it takes 8 bytes on a 64-bit system, and 4 bytes on a 32 bit system. 12345struct A { int* p; // 8 bytes (on a 64-bit system)};// total = 8 Static members do not affect class size because they are stored separately in global memory. 123456struct A { int a; // 4 byes static int b; // 4 bytes, but do not affect class size};// total = 4 When a class contains another class object as a member, it inherits the memory layout of the conatined object. 1234567891011struct A { char a; // 1 byte int b; // 4 bytes};// total = 1 + 3(padding) + 4 = 8struct B { A e; // Size of A is 8 bytes double c; // 4 bytes};// total = 8 + 4 + 4(padding) = 16 If a class has at least one virtual function, it will contain a hidden virtual table pointer. The vptr takes 8 bytes on a 64-bit system. 1234struct C { virtual void foo() {}};// total = 8, due to a hidden vptr Empty base class optimization means an empty base class usually takes 1 byte to ensure unique address, however, compilers can optimize it by reducing its actual size to 0 byte. 123456struct Empty {};struct A : Empty { int x;};// total = 4, due to empty base class optimization STL containers take spaces dependent on their implementations. For example, std::vector&lt;T&gt; typically uses 3 pointers to manage its dynamic array. 1234567// std::vector&lt;T structuretemplate &lt;typename T&gt;struct VectorLayout { T* start; // Points to the beginning of the allocated array T* finish; // Points to one past the last element T* end_of_storage; // Points to the end of allocated memory}; 1234567struct A { char a; // 1 byte int b; // 4 bytes std::vector&lt;int&gt; vec; // 24 bytes};// total = 1 + 3 + 4 + 24 = 32 Lambda functions in C++ are implemented as unnamed (closure) classes. When a lambda is declared inside a class, it is treated as a hidden member class that can potentially increase the class size depending on how the lambda captures variables. Its use cases are a bit complicated, we will use another post to discuss it in the future. 2. Alignment and PaddingAlignment is a fundamental concept in C++ that ensures efficient memory access and prevents performance penalties due to unaligned memory access. Each data type in C++ has an alignment requirement, which dictates that its memory address must be a multiple of a certain number (power of 2). The compiler inserts padding bytes to satisfy these requirements. The key rules: The alignment requirement of a struct/class is determined by its largest member. The total size of a struct/class must be a multiple of its largest alignment. 123456struct A { char a; // 1 byte double d; // 8 bytes (must be aligned to 8, d needs to start at a multiple of 8) int b; // 4 bytes (must be aligned to 4)};// total = 1 + 7(padding) + 8 + 4 + 4(padding) = 24 If we simply switch the order, we can optimize the memory layout. 123456struct A { double d; // 8 bytes (must be aligned to 8, d needs to start at a multiple of 8) int b; // 4 bytes (must be aligned to 4) char a; // 1 byte};// total = 8 + 4 + 1 + 3(padding) = 16 In class inheritance, the alignment rule is also inherited from base class. 12345678910struct Base { char a; // 1 byte int b; // 4 bytes};struct Derived : Base { double d; // 8 bytes};// total = 1 + 3(padding) + 4 + 8 = 16 We can check the alignment with alignas. 123456789struct A { char a; int b; double d;};int main() { std::cout &lt;&lt; &quot;Alignment of A: &quot; &lt;&lt; alignof(A) &lt;&lt; &quot; bytes\\n&quot;; // alignment of 8} alignas is powerful, and it allows us to control the alignment. alignas(16) forces the struct/class to align to 16 bytes. 12345struct alignas(16) A { char a; // 1 byte int b; // 4 bytes};// total = 1 + 3(padding) + 4 + 8 = 16 We can also use alignas to have fine-grain control over each individual member. 12345struct A { char a; alignas(8) int b;};// total = 1 + 7(padding) + 4 + 4(padding) = 16 We added another 4 padding at the end because the total size must be the multiple of its largest member, in our case, it would be alignas(8) int b;. alignas can be useful for SIMD optimization. We can also use the #pragma pack(1) directive controls structure packing, telling the compiler to minimize padding between members by aligning them to 1-byte boundaries instead of their natural alignment. It is compiler-specific, and its behavior can vary across different compilers. 12345678#pragma pack(1) // Disable padding (1-byte alignment)struct B { char a; // 1 byte int b; // 4 bytes};#pragma pack() // Reset to default alignment// total = 1 + 4 = 5 123456789#pragma pack(2) // Align members to 2-byte boundariesstruct A { char a; // 1 byte int b; // 4 bytes};#pragma pack() // Reset to default alignment// total = 1 + 1(padding) + 4 = 6 3. Conclusion Alignment and padding play a crucial role in C++ by optimizing memory access performance. Efficient memory layout can be achieved by strategically reordering member declarations. While we have manual control over alignment and padding, it should be used carefully to prevent unnecessary memory overhead or performance degradation. In large projects, this aspect is often overlooked. However, when a class or struct is instantiated hundreds or thousands of times, careful design becomes essential.","link":"/cpp/cpp-class-size/"},{"title":"Concept in C++","text":"C++20 introduced concept as a major language feature that allows developers to specify constraints on template parameters. Table of Contents 1. Intro 2. Concept Syntax 3. Requires Expression 4. Error Messages 5. Practices 1. IntroBefore C++20, template constraints are achieved by using SFINAE, which lacks readability and error messages. concept provides clear template constraints that are easy to read and understand. 123456// SFINAE way// specify template type to be int or chartemplate &lt;typename T&gt;std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; foo(T) { std::cout &lt;&lt; &quot;Integer overload\\n&quot;;} When T is a type of integral, then the expression std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; will be evaluated to be true. The function signature is valid. Otherwise, the function will be discarded, leading to compile error of “no matching function”. To achieve the same thing using concept. 1234567template &lt;typename T&gt;concept Integral = std::is_integral_v&lt;T&gt;; // Concept to check if T is an integral typetemplate &lt;Integral T&gt; // Use the Integral concept to constrain Tvoid print(T value) { std::cout &lt;&lt; &quot;Integral: &quot; &lt;&lt; value &lt;&lt; std::endl;} 2. Concept SyntaxWe will define a concept named Addable which checks whether two objects of type T can be added together using the + operator. Here are some common usages of how to apply this concept. 1234567891011121314151617181920212223242526272829// Define a concepttemplate&lt;typename T&gt;concept Addable = requires(T a, T b) { {a + b} -&gt; std::convertible_to&lt;T&gt;;};// method 1: template parameter constrainttemplate&lt;Addable T&gt;void add1(T a, T b) { std::cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; std::endl;}// method 2: Abbreviated function template (new in C++20)void add2(Addable auto a, Addable auto b) { std::cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; std::endl;}// method 3: Trailing requires clausetemplate&lt;typename T&gt;void add3(T a, T b) requires Addable&lt;T&gt; { std::cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; std::endl;}// method 4: Requires clausetemplate&lt;typename T&gt;requires Addable&lt;T&gt;void add4(T a, T b) { std::cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; std::endl;} We can also use logical operators to combine multiple constraints. 12template &lt;typename T&gt;concept Numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;; // check if T is either int or float 12template &lt;typename T&gt;concept IntegralAndRegular = std::integral&lt;T&gt; &amp;&amp; std::regular&lt;T&gt;; // T is an integral type and supports copy, move, and equality 3. Requires ExpressionThe requires expression is a new language construct in C++20 that allows you to specify requirements within concept definitions. The basic syntax for requires is: 123requires (parameter-list) { requirement-seq } Where parameter-list is optional and requirement-seq can be one of the followings: simple requirement type requirement compound requirement nested requirement *Simple requirement requires that the expressions must be valid. 1234567template&lt;typename T&gt;concept BasicContainer = requires(T container) { container.size(); // Must have size() method container.empty(); // Must have empty() method container.begin(); // Must have begin() method container.end(); // Must have end() method}; Type requirement* requires that a type member exists and is valid. 123456template&lt;typename T&gt;concept ContainerWithTypes = requires { typename T::value_type; // Must have value_type typename T::iterator; // Must have iterator type typename T::const_iterator; // Must have const_iterator type}; Compound requirementBasic syntax: 123456requires { expression1 -&gt; ReturnType; expression2 -&gt; ReturnType; expression3 -&gt; ReturnType; ...} A compound requirement does two things: Checks if the expression is valid. Checks whether the result type of the expression matches a given type. 1234567template&lt;typename T&gt;concept Comparable = requires(T a, T b) { // Expression must be valid AND return bool { a == b } -&gt; std::convertible_to&lt;bool&gt;; { a != b } -&gt; std::convertible_to&lt;bool&gt;; { a &lt; b } -&gt; std::convertible_to&lt;bool&gt;;}; Nested requirement is a situation where a requires clause is embedded inside another requires clause. It performs additional constraints check. 12345678910111213template&lt;typename T&gt;concept ComplexContainer = requires(T container) { // Simple requirements container.size(); container.empty(); // Nested requirements requires std::same_as&lt;typename T::value_type, int&gt;; requires requires(typename T::iterator it) { *it; ++it; };}; 4. Error MessagesUnlike SFINAE (which only output: “no matching function found”), with concept, we can have a more clear error message. In case if we accidentally use a wrong data type: 123456template&lt;std::signed_integral T&gt;T process_signed_integer(T value) { return value * 2;}process_signed_integer(1.0); We will see a error message like this: 12345678910Compiler returned: 1Compiler stderr&lt;source&gt;:46:5: error: no matching function for call to 'process_signed_integer' 46 | process_signed_integer(1.0); | ^~~~~~~~~~~~~~~~~~~~~~&lt;source&gt;:36:3: note: candidate template ignored: constraints not satisfied [with T = double] 36 | T process_signed_integer(T value) { | ^&lt;source&gt;:35:10: note: because 'double' does not satisfy 'signed_integral' 35 | template&lt;std::signed_integral T&gt; 5. PracticesHere’s a practical real-world example to illustrate the use of concept. Imagine we are developing an e-commerce platform for selling products. We can simply classify products into two categories: physical products and digital products. All products share some common attributes, such as a name, price, and unique ID. However, each product type also has its own specific characteristics—for instance, physical products may include properties like weight and dimensions, while digital products might have attributes such as file size and download link. 123456789101112131415161718192021222324252627// Basic concept: What every product in our store must havetemplate&lt;typename T&gt;concept Product = requires(T product) { // Every product must have these basic properties { product.get_name() } -&gt; std::convertible_to&lt;std::string&gt;; { product.get_price() } -&gt; std::convertible_to&lt;double&gt;; { product.get_id() } -&gt; std::convertible_to&lt;int&gt;; // Every product must be able to display itself { product.display_info() } -&gt; std::convertible_to&lt;std::string&gt;;};// Concept for products that can be shipped physicallytemplate&lt;typename T&gt;concept PhysicalProduct = Product&lt;T&gt; &amp;&amp; requires(T product) { { product.get_weight() } -&gt; std::convertible_to&lt;double&gt;; { product.get_dimensions() } -&gt; std::convertible_to&lt;std::string&gt;; { product.is_fragile() } -&gt; std::convertible_to&lt;bool&gt;;};// Concept for products that can be downloadedtemplate&lt;typename T&gt;concept DigitalProduct = Product&lt;T&gt; &amp;&amp; requires(T product) { { product.get_file_size() } -&gt; std::convertible_to&lt;long&gt;; { product.get_download_link() } -&gt; std::convertible_to&lt;std::string&gt;; { product.get_format() } -&gt; std::convertible_to&lt;std::string&gt;;}; References https://en.cppreference.com/w/cpp/concepts.html https://en.cppreference.com/w/cpp/language/requires.html https://en.cppreference.com/w/cpp/language/constraints.html","link":"/cpp/cpp-concept/"},{"title":"constexpr VS consteval","text":"Discuss some differences. 1. IntroductionIn C++, both constexpr and consteval are used to indicate that a function or variable should be evaluated at compile time. However, they have different purposes and restrictions. 2. Compare constexpr consteval definition can be applied to variables, functions, and constructors since C++20, can only be applied to functions. evaluation 1. A constexpr function can be evaluated at compile time if its arguments are compile-time constants. However, it can also be evaluated at runtime if called with runtime values.2. A constexpr variable is always a compile-time constant. A consteval function must be evaluated at compile time. If called at runtime, the program will not compile. use case constexpr is used when you want a function or variable to potentially be evaluated at compile time, but it is not mandatory. This provides more flexibility. consteval is used when you want to ensure that a function is always evaluated at compile time. 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;// constexpr function: Can be evaluated at both compile-time and runtimeconstexpr int square(int x) { return x * x;}// consteval function: Must be evaluated at compile-timeconsteval int factorial(int n) { return (n &lt;= 1) ? 1 : (n * factorial(n - 1));}int main() { // Compile-time evaluation of constexpr function constexpr int result1 = square(5); // Evaluated at compile-time // Runtime evaluation of constexpr function int y = 10; int result2 = square(y); // Evaluated at runtime std::cout &lt;&lt; &quot;square(5) (compile-time): &quot; &lt;&lt; result1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;square(10) (runtime): &quot; &lt;&lt; result2 &lt;&lt; std::endl; // Compile-time evaluation of consteval function constexpr int factResult = factorial(5); // Evaluated at compile-time std::cout &lt;&lt; &quot;factorial(5) (compile-time): &quot; &lt;&lt; factResult &lt;&lt; std::endl; // Attempt to use consteval function at runtime will cause a compilation error // int runtimeFact = factorial(y); // Uncommenting this line will cause a compilation error return 0;} 123square(5) (compile-time): 25square(10) (runtime): 100factorial(5) (compile-time): 120 1234567891011121314151617181920#include &lt;iostream&gt;struct A { int _x; constexpr A(int x) : _x(x) {}};struct B { int _x; consteval B(int x) : _x(x) {}};int main () { A a1{1}; // Compile-time int x = 1; A a2{x}; // runtime B b1{1}; // Compile-time // B b2{x}; // Error}","link":"/cpp/cpp-constexpr-consteval/"},{"title":"constexpr specifier","text":"The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Example12345678910#include &lt;iostream&gt;constexpr int accumSum(int n) { if (n == 1) return 1; return n + accumSum(n-1);}int main () { int a = accumSum(10); // evaluate during runtime} Try you code on compiler explorer On the right side, the assembly code shows that the program calls accumSum(int) function explicitly during runtime. If we add constexpr when declaring a, we can see the function call does not appear in the assembly code. const vs constexpr const can be deferred at runtime. constexpr must be evaluated at compile time. All constexpr variables are const. 12345constexpr int x = 1; // OKconstexpr int y = 2 * 3; // OKconstexpr int z; // Errorint i = 0;constexpr int j = i + 1; // Error, i is not constexpr constexpr in OOP1234567891011121314151617class Base {private: int m_i;public: constexpr Base(int i) : m_i(i) {} // A read-only function, can not change any non-static data or call any member functions that aren't constant constexpr int getVal() const { return m_i; }};int main() { constexpr Base b(5); constexpr int x = b.getVal(); std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; std::endl;} References https://en.cppreference.com/w/cpp/language/constexpr https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170","link":"/cpp/cpp-constexpr/"},{"title":"Construct Thread Objects With Member Functions","text":"Start a new thread with static/non-static member functions. 1. IntroductionAccording to cpprefenrence, to start a new thread with std::thread, its constructor takes the following parameters: Callable Object (mandatory):The first argument must be a callable object, such as: A function pointer (e.g., void myFunction()).A lambda function (e.g., []() { /* code */ }).A pointer to a member function (e.g., &amp;MyClass::myMethod).A functor (an object with an overloaded operator()). Arguments for the Callable (optional):After the callable, you can pass additional arguments to the thread’s constructor. These arguments will be passed to the callable when the thread is started. example.cpp1234567891011// 1. Function Pointerstd::thread t(functionName, arg1, arg2, ...);// 2. Lambda Functionstd::thread t([](int x) { std::cout &lt;&lt; x; }, 10); // Callable + arguments// 3. Member Functionstd::thread t(&amp;ClassName::memberFunction, &amp;object, arg1, arg2, ...);// 4. Functorstd::thread t(FunctorObject(), arg1, arg2, ...); 2. Non-static Member Functions12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;class TaskRunner {public: // Non-static member function that takes a TaskRunner pointer void taskFunction(TaskRunner* runner) { std::cout &lt;&lt; &quot;Running task with TaskRunner instance!&quot; &lt;&lt; std::endl; runner-&gt;printMessage(); // Access instance methods via the pointer } // Member function to start a new thread void startThread() { // Launch a thread with the non-static member function // Pass `this` (pointer to the current TaskRunner instance) std::thread t(&amp;TaskRunner::taskFunction, this, this); t.detach(); // Detach the thread to let it run independently } // Example member function to be accessed by taskFunction void printMessage() { std::cout &lt;&lt; &quot;Hello from TaskRunner!&quot; &lt;&lt; std::endl; }};int main() { TaskRunner runner; // Start a new thread using the non-static member function runner.startThread(); // Main thread continues execution std::cout &lt;&lt; &quot;Main thread continues...&quot; &lt;&lt; std::endl; // Give the detached thread some time to finish its work std::this_thread::sleep_for(std::chrono::seconds(1)); return 0;} Why is this passed twice? First this: It binds the non-static member function (taskFunction) to the specific instance of TaskRunner. This is necessary because taskFunction is non-static and requires an instance to operate on. Without this, the thread would not know which instance of the class to invoke the function on. Second this: It passes the current instance (this) to the function as the argument, allowing the thread to work on that instance. 3. Static Member FunctionsPassing this twice is not necessary and we can use a static member function to avoid it. This is because static member functions are not tied to any specific object instance; they behave like regular global or free functions. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;class TaskRunner {public: // Static member function that takes a TaskRunner object as a parameter static void taskFunction(TaskRunner* runner) { // Accessing member data or methods from the TaskRunner instance std::cout &lt;&lt; &quot;Task is running on TaskRunner object!&quot; &lt;&lt; std::endl; runner-&gt;printMessage(); // Example of using the object's member function } // Member function to start a new thread using the static taskFunction void startThread() { // Launch a thread with the static member function, passing `this` as the parameter std::thread t(&amp;TaskRunner::taskFunction, this); // Passing `this` to the static function t.detach(); // Detach the thread to run independently } // Example member function to be used in the static function void printMessage() { std::cout &lt;&lt; &quot;Hello from TaskRunner!&quot; &lt;&lt; std::endl; }};int main() { TaskRunner runner; // Start a new thread using the static member function runner.startThread(); // Main thread continues execution std::cout &lt;&lt; &quot;Main thread continues...&quot; &lt;&lt; std::endl; // Give the detached thread some time to finish its work std::this_thread::sleep_for(std::chrono::seconds(1)); return 0;} Static member functions can only access static data or data passed explicitly to it. Here, we pass a pointer(this) to a TaskRunner object (TaskRunner* runner) as its parameter. This allows the static function to access the instance-specific data or call other member functions of the TaskRunner object. Now, we only need to pass this once in the std::thread constructor, as it serves as the argument for the static member function. References https://en.cppreference.com/w/cpp/thread/thread/thread","link":"/cpp/cpp-construct-thread-with-member-functions/"},{"title":"C++ Insights Tool","text":"C++ Insights is an open-source tool that transforms C++ source code into a representation closer to what compiler sees and generates. It helps understand the underlying details of C++. 1. IntroductionOnline version: https://cppinsights.io/ A binary release is available, allowing you to install the tool on your local machine. Upon opening it in the browser, a default example is displayed, demonstrating its capabilities. The left pane shows the input C++ source code, while the right pane presents the translated version enriched with additional information. 2. Translating range-based for loopbefore.cpp1234567int main() { std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5}; for (int num : numbers) { std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; } return 0;} after.cpp123456789101112131415int main(){ std::vector&lt;int, std::allocator&lt;int&gt; &gt; numbers = std::vector&lt;int, std::allocator&lt;int&gt; &gt;{std::initializer_list&lt;int&gt;{1, 2, 3, 4, 5}, std::allocator&lt;int&gt;()}; { std::vector&lt;int, std::allocator&lt;int&gt; &gt; &amp; __range1 = numbers; __gnu_cxx::__normal_iterator&lt;int *, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; __begin1 = __range1.begin(); __gnu_cxx::__normal_iterator&lt;int *, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; __end1 = __range1.end(); for(; __gnu_cxx::operator!=(__begin1, __end1); __begin1.operator++()) { int num = __begin1.operator*(); std::operator&lt;&lt;(std::cout.operator&lt;&lt;(num), &quot; &quot;); } } return 0;} 3. Translating template instantiationLet’s test a fold expression. before.cpp12345678910template&lt;typename T, typename... Ts&gt;auto average(T value, Ts... values) { auto n = (1. + sizeof...(Ts)); return ((value / n) + ... + (values / n)); // (init op ... op pack)}int main() { std::cout &lt;&lt; average(1.0, 2.0, 3.0); return 0;} after.cpp12345678910111213141516171819202122template&lt;typename T, typename ... Ts&gt;auto average(T value, Ts... values){ double n = (1.0 + static_cast&lt;double&gt;(sizeof...(Ts))); return ((value / n) + ... + (values / n));}#ifdef INSIGHTS_USE_TEMPLATEtemplate&lt;&gt;double average&lt;double, double, double&gt;(double value, double __values1, double __values2){ double n = (1.0 + static_cast&lt;double&gt;(2)); return ((value / n) + (__values1 / n)) + (__values2 / n);}#endifint main(){ std::cout.operator&lt;&lt;(average(1.0, 2.0, 3.0)); return 0;} 4. Translating Lambda expressionbefore.cpp12345int main() { auto add = [](int a, int b) { return a + b; }; std::cout &lt;&lt; add(3, 4) &lt;&lt; std::endl; return 0;} after.cpp123456789101112131415161718192021222324252627282930int main(){ class __lambda_5_16 { public: inline /*constexpr */ int operator()(int a, int b) const { return a + b; } using retType_5_16 = int (*)(int, int); inline constexpr operator retType_5_16 () const noexcept { return __invoke; }; private: static inline /*constexpr */ int __invoke(int a, int b) { return __lambda_5_16{}.operator()(a, b); } }; __lambda_5_16 add = __lambda_5_16{}; std::cout.operator&lt;&lt;(add.operator()(3, 4)).operator&lt;&lt;(std::endl); return 0;} 5. Translating implicit conversionIn order to show implicit conversion, we need to enable Show all implicit casts in the dropdown list. before.cpp12345678void func(double i) {}int main() { func(3); unsigned int a = 1u; char buff[3] = {1, 2}; return 0;} after.cpp12345678910111213void func(double i){}int main(){ func(static_cast&lt;double&gt;(3)); unsigned int a = 1U; char buff[3] = {static_cast&lt;char&gt;(1), static_cast&lt;char&gt;(2), '\\0'}; return 0; /* buff // lifetime ends here */ /* a // lifetime ends here */} 5. Translating conversion operatorbefore.cpp123456789101112131415struct A {};struct B { operator A() {return {};}};void func(const A&amp; a) {}int main() { B b; A a = b; func(B{}); return 0;} after.cpp123456789101112131415161718192021222324252627struct A{};struct B{ inline operator A () { return {}; } // inline constexpr B() noexcept = default;};void func(const A &amp; a){}int main(){ B b; A a = b.operator A(); func(static_cast&lt;const A&gt;(B{}.operator A())); return 0;} 6. Translating auto-type deductionbefore.cpp123456789101112131415161718192021#include &lt;initializer_list&gt;auto a = 3;const auto ca = a;const auto&amp; ra = a;auto&amp;&amp; ref1 = a;auto&amp;&amp; ref2 = ca;auto&amp;&amp; ref3 = 3;auto a1 = 3;auto a2(3);auto a3 = {1};auto a4{3}; // narrowing checkint* p;const int* cp;const int* const ccp = cp;auto b1 = p;auto b2 = cp;auto b3 = ccp; after.cpp123456789101112131415161718192021#include &lt;initializer_list&gt;int a = 3;const int ca = a;const int &amp; ra = static_cast&lt;const int&gt;(a);int &amp; ref1 = a;const int &amp; ref2 = ca;int &amp;&amp; ref3 = 3;int a1 = 3;int a2 = 3;std::initializer_list&lt;int&gt; a3 = std::initializer_list&lt;int&gt;{1};int a4 = {3};int * p;const int * cp;const int *const ccp = cp;int * b1 = p;const int * b2 = cp;const int * b3 = ccp; When using auto, the deduced type will: Preserve top-level const for references. Ignore top-level const for non-reference types. Here, ccp is not a reference, so the top-level const (the const on the pointer itself) is ignored, while the low-level const (the const on the object being pointed to) is preserved. References https://www.youtube.com/watch?v=6A4dcKy46-Y","link":"/cpp/cpp-cpp-insights-tool/"},{"title":"CRTP","text":"Curiously Recurring Template Pattern 1. What is CRTP?A CRTP is where a Derived class: Inherits from a template class. Uses the derived class itself as a template parameter of the base class. CRTT enables static polymorphism, reducing the overhead of dynamic dispatch(dynamic polymorphism) when using virtual functions. 12345678910111213141516171819202122#include &lt;iostream&gt;template &lt;typename T&gt;class Base {public: void interface() { static_cast&lt;T*&gt;(this)-&gt;implement(); }};class Derived : public Base&lt;Derived&gt; {public: void implement() { std::cout &lt;&lt; &quot;Derived: implement()\\n&quot;; }};int main() { Derived d; d.interface();} 2. Two Forms of CRTP2.1 Static InterfaceThis usage of CRTP is really similar to the runtime polymorphism, where the Base class represents the interface(no actual implementation) and the Derived one represents the detailed implementation of that interface. The difference is that there is no vtable and associated vptr in the code. All the polymorphic calls are resolved at compile time, avoiding the runtime virtual function look-up cost. Since all the information is known at compile time, It is the developers’ responsibility to carefully design the inheritance hierarchy and make sure the right polymorphic calls are correctly implemented, otherwise, we will get runtime errors of “undefined reference” to some functions. 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;template &lt;typename T&gt;struct Base { int getValue() { return static_cast&lt;T *&gt;(this)-&gt;getValue(); }};struct Derived1 : Base&lt;Derived1&gt; { int getValue() const { return 1; }};struct Derived2 : Base&lt;Derived2&gt; { Derived2(int val) : x(val) {} int getValue() const { return x; }private: int x = 0;};template &lt;typename T&gt;void print(Base&lt;T&gt;&amp; obj) { std::cout &lt;&lt; obj.getValue() &lt;&lt; '\\n';}int main() { Derived1 d1; Derived2 d2{2}; print&lt;Derived1&gt;(d1); print&lt;Derived2&gt;(d2);} 2.2 Adding FunctionalitiesAdding functionalities(also called mixin pattern) allows the Base class to provide reusable functionalities that can operate on Derived classes. For example, let’s say we have different logging behaviors for different Systems. 1234567891011121314151617181920212223class Application : public Base&lt;Application&gt; {public: Application(double delay) : delay_{delay} {} std::string getName() const {return &quot;App&quot;;} double getDelayTime() const {return delay_;} void log() { std::cout &lt;&lt; getName() &lt;&lt; &quot;, delayed: &quot; &lt;&lt; getDelayTime() &lt;&lt; '\\n'; }private: double delay_ = 0.0;};class Server : public Base&lt;Server&gt; {public: Server(double delay) : delay_{delay} {} std::string getName() const {return &quot;Server&quot;;} double getDelayTime() const {return delay_;} void log() { std::cout &lt;&lt; getName() &lt;&lt; &quot;, delayed: &quot; &lt;&lt; getDelayTime() &lt;&lt; '\\n'; }private: double delay_ = 0.0;}; If other systems also require this logging capability, do we need to duplicate the same implementation in each new derived class? With CRTP, we can encapsulate the common functionality in the Base class and seamlessly apply it to all Derived classes, eliminating redundant code. 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;template &lt;typename T&gt;class Base {public: void log() { T* ptr = static_cast&lt;T*&gt;(this); std::cout &lt;&lt; ptr-&gt;getName() &lt;&lt; &quot;, delayed: &quot; &lt;&lt; ptr-&gt;getDelayTime() &lt;&lt; '\\n'; }};class Application : public Base&lt;Application&gt; {public: Application(double delay) : delay_{delay} {} std::string getName() const {return &quot;App&quot;;} double getDelayTime() const {return delay_;}private: double delay_ = 0.0;};class Server : public Base&lt;Server&gt; {public: Server(double delay) : delay_{delay} {} std::string getName() const {return &quot;Server&quot;;} double getDelayTime() const {return delay_;}private: double delay_ = 0.0;};int main() { Application a{1000.0}; Server s{100.0}; a.log(); s.log();} 3. Can we remove static_cast?As we probably can see, we have to mannually cast the Base this pointer to a Derived type in order to use Derived functions. Extensive use of static_cast makes the code looks heavy. Are we able to get rid of it? The answer is YES. In C++ 23, we can use explicit object parameter to explicitly use the Derived object as a parameter, avoiding the need of static_cast. 12345678910111213141516171819#include &lt;iostream&gt;template &lt;typename Derived&gt;struct Base { void interface(this Derived&amp; self) { self.implementation(); }};struct Derived : Base&lt;Derived&gt; { void implementation() { std::cout &lt;&lt; &quot;Derived implementation\\n&quot;; }};int main() { Derived d; d.interface();} 4. A Perfect Replacement for Virtual Functions?Though CRTP avoids the runtime overhead, it is not always a perfect replacement for virtual functions. I think the two most significant limitations are: One major downside of CRTP is that every derived class creates a new instantiation of the base class template, which can lead to code bloat and prevent shared base-class behavior across different derived types. With virtual functions, you can store objects of different derived types in a std::vector&lt;Base*&gt;. With CRTP, this is not possible, as the base class is templated and does not define a common type. References https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/ https://www.youtube.com/watch?v=pmdwAf6hCWg&amp;t=1291s","link":"/cpp/cpp-crtp/"},{"title":"decltype specifier","text":"Since C++11 1. Value Category Three primary value categories: prvalue, xvalue, and lvalue. Two mixed categories: glvalue, value. Category Definition lvalue Represents an object that occupies a specific location in memory rvalue Temporary value without a persistent memory address. glvalue (generalized lvalue) Represents an expression that refers to a memory location. xvalue (expiring value) Represents an object that is about to be moved from. It denotes an object whose resources can be reused. prvalue (pure rvalue) Represents a temporary value that does not have a memory location. It is used to initialize objects. The concept of xvalue can be really confusing. Here are some common scenarios where xvalue is relevant. 123456789101112131415161718192021222324252627282930313233int&amp;&amp; foo() { int x = 42; return std::move(x); // std::move(x) is an xvalue}struct A { A() {}};int main() { /* Example 1: using std::move() to cast a lvalue to rvalue reference. */ int x = 10; int&amp;&amp; a = std::move(x); // std::move(x) is an xvalue /* Example 2: Function Returning an rvalue Reference. */ int&amp;&amp; b = foo(); // foo() is an xvalue /* Example 3: Temporary objects in expressions when they are cast to rvalue references. */ A&amp;&amp; c = A(); /* Example 4: cast literals to rvalue references */ int&amp;&amp; d = static_cast&lt;int&amp;&amp;&gt;(5); return 0;} Why does xvalue belong to both glvalue and rvalue? Here are two explanations: Resource reuse: An xvalue represents an object whose resources can be reused, typically because it is about to go out of scope or is explicitly marked for resource transfer. This makes xvalue similar to an rvalue, which represents temporary objects that can be moved or copied from. Memory location: Despite being suitable for resource transfer, an xvalue still refers to a specific location in memory, just like an lvalue. We can still take the address of an xvalue and use it to access the object’s memory. 2. decltypeThe decltype specifier is used to query the type of an expression. Its syntax can be: decltype(entity) decltype(expression) Based on the explanation in cppreference, we have two categories for using decltype. If the argument is an unparenthesized id-expression or an unparenthesized class member access expression, then decltype yields the type of the entity named by this expression. If there is no such entity, or if the argument names a set of overloaded functions, the program is ill-formed. 123456789101112131415161718192021222324252627282930313233343536373839int foo() { return 3;}struct E { double m;};void func(int) {}void func(double) {}int main() { /* Example 1: variable */ int a = 42; decltype(a) b = 5; // b has type int because a is an int std::cout &lt;&lt; &quot;Type of b: &quot; &lt;&lt; typeid(b).name() &lt;&lt; '\\n'; /* Example 2: function */ decltype(foo()) d = foo(); std::cout &lt;&lt; &quot;Type of d: &quot; &lt;&lt; typeid(d).name() &lt;&lt; '\\n'; /* Example 3: member variable */ E e; decltype(e.m) f = 1.; std::cout &lt;&lt; &quot;Type of f: &quot; &lt;&lt; typeid(f).name() &lt;&lt; '\\n'; /* Example 4: overloaded functions */ decltype(func) g; // Error, overloaded functions return 0;} If the argument is any other expression of type T, and a) if the value category of expression is xvalue, then decltype yields T&amp;&amp;; b) if the value category of expression is lvalue, then decltype yields T&amp;; c) if the value category of expression is prvalue, then decltype yields T. 12345678910111213141516171819202122int main() { /* Example 1: xvalue */ int a = 1; decltype(std::move(a)) b = 3; std::cout &lt;&lt; &quot;Type of b: &quot; &lt;&lt; typeid(b).name() &lt;&lt; '\\n'; /* Example 2: lvalue */ int c = 3; decltype(c) d1 = c; // x is an lvalue, decltype(x) is int decltype((c)) d2 = c; // (x) is an lvalue expression, decltype((x)) is int&amp; /* Example 3: prvalue */ int e = 42; decltype(42) f1 = 42; // f1 is int decltype(e + 1) f2 = e + 1; // f2 is int} 3. Parenthesized VS UnparenthesizedIf the name of an object is parenthesized, it is treated as an ordinary lvalue expression. When decltype is used with an unparenthesized expression, it simply yields the type of the named entity. When decltype is used with a parenthesized expression, it yields a type based on the value category of the expression inside the parentheses.1234567891011int x = 42;int&amp; lref = x; // lvalue reference to xint&amp;&amp; rref = 42; // rvalue reference to a temporary int// Unparenthesized expressionsdecltype(x) a = 5; // a is intdecltype(lref) b = x; // b is int&amp;, because lref is an lvalue reference// Parenthesized expressionsdecltype((x)) c = x; // c is int&amp; because (x) is an lvaluedecltype((lref)) d = x; // d is int&amp; because (lref) is an lvalue To summarize, for parenthesized expression, it yields the type of the named entity.. For unparenthesized expression, it yields a type based on the value category of the expression inside the parentheses. References https://en.cppreference.com/w/cpp/language/value_category https://en.cppreference.com/w/cpp/language/decltype","link":"/cpp/cpp-decltype/"},{"title":"C++ Function Pointers","text":"Introduce 4 ways to define function pointers in C++. Traditional typedef using std::function 1. TraditionalSyntax 1234return_type (*pointer_name)(parameter_types1, parameter_types2);// exampleint (*funcPtr)(int, int); 2. typedefSyntax 1234typedef return_type (*pointer_name)(parameter_types1, parameter_types2);// exampletypedef int (*funcPtr)(int, int); funcPtr becomes an alias for the type “pointer to a function that takes two int parameters and returns an int”. 3. usingSyntax 1234using pointer_name = return_type (*)(parameter_types1, parameter_types2);// exampleusing funcPtr = int (*)(int, int) funcPtr becomes an alias for the type “pointer to a function that takes two int parameters and returns an int”. 4. std::functionSyntax 1234std::function&lt;return_type(parameter_types1, parameter_types2)&gt; pointer_name;// examplestd::function&lt;int(int, int)&gt; funcPtr; 5. Example1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;functional&gt;int add(int a, int b) { return a + b;}int main() { // 1. traditional int (*funcPtr1)(int, int); funcPtr1 = add; std::cout &lt;&lt; funcPtr1(1, 2) &lt;&lt; '\\n'; // 2. typedef typedef int (*AddFunc_typedef)(int, int); AddFunc_typedef funcPtr2 = add; std::cout &lt;&lt; funcPtr2(1, 2) &lt;&lt; '\\n'; // 3. using using AddFunc_using = int (*)(int, int); AddFunc_using funcPtr3 = add; std::cout &lt;&lt; funcPtr3(1, 2) &lt;&lt; '\\n'; // 4. std::function std::function&lt;int(int, int)&gt; funcPtr4 = add; std::cout &lt;&lt; funcPtr4(1, 2) &lt;&lt; '\\n'; return 0;}","link":"/cpp/cpp-define-function-pointers/"},{"title":"C++ Dependent Name","text":"In C++, a dependent name refers to a name (e.g., a type, variable, function, or template) whose meaning depends on a template parameter. This concept arises in the context of templates, where the compiler cannot fully resolve certain names until the template is instantiated with specific types or values. 1. IntroductionWhen the compiler processes a template definition, it performs a two-phase lookup: Non-dependent names: Resolved at the point of template definition (when the template is written). Dependent names: Resolved at the point of template instantiation (when the template is used with concrete types). Because dependent names rely on template parameters, the compiler delays their resolution until it knows the actual types involved. This introduces some special rules and syntax, like the typename and template keywords, to help the compiler distinguish between types and non-types or to access nested template members. 2. An all-in-one example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;// A helper struct with various dependent elementsstruct MyStruct { using value_type = int; // Dependent type static double scale; // Dependent variable void process() { // Dependent function std::cout &lt;&lt; &quot;Processing in MyStruct\\n&quot;; } // Templated member function with a return value template &lt;typename U&gt; U transform(U value) { std::cout &lt;&lt; &quot;Transforming: &quot; &lt;&lt; value &lt;&lt; &quot;\\n&quot;; return value * 2; }};// Define the static variabledouble MyStruct::scale = 2.5;// A template class that uses dependent namestemplate &lt;typename T&gt;class Worker {public: void run(T obj, float input) { // 1. Dependent Type typename T::value_type result = 10; // 2. Dependent Variable double scaled = input * T::scale; // 3. Dependent Function Call obj.process(); // 4. Dependent Function Template with Return Value float transformed = obj.template transform&lt;float&gt;(scaled); // Capture return value std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; &quot;, Scaled: &quot; &lt;&lt; scaled &lt;&lt; &quot;, Transformed: &quot; &lt;&lt; transformed &lt;&lt; &quot;\\n&quot;; }};int main() { MyStruct s; Worker&lt;MyStruct&gt; w; w.run(s, 4.0f); return 0;}","link":"/cpp/cpp-dependent-name/"},{"title":"Design Iterator","text":"Design a customized iterator. IntroductionToday, we will explore how to design a customized iterator. Iterators in C++ are convenient to iterate over a collection of elements in C++ standard contains. The example below shows some common operations in iterators. 1234567891011121314151617181920212223242526int main() { std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5}; std::vector&lt;int&gt;::iterator bit = vec.begin(); std::vector&lt;int&gt;::iterator eit = vec.end(); std::cout &lt;&lt; *bit &lt;&lt; std::endl; bit++; std::cout &lt;&lt; *bit &lt;&lt; std::endl; bit--; std::cout &lt;&lt; *bit &lt;&lt; std::endl; if (bit == eit) { std::cout &lt;&lt; &quot;same position\\n&quot;; } else { std::cout &lt;&lt; &quot;different position\\n&quot;; } for (auto it = vec.begin(); it != vec.end(); it++) { std::cout &lt;&lt; *it &lt;&lt; std::endl; } return 0;} 12345678910output:121different position12345 CodeIn order to write our own iterator, we will continue to use the Vector class we designed from previous tutorial. But we still need to change it a little bit to make our code nice and clean. Vector.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#pragma once#include &lt;new&gt;template &lt;typename Vector&gt;class VectorIterator {public: using ValueType = typename Vector::ValueType; using PointerType = ValueType*; using ReferenceType = ValueType&amp;;public: VectorIterator(PointerType ptr) : _ptr(ptr) {} // prefix ++ VectorIterator&amp; operator++() { _ptr++; return *this; } // postfix ++ VectorIterator operator++(int) { VectorIterator iterator = *this; ++(*this); return iterator; } // prefix -- VectorIterator&amp; operator--() { _ptr--; return *this; } // postfix -- VectorIterator operator--(int) { VectorIterator iterator = *this; --(*this); return iterator; } ReferenceType operator[](int index) { return *(_ptr + index); } PointerType operator-&gt;() { return _ptr; } ReferenceType operator*() { return *_ptr; } bool operator==(const VectorIterator&amp; other) const { return _ptr == other._ptr; } bool operator!=(const VectorIterator&amp; other) const { return !(*this == other); }private: PointerType _ptr;};template&lt;typename T&gt;class Vector {public: using ValueType = T; using Iterator = VectorIterator&lt;Vector&lt;T&gt;&gt;;public: Vector() { ReAlloc(2); } ~Vector() { clear(); ::operator delete(_data, _capacity * sizeof(T)); } void pushback(const T&amp; value) { if (_size &gt;= _capacity) { ReAlloc(_capacity + _capacity / 2); } new(&amp;_data[_size]) T(value); _size++; } void pushback(T&amp;&amp; value) { if (_size &gt;= _capacity) { ReAlloc(_capacity + _capacity / 2); } new(&amp;_data[_size]) T(std::move(value)); _size++; } void popback() { if (_size &gt; 0) { _size--; _data[_size].~T(); } } void clear() { for (size_t i = 0; i &lt; _size; i++) { _data[i].~T(); } _size = 0; } template &lt;typename... Args&gt; T&amp; emplaceback(Args&amp;&amp;... args) { if (_size &gt;= _capacity) { ReAlloc(_capacity + _capacity / 2); } // replacement new, construct objetcs in-place new(&amp;_data[_size]) T(std::forward&lt;Args&gt;(args)...); return _data[_size++]; } T&amp; operator[](size_t index) { return _data[index]; } const T&amp; operator[](size_t index) const { if (index &gt;= _size) { __builtin_trap(); } return _data[index]; } size_t size() const {return _size;} Iterator begin() { return Iterator(_data); } Iterator end() { return Iterator(_data + _size); }private: void ReAlloc(size_t newCapacity) { // 1. allocate a new block of memory // 2. copy//move old data into new block // 3. delete old data T* newBlock = (T*) ::operator new(newCapacity * sizeof(T)); // for downsize the vector if (newCapacity &lt; _size) { _size = newCapacity; } for (size_t i = 0; i &lt; _size; i++) { new (&amp;newBlock[i]) T(std::move(_data[i])); } for (size_t i = 0; i &lt; _size; i++) { _data[i].~T(); } ::operator delete(_data, _capacity * sizeof(T)); _data = newBlock; _capacity = newCapacity; }private: T* _data = nullptr; size_t _size = 0; size_t _capacity = 0;}; main.cpp 1234567891011121314151617181920#include &quot;Array.h&quot;#include &quot;Vector.h&quot;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;int main() { Vector&lt;std::string&gt; vec; vec.pushback(&quot;C++&quot;); vec.pushback(&quot;Kotlin&quot;); vec.emplaceback(&quot;Mojo&quot;); for (auto it = vec.begin(); it != vec.end(); it++) { std::cout &lt;&lt; *it &lt;&lt; std::endl; } return 0;} 1234output:C++KotlinMojo","link":"/cpp/cpp-design-iterator/"},{"title":"Design Matrix","text":"Design a customized Matrix. IntroductionToday, we will explore how to design a customized Matrix class. Matrix is widely used in image processing and scientific computation as data holder. A Matrix data type should have the following attributes and functions: size: height and width data type: int, float, double addition: + subtraction: - multiplication: * scalar multiplication: * transpose CodeMat.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#pragma once#include &lt;iostream&gt;#include &lt;initializer_list&gt;template &lt;typename T&gt;class Mat {public: static Mat zeros(int rows, int cols) { Mat mat(rows, cols); return mat; } static Mat ones(int rows, int cols) { Mat mat(rows, cols); mat.fill(static_cast&lt;T&gt;(1)); return mat; }public: constexpr Mat() : _row(0), _col(0) {} constexpr Mat(const int row, const int col) : _row(row), _col(col) { if (_row &gt; 0 &amp;&amp; _col &gt; 0) { _totalElements = _row * _col; _data = (T*) ::operator new(_totalElements * sizeof(T)); } else { std::cerr &lt;&lt; &quot;_row &gt; 0 &amp;&amp; _col &gt; 0&quot; &lt;&lt; std::endl; _row = 0; _col = 0; _data = nullptr; } } constexpr Mat(const Mat&amp; other) { *this = other; } ~Mat() { for (size_t i = 0; i &lt; _totalElements; i++) { _data[i].~T(); } ::operator delete(_data, _totalElements * sizeof(T)); } const T* operator[](int row) const { return _data + row * _col; } Mat&amp; operator=(std::initializer_list&lt;T&gt; values) { _data = (T*) ::operator new(_totalElements * sizeof(T)); std::copy(values.begin(), values.end(), _data); return *this; } bool operator==(const Mat&amp; other) { if (_data == other._data &amp;&amp; _row == other._row &amp;&amp; _col == other._col) return true; else return false; } Mat&amp; operator=(const Mat&amp; other) { if (*this == other) return *this; _row = other._row; _col = other._col; if (_row == other._row &amp;&amp; _col == other._col &amp;&amp; (_row &gt; 0 &amp;&amp; _col &gt; 0)) { _totalElements = _row * _col; _data = (T*) ::operator new(_totalElements * sizeof(T)); for (size_t i = 0; i &lt; _row; i++) { for (size_t j = 0; j &lt; _col; j++) { auto idx = _index(i, j, _col); _data[idx] = other._data[idx]; } } return *this; } else { throw std::invalid_argument(&quot;matrix size must be the same.&quot;); } } Mat operator+(const Mat&amp; other) { if (other._row == _row &amp;&amp; other._col == _col) { Mat&lt;T&gt; res = *this; for (size_t i = 0; i &lt; _row; i++) { for (size_t j = 0; j &lt; _col; j++) { auto idx = _index(i, j, _col); res._data[idx] = _data[idx] + other._data[idx]; } } return res; } else { throw std::invalid_argument(&quot;matrix size must be the same.&quot;); } } Mat operator-(const Mat&amp; other) { if (other._row == _row &amp;&amp; other._col == _col) { Mat&lt;T&gt; res = *this; for (size_t i = 0; i &lt; _row; i++) { for (size_t j = 0; j &lt; _col; j++) { auto idx = _index(i, j, _col); res._data[idx] = _data[idx] - other._data[idx]; } } return res; } else { throw std::invalid_argument(&quot;matrix size must be the same.&quot;); } } Mat operator*(const Mat&amp; other) { if (other._row == _row &amp;&amp; other._col == _col) { Mat&lt;T&gt; res = *this; for (size_t i = 0; i &lt; _row; i++) { for (size_t j = 0; j &lt; _col; j++) { auto idx = _index(i, j, _col); res._data[idx] = _data[idx] * other._data[idx]; } } return res; } else { throw std::invalid_argument(&quot;matrix size must be the same.&quot;); } } Mat&amp; operator*(T scalar) { for (size_t i = 0; i &lt; _row; i++) { for (size_t j = 0; j &lt; _col; j++) { auto idx = _index(i, j, _col); _data[idx] *= scalar; } } return *this; } Mat&amp; fill(T scalar) { for (size_t i = 0; i &lt; _row; i++) { for (size_t j = 0; j &lt; _col; j++) { auto idx = _index(i, j, _col); _data[idx] = scalar; } } return *this; } Mat transpose() { Mat&lt;T&gt; res(_col, _row); for (size_t i = 0; i &lt; _row; i++) { for (size_t j = 0; j &lt; _col; j++) { auto idx1 = _index(i, j, _col); auto idx2 = _index(j, i, _row); res._data[idx2] = _data[idx1]; } } return res; } constexpr int rows() const { return _row; } constexpr int cols() const { return _col; }private: constexpr int _index(int i, int j, int stride) const { return i * stride + j; }private: int _row; int _col; int _totalElements; T* _data;}; main.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;Mat.h&quot;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;template &lt;typename T&gt;void printMat(const Mat&lt;T&gt;&amp; mat, const std::string&amp; name) { std::cout &lt;&lt; &quot;-----------&gt; &quot; &lt;&lt; name &lt;&lt; std::endl; for (int i = 0; i &lt; mat.rows(); i++) { for (int j = 0; j &lt; mat.cols(); j++) { if (i == 0 &amp;&amp; j == 0) std::cout &lt;&lt; &quot;[ &quot;; std::cout &lt;&lt; mat[i][j] &lt;&lt; &quot;, &quot;; if (i == mat.rows() - 1 &amp;&amp; j == mat.cols() - 1) std::cout &lt;&lt; &quot;]\\n&quot;; if (j == mat.cols() - 1) std::cout &lt;&lt; &quot;\\n&quot;; } }}int main() { Mat&lt;float&gt; mat1(3, 3); mat1 = {1, 2, 3, 4, 5, 6, 7, 8, 9}; printMat(mat1, &quot;mat1&quot;); Mat&lt;float&gt; mat2(3, 3); mat2 = {1, 1, 1, 1, 1, 1, 1, 1, 2}; Mat&lt;float&gt; mat3 = mat2; printMat(mat3, &quot;mat3&quot;); Mat&lt;float&gt; mat4 = mat1 + mat2; printMat(mat4, &quot;mat4&quot;); Mat&lt;float&gt; mat5 = mat1 - mat2; printMat(mat5, &quot;mat5&quot;); Mat&lt;float&gt; mat6 = mat1 * mat2; printMat(mat6, &quot;mat6&quot;); Mat&lt;float&gt; mat7(2, 3); mat7 = {1, 2, 3, 4, 5, 6}; printMat(mat7, &quot;mat7&quot;); Mat&lt;float&gt; mat7Trans = mat7.transpose(); printMat(mat7Trans, &quot;mat7Trans&quot;); Mat&lt;float&gt; mat8(3, 3); mat8 = {1, 2, 3, 4, 5, 6, 7, 8, 9}; printMat(mat8, &quot;mat8&quot;); mat8 = mat8 * 2.0f; printMat(mat8, &quot;mat8&quot;); Mat&lt;float&gt; mat9 = Mat&lt;float&gt;::zeros(3, 3); printMat(mat9, &quot;mat9&quot;); Mat&lt;float&gt; mat10 = Mat&lt;float&gt;::ones(3, 3); printMat(mat10, &quot;mat10&quot;); return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354output:-----------&gt; mat1[ 1, 2, 3, 4, 5, 6, 7, 8, 9, ]-----------&gt; mat3[ 1, 1, 1, 1, 1, 1, 1, 1, 2, ]-----------&gt; mat4[ 2, 3, 4, 5, 6, 7, 8, 9, 11, ]-----------&gt; mat5[ 0, 1, 2, 3, 4, 5, 6, 7, 7, ]-----------&gt; mat6[ 1, 2, 3, 4, 5, 6, 7, 8, 18, ]-----------&gt; mat7[ 1, 2, 3, 4, 5, 6, ]-----------&gt; mat7Trans[ 1, 4, 2, 5, 3, 6, ]-----------&gt; mat8[ 1, 2, 3, 4, 5, 6, 7, 8, 9, ]-----------&gt; mat8[ 2, 4, 6, 8, 10, 12, 14, 16, 18, ]-----------&gt; mat9[ 0, 0, 0, 0, 0, 0, 0, 0, 0, ]-----------&gt; mat10[ 1, 1, 1, 1, 1, 1, 1, 1, 1, ]","link":"/cpp/cpp-design-matrix/"},{"title":"Design Vector","text":"Design a customized vector container. IntroductionI am launching a fresh blog series dedicated to object-oriented design with C++. The inspiration behind this initiative stems from my job interviews, where over 70% of the positions requiring C++ skills focused on designing scenarios rather than typical leetcode-style problems. This experience highlighted the significance of understanding design patterns and the principles of object-oriented programming (OOP). Today, we will explore how to design a vector container in C++. Some basic requirements for our customized vector would be: pushback(): push an object/element to the end of the vector popback(): pop an object/element for the end of the vector size(): get the size of the vector emplaceback(): contruct an object in-place and push it to the end of the vector []: vector indexing clear(): deallocate the memory Other requirements: dynamic memory size allocation manage all the allocated memory adapt to different data types CodeVector.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#pragma once#include &lt;new&gt;template&lt;typename T&gt;class Vector {public: Vector() { ReAlloc(2); } ~Vector() { clear(); ::operator delete(_data, _capacity * sizeof(T)); } void pushback(const T&amp; value) { if (_size &gt;= _capacity) { ReAlloc(_capacity + _capacity / 2); } new(&amp;_data[_size]) T(value); _size++; } void pushback(T&amp;&amp; value) { if (_size &gt;= _capacity) { ReAlloc(_capacity + _capacity / 2); } new(&amp;_data[_size]) T(std::move(value)); _size++; } void popback() { if (_size &gt; 0) { _size--; _data[_size].~T(); } } void clear() { for (size_t i = 0; i &lt; _size; i++) { _data[i].~T(); } _size = 0; } template &lt;typename... Args&gt; T&amp; emplaceback(Args&amp;&amp;... args) { if (_size &gt;= _capacity) { ReAlloc(_capacity + _capacity / 2); } // replacement new, construct objetcs in-place new(&amp;_data[_size]) T(std::forward&lt;Args&gt;(args)...); return _data[_size++]; } T&amp; operator[](size_t index) { return _data[index]; } const T&amp; operator[](size_t index) const { if (index &gt;= _size) { __builtin_trap(); } return _data[index]; } size_t size() const {return _size;}private: void ReAlloc(size_t newCapacity) { // 1. allocate a new block of memory // 2. copy//move old data into new block // 3. delete old data T* newBlock = (T*) ::operator new(newCapacity * sizeof(T)); // for downsize the vector if (newCapacity &lt; _size) { _size = newCapacity; } for (size_t i = 0; i &lt; _size; i++) { new (&amp;newBlock[i]) T(std::move(_data[i])); } for (size_t i = 0; i &lt; _size; i++) { _data[i].~T(); } ::operator delete(_data, _capacity * sizeof(T)); _data = newBlock; _capacity = newCapacity; }private: T* _data = nullptr; size_t _size = 0; size_t _capacity = 0;}; main.cpp 12345678910111213141516171819202122232425262728template &lt;typename T&gt;void printVector(const Vector&lt;T&gt;&amp; vec) { for (size_t i = 0; i &lt; vec.size(); i++) { std::cout &lt;&lt; vec[i] &lt;&lt; std::endl; } std::cout &lt;&lt; &quot;-----------\\n&quot;;}int main() { Vector&lt;std::string&gt; vec; vec.pushback(&quot;C++&quot;); vec.pushback(&quot;Kotlin&quot;); vec.emplaceback(&quot;Mojo&quot;); vec.emplaceback(&quot;Python&quot;); printVector(vec); vec.popback(); printVector(vec); vec.clear(); printVector(vec); return 0;} 1234567891011output:C++KotlinMojoPython-----------C++KotlinMojo----------------------","link":"/cpp/cpp-design-vector/"},{"title":"std::enable_shared_from_this","text":"Safe ownership management. 1. Introductionstd::enable_shared_from_this is a standard library utility in C++ that helps manage std::shared_ptr instances. It allows an object to create a shared pointer (std::shared_ptr) that shares ownership of the object. This can be particularly useful when you want to ensure that a class instance can generate shared pointers to itself without creating multiple std::shared_ptr instances that manage the same object. Key Features The class that wants to use this utility should inherit from std::enable_shared_from_this&lt;T&gt;. This class provides a member function shared_from_this(), which returns a std::shared_ptr to the object. It ensures that no multiple std::shared_ptr instances try to manage the same object, preventing potential undefined behavior. 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;memory&gt;class A : public std::enable_shared_from_this&lt;A&gt; {public: A() { std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; } std::shared_ptr&lt;A&gt; getShared() { // Use shared_from_this() to create a shared_ptr that shares ownership with the existing shared_ptr return shared_from_this(); }};int main() { // Create a shared_ptr to A std::shared_ptr&lt;A&gt; ptr1 = std::make_shared&lt;A&gt;(); // Create another shared_ptr using shared_from_this() std::shared_ptr&lt;A&gt; ptr2 = ptr1-&gt;getShared(); // Both ptr1 and ptr2 share ownership of the same object std::cout &lt;&lt; &quot;ptr1 use_count: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; // Output: 2 std::cout &lt;&lt; &quot;ptr2 use_count: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; std::endl; // Output: 2 return 0;} A bad attempt to achieve the same thing without using std::enable_shared_from_this could be: 123456789101112131415161718#include &lt;iostream&gt;#include &lt;memory&gt;struct B{ std::shared_ptr&lt;B&gt; getptr() { return std::shared_ptr&lt;B&gt;(this); } ~B() { std::cout &lt;&lt; &quot;B::~B() called\\n&quot;; }};int main() { // each shared_ptr thinks it's the only owner of the object std::shared_ptr&lt;B&gt; b1 = std::make_shared&lt;B&gt;(); std::shared_ptr&lt;B&gt; b2 = b1-&gt;getptr(); return 0;} 12double free or corruption (out)Program terminated with signal: SIGSEGV 2. ExampleIn the observer pattern, we want observers to hold shared pointers to the same subject. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;class Subject;class Observer {public: void observe(const std::shared_ptr&lt;Subject&gt;&amp; subject) { subject_ = subject; } void notify() { if (auto spt = subject_.lock()) { std::cout &lt;&lt; &quot;Subject is still alive\\n&quot;; } else { std::cout &lt;&lt; &quot;Subject has been destroyed\\n&quot;; } }private: std::weak_ptr&lt;Subject&gt; subject_;};class Subject : public std::enable_shared_from_this&lt;Subject&gt; {public: void addObserver(const std::shared_ptr&lt;Observer&gt;&amp; observer) { observers_.push_back(observer); observer-&gt;observe(shared_from_this()); } void notifyObservers() { for (auto&amp; observer : observers_) { observer-&gt;notify(); } }private: std::vector&lt;std::shared_ptr&lt;Observer&gt;&gt; observers_;};int main() { auto subject = std::make_shared&lt;Subject&gt;(); auto observer1 = std::make_shared&lt;Observer&gt;(); auto observer2 = std::make_shared&lt;Observer&gt;(); subject-&gt;addObserver(observer1); subject-&gt;addObserver(observer2); subject-&gt;notifyObservers(); // Outputs: Subject is still alive subject.reset(); // Destroy the subject observer1-&gt;notify(); // Outputs: Subject has been destroyed observer2-&gt;notify(); // Outputs: Subject has been destroyed return 0;} 1234Subject is still aliveSubject is still aliveSubject has been destroyedSubject has been destroyed References https://en.cppreference.com/w/cpp/memory/enable_shared_from_this","link":"/cpp/cpp-enable-shared-from-this/"},{"title":"Enum Class","text":"Choose enum class over enum for type safety. 1. OverviewEnum class is introduced in C++11. Compared to traditional Enum, it shows differences in: Scope Underlying types Type safety Enum constants 2. Scope enum defines an enumeration in the global scope, enum values are directly accessible without any scope qualification, meaning its enumerators can potentially clash with other names in the same scope. enum class introduces scoped enumerations. Enumerators inside an enum class are scoped to the enumeration, reducing the risk of naming conflicts. 12345678910enum class Color { Red, Green, Blue};int main() { Color myColor = Color::Red; // Enum value is scoped. std::cout &lt;&lt; static_cast&lt;int&gt;(myColor) &lt;&lt; std::endl; // Prints 0 (Red)} 3. Underlying types By default, enum uses int as the underlying type for its enumerators. This can lead to unintended conversions and comparison issues. enum class requires an explicitly specified underlying type, preventing implicit conversions and providing stronger type safety. 12345678910111213141516enum Color1 { Red, Green, Blue};enum class Color2 : short { Red, Green, Blue};int main() { std::cout &lt;&lt; sizeof(Color1) &lt;&lt; std::endl; // 4, Size is implementation-dependent. std::cout &lt;&lt; sizeof(Color2) &lt;&lt; std::endl; // 2} 4. Type safety enum does not provide strong type safety. Enumerators are implicitly convertible to integers and can lead to unintended behavior. enum class enhances type safety by encapsulating enumerators within the scope of the enumeration. Enumerators are not implicitly convertible to integers, reducing potential bugs. 123456789101112enum class Color { Red, Green, Blue};int main() { Color myColor = Color::Green; if (myColor == 1) { // error, no match for 'operator==' (operand types are 'Color' and 'int') std::cout &lt;&lt; &quot;color match\\n&quot;; }} 5. Enum constants enum constants can be defined with any valid integer value, including duplicates and values outside the declared range. enum class constants are strongly enforced to be unique within the scope and adhere to the underlying type’s range. References https://agrawalsuneet.github.io/blogs/enum-vs-enum-class-in-c++/ https://en.cppreference.com/w/cpp/language/enum","link":"/cpp/cpp-enum-class/"},{"title":"Explicit Specifier","text":"Prevent C++ implicit conversion. IntroductionIn C++, the explicit keyword is used with constructors to prevent them from performing implicit conversions. Implicit means automatic. It happens without us explicitly specifying the compiler what to do. By adding the explicit keyword before a constructor, we force the compiler not to perform any implict conversions. ExanpleThe following declarations are legal. The compiler converts the single argument to the class beging constructed. 1234567891011121314class Base {public: Base() {} Base(int x) {} Base(const char* s) {}};int main() { Base b1 = 10; // equivalent to Base b1 = Base(10); Base b2 = &quot;C++&quot;; // equivalent to Base b2 = Base(&quot;C++&quot;); return 0;} To prevent such implicit conversions, we can declare constructors with explicit keyword. Thus, the previous declaration would be illegal. 1234567891011121314class Base {public: Base() {} explicit Base(int x) {} explicit Base(const char* s) {}};int main() { Base b1 = Base(10); Base b2 = Base(&quot;C++&quot;); return 0;} References https://www.ibm.com/docs/en/i/7.1?topic=only-explicit-specifier-c https://www.scaler.com/topics/cpp-explicit/","link":"/cpp/cpp-explicit/"},{"title":"Coroutine in C++","text":"Introduced in C++20 Table of Contents Coroutine Basics State machine of a coroutine First coroutine program Resume a suspending coroutine Lazy and eager coroutines Restrictions on couroutines co_yield Access coroutine data co_return co_await 1. Coroutine BasicsCoroutine is a special function that suspends its execution and then resumes later. In C++, coroutines are stackless. They suspend by returning to the caller and the data that is required for later execution is stored on heap. Compared to regular functions, coroutines are suspendable by calling co_yield or co_await. Once the coroutine decides to suspend itself, it gives control back to the caller. This allows the caller to resume executing other instructions and at some point resume the coroutine. Finally, when a coroutine reaches the end of its execution, it will return to the caller by calling co_return. Coroutines in C++ do not inherently run on separate threads. They are executed in the same thread as the caller, but they provide a way to suspend and resume execution at certain points, allowing other work to be done in between. keyword actions state co_yield output suspend co_await input suspend co_return output end 2. State machine of a coroutineA simple diagram shows the state transition of a coroutine. 3. First coroutine program123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;coroutine&gt;struct ReturnType { // A wrapper type. This is the return type of the coroutine function's prototype struct promise_type { // the compiler looks for a type with the exact name promise_type inside the return type std::suspend_never initial_suspend() {return {}; } // gets executed before a coroutine starts execution std::suspend_never final_suspend() noexcept {return {}; } // gets executed when a coroutine finishes execution ReturnType get_return_object() {return {}; } // this is the first method gets called when the coroutine is called for the first time void unhandled_exception() {} };};ReturnType foo() { std::cout &lt;&lt; &quot;1 foo\\n&quot;; co_await std::suspend_always(); // suspend std::cout &lt;&lt; &quot;2 foo\\n&quot;; // will never execute since coroutine suspends in the above line}int main(){ ReturnType r = foo(); return 0;} 11 foo 4. Resume a suspending coroutineCoroutine provides class template coroutine_handle to refer to a coroutine. According to official documentation, it has 3 main specilizations. Primary template, can be created from the promise object of type Promise. Specialization std::coroutine_handle&lt;void&gt; erases the promise type. It is convertible from other specializations. Specialization std::coroutine_handle&lt;std::noop_coroutine_promise&gt; refers to no-op coroutines. It cannot be created from a promise object 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;coroutine&gt;struct ReturnType { struct promise_type { std::suspend_never initial_suspend() {return {}; } std::suspend_never final_suspend() noexcept {return {}; } ReturnType get_return_object() { return ReturnType(std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)); } void unhandled_exception() {} }; ReturnType(std::coroutine_handle&lt;void&gt; handle) : mHandle{handle} {} std::coroutine_handle&lt;void&gt; mHandle;};ReturnType foo() { std::cout &lt;&lt; &quot;1 foo\\n&quot;; co_await std::suspend_always(); std::cout &lt;&lt; &quot;2 foo\\n&quot;;}int main(){ ReturnType r = foo(); r.mHandle.resume(); // equivalent to r.mHandle(); return 0;} 121 foo2 foo 5. Lazy and eager coroutinesLazy coroutine Suspends immediately upon intial call. First line of the coroutine body executes only when resumes. 1234567struct ReturnType { struct promise_type { std::suspend_always initial_suspend() {return {}; } ... }; ...}; Eager coroutine Starts immediately upon intial call. First line of the coroutine body always get executed. 1234567struct ReturnType { struct promise_type { std::suspend_never initial_suspend() {return {}; } ... }; ...}; 6. Restrictions on couroutinesAccording to cppreference, courotines do not apply to some cases, such as variadic arguments, plain return statements, or placeholder return types (auto or Concept),consteval functions, constexpr functions, constructors, destructors, and the main function. Some common scenarios where we can use coroutines. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct ReturnType { struct promise_type { std::suspend_never initial_suspend() {return {}; } std::suspend_never final_suspend() noexcept {return {}; } ReturnType get_return_object() { return ReturnType(std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)); } void unhandled_exception() {} }; ReturnType(std::coroutine_handle&lt;void&gt; handle) : mHandle{handle} {} std::coroutine_handle&lt;void&gt; mHandle;};struct Foo { // 1. member functions ReturnType func() { co_await std::suspend_always(); } // 2. static member functions static ReturnType staticFunc() { std::cout &lt;&lt; &quot;1 staticFunc\\n&quot;; co_await std::suspend_always(); std::cout &lt;&lt; &quot;2 staticFunc\\n&quot;; }};struct Base { // 3. pure virtual functions virtual ReturnType pure() const = 0;};struct Derived : public Base { // 4. overriding coroutine ReturnType pure() const override { std::cout &lt;&lt; &quot;1 pure\\n&quot;; co_await std::suspend_always(); std::cout &lt;&lt; &quot;2 pure\\n&quot;; }};// 5. lambda expressionauto lambdaFunc = [](auto ... params) -&gt; ReturnType { std::cout &lt;&lt; &quot;1 pure\\n&quot;; co_await std::suspend_always(); std::cout &lt;&lt; &quot;2 pure\\n&quot;;}; 7. co_yieldTo use co_yield, promise_type needs to define a method yield_value. After yield_value is called, the coroutine suspends and it gives the control back to the caller. 12345678910struct ReturnType { struct promise_type { std::suspend_always yield_value(int val) { this-&gt;mVal = val; return std::suspend_always(); } ... }; ...}; To implement a simple generator with co_yield. 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;coroutine&gt;struct ReturnType { struct promise_type { int mVal; std::suspend_never initial_suspend() {return {}; } std::suspend_always final_suspend() noexcept {return {}; } ReturnType get_return_object() { return ReturnType(std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)); } void unhandled_exception() {} std::suspend_always yield_value(int val) { this-&gt;mVal = val; return std::suspend_always(); } }; ReturnType(std::coroutine_handle&lt;promise_type&gt; handle) : mHandle{handle} {} std::coroutine_handle&lt;promise_type&gt; mHandle; int getValue() const { return mHandle.promise().mVal; }};ReturnType generator(int start, int end, int step = 1) { for (int val = start; val &lt; end; val+=step) { co_yield val; }}int main(){ auto gen = generator(0, 10, 2); while(!gen.mHandle.done()) { std::cout &lt;&lt; &quot;val: &quot; &lt;&lt; gen.getValue() &lt;&lt; &quot;\\n&quot;; gen.mHandle(); } return 0;} 12345val: 0val: 2val: 4val: 6val: 8 8. Access coroutine dataMake sure final_suspend() has return type of std::suspend_always, otherwise, the coroutine will not reach its last suspend point. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;coroutine&gt;struct ReturnType { struct promise_type { std::suspend_never initial_suspend() { return {}; } std::suspend_always final_suspend() noexcept { return {}; } // make sure final_suspend() is et ReturnType get_return_object() { return ReturnType(std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)); } void unhandled_exception() { } double getValue() const { return this-&gt;val; } void setValue(double v) { this-&gt;val = v; } ~promise_type() { std::cout &lt;&lt; &quot;~promise_type\\n&quot;; this-&gt;val = 1.23; } private: double val = 1.23; }; // promise_type ReturnType(std::coroutine_handle&lt;promise_type&gt; handle) : mHandle{handle} {} // implicit conversion to std::coroutine_handle&lt;promise_type&gt; operator std::coroutine_handle&lt;promise_type&gt;() {return mHandle;} private: std::coroutine_handle&lt;promise_type&gt; mHandle;}; // ReturnTypeReturnType AccessDataCoroutine() { std::cout &lt;&lt; &quot;1 AccessDataCoroutine\\n&quot;; co_await std::suspend_always(); std::cout &lt;&lt; &quot;2 AccessDataCoroutine\\n&quot;; co_await std::suspend_always(); std::cout &lt;&lt; &quot;3 AccessDataCoroutine\\n&quot;; co_await std::suspend_always();}double caller() { std::coroutine_handle&lt;ReturnType::promise_type&gt; h = AccessDataCoroutine(); // ReturnType contains the coroutine handle ReturnType::promise_type promise = h.promise(); // reference to the promise object. int i = 1; while (!h.done()) { promise.setValue(static_cast&lt;double&gt;(i++)); h.resume(); } return promise.getValue();}int main(){ double v = caller(); std::cout &lt;&lt; &quot;Access data from coroutine: &quot; &lt;&lt; v &lt;&lt; &quot;\\n&quot;;} 123451 AccessDataCoroutine2 AccessDataCoroutine3 AccessDataCoroutine~promise_typeAccess data from coroutine: 3 9. co_returnco_return must be defined inside promise_type struct, otherwise, the compiler will shows error message. When the coroutine reaches co_return, it will return to its caller and its state will become end. co_return can either return nothing or value(s). return_void(): In this case, a good practice is to performan some cleanup operations inisde the promise_type, such as free up the allocated memory or reset the values. return_value(T val): Depending on the return type, we should decide the data type here. This return_value method will get executed by the runtime system when coroutines return with non-empty co_return. It is important to know that these two return methods must be implemented inside the promise_type and these two can not exist at the same time. return_void example: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;coroutine&gt;struct ReturnType { struct promise_type { std::suspend_never initial_suspend() { return {}; } std::suspend_always final_suspend() noexcept { return {}; } // make sure final_suspend() is et void return_void() { this-&gt;val = 1.23; std::cout &lt;&lt; &quot;perform cleanup operation here\\n&quot;; } ReturnType get_return_object() { return ReturnType(std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)); } void unhandled_exception() { } double getValue() const { return val; } void setValue(double v) { this-&gt;val = v; } ~promise_type() { std::cout &lt;&lt; &quot;~promise_type\\n&quot;; } private: int val = 1.23; }; // promise_type ReturnType(std::coroutine_handle&lt;promise_type&gt; handle) : mHandle{handle} {} // implicit conversion operator std::coroutine_handle&lt;promise_type&gt;() {return mHandle;} private: std::coroutine_handle&lt;promise_type&gt; mHandle;}; // ReturnTypeReturnType foo() { std::cout &lt;&lt; &quot;1 foo\\n&quot;; co_await std::suspend_always(); std::cout &lt;&lt; &quot;reach co_return\\n&quot;; co_return;}void caller() { std::coroutine_handle&lt;ReturnType::promise_type&gt; h = foo(); // ReturnType contains the coroutine handle while (!h.done()) { h.resume(); }}int main(){ caller();} 1231 fooreach co_returnperform cleanup operation here return_value(T val) example: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;coroutine&gt;struct ReturnType { struct promise_type { std::suspend_never initial_suspend() { return {}; } std::suspend_always final_suspend() noexcept { return {}; } // make sure final_suspend() is always void return_value(double v) { this-&gt;val = v; std::cout &lt;&lt; &quot;assign v to this-&gt;val\\n&quot;; } ReturnType get_return_object() { return ReturnType(std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)); } void unhandled_exception() { } double getValue() const { return val; } void setValue(double v) { this-&gt;val = v; } ~promise_type() { std::cout &lt;&lt; &quot;~promise_type\\n&quot;; } private: double val = 1.23; }; // promise_type ReturnType(std::coroutine_handle&lt;promise_type&gt; handle) : mHandle{handle} {} operator std::coroutine_handle&lt;promise_type&gt;() {return mHandle;} private: std::coroutine_handle&lt;promise_type&gt; mHandle;}; // ReturnTypeReturnType foo(double value) { std::cout &lt;&lt; &quot;1 foo\\n&quot;; co_await std::suspend_always(); std::cout &lt;&lt; &quot;reach co_return value\\n&quot;; co_return value;}void caller() { std::coroutine_handle&lt;ReturnType::promise_type&gt; h = foo(5.0); // ReturnType contains the coroutine handle while (!h.done()) { h.resume(); } std::cout &lt;&lt; &quot;value from coroutine: &quot; &lt;&lt; h.promise().getValue() &lt;&lt; &quot;\\n&quot;;}int main(){ caller();} 12341 fooreach co_return valueassign v to this-&gt;valvalue from coroutine: 5 10. co_awaitco_await suspends a coroutine and returns control back to the caller. 1co_await expr; As we see in previous examples, the most common use cases are: 12co_await std::suspend_always();co_await std::suspend_never(); suspend_always and suspend_never are both C++ structs that define their own member functions for deciding the coroutine behaviors when co_await is called. member function description await_ready return a bool - if true, call await_suspend - if false, return control to caller await_suspend - if return void, return control back to caller- if return bool 1. true - return to caller 2. false - resume coroutine- if returns a coroutine handle for some other coroutine, that handle is resumed (by a call to handle.resume()) await_resume does nothing We can implement our own suspend class. 1234567891011121314class SuspendAlways {public: constexpr bool await_ready() const noexcept { return false; } constexpr void await_suspend( std::coroutine_handle&lt;&gt; ) const noexcept { } constexpr void await_resume() const noexcept { }}; We can try it in our program to see if works like std::suspend_always(); 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;coroutine&gt;struct ReturnType { // A wrapper type. This is the return type of the coroutine function's prototype struct promise_type { // the compiler looks for a type with the exact name promise_type inside the return type std::suspend_never initial_suspend() {return {}; } // gets executed before a coroutine starts execution std::suspend_never final_suspend() noexcept {return {}; } // gets executed when a coroutine finishes execution ReturnType get_return_object() {return {}; } // this is the first method gets called when the coroutine is called for the first time void unhandled_exception() {} };};class SuspendAlways {public: bool await_ready() const noexcept { std::cout &lt;&lt; &quot;await_ready()\\n&quot;; return false; } void await_suspend( std::coroutine_handle&lt;&gt; ) const noexcept { std::cout &lt;&lt; &quot;await_suspend()\\n&quot;; } void await_resume() const noexcept { std::cout &lt;&lt; &quot;await_resume()\\n&quot;; }};ReturnType foo() { std::cout &lt;&lt; &quot;1 foo\\n&quot;; co_await SuspendAlways(); // suspend std::cout &lt;&lt; &quot;2 foo\\n&quot;; // will never execute since coroutine suspends in the above line}int main(){ ReturnType r = foo(); return 0;} 1231 fooawait_ready()await_suspend() Since after the coroutine is suspended, we never resume it, so await_resume will not be called. Similarly, we can define a customized version of std::suspend_never. The main difference is that await_ready() should return true this time, and the coroutine will resume its execution. References https://www.youtube.com/watch?v=Ld_s1GtLkr4&amp;list=PL2EnPlznFzmhKDBfE0lqMAWyr74LZsFVY&amp;index=2 https://en.cppreference.com/w/cpp/coroutine/coroutine_handle https://en.cppreference.com/w/cpp/language/coroutines#:~:text=%5Bedit%5D%20Restrictions,main%20function%20cannot%20be%20coroutines.","link":"/cpp/cpp-coroutine/"},{"title":"Fold Expressions in C++","text":"Since C++17 1. IntroductionA fold expression is an instruction for the compiler to repeat the operation of an operator over a parameter pack. 2. Syntax Syntax (pack op …) Unary right fold (… op pack) Unary left fold (pack op … op init) Binary right fold (init op … op pack) Binary left fold op: could be any of the 32 binary operators. In binary folds, both ops must be the same. pack: unexpanded parameter pack. init: initial value, neither an unexpanded parameter pack or an operator. The opening and closing parentheses are a required part of the fold expression. 3. Expansion Syntax ($E$ op …) ($E_1$ op (… op ($E_{n-1}$ op $E_n$))) (… op $E$) ((($E_1$ op $E_2$) op …) op $E_n$) ($E$ op … op $I$) ($E_1$ op (… op ($E_{n-1}$ op ($E_n$ op $I$)))) ($I$ op … op $E$) (((($I$ op $E_1$) op $E2$) op …) op $E_n$) 12345678910template&lt;typename T, typename... Ts&gt;auto average(T value, Ts... values) { auto n = (1. + sizeof...(Ts)); return ((value / n) + ... + (values / n)); // (init op ... op pack)}int main() { std::cout &lt;&lt; average(1.0, 2.0, 3.0, 4.0, 5.0); return 0;} 5. Fold Expression with Comma OperatorThe comma operator in fold expressions can be used to perform multiple operations in sequence. This is particularly useful when you need to perform side effects or aggregate results while iterating through a parameter pack. 123456789101112template&lt;typename Container, typename... Values&gt;void push(Container&amp; c, Values... values) { (c.push_back(std::forward&lt;Values&gt;(values)), ...);}int main() { std::vector&lt;int&gt; vec{5}; push(vec, 1, 2, 3); for (int v : vec) { std::cout &lt;&lt; v &lt;&lt; &quot;\\n&quot;; }} A more generalized example would be applying the same function/process to each value in the parameter pack. 12345678910111213141516template&lt;typename Function, typename... Ts&gt;void apply(Function f, Ts... values) { (f(std::forward&lt;Ts&gt;(values)), ...);}int main() { std::vector&lt;int&gt; vec{5}; auto lm = [&amp;](auto i) { vec.push_back(i); }; apply(lm, 1, 2, 3); for (auto v : vec) { std::cout &lt;&lt; v &lt;&lt; &quot;\\n&quot;; }} 6. Operator PrecedenceIf the expression used as init or as pack has an operator with precedence below cast at the top level, it must be parenthesized. 123456template&lt;typename T, typename... Ts&gt;auto average(T value, Ts... values) { auto n = (1. + sizeof...(Ts)); // return ((value / n) + ... + values / n); // error, operator &quot;/&quot; has precedence lower than cast. return ((value / n) + ... + (values / n));} Here are some common operators in programming languages that have precedence below the cast operator: Assignment Operators: = (Simple assignment) += (Addition assignment) -= (Subtraction assignment) *= (Multiplication assignment) /= (Division assignment) %= (Modulus assignment) and other compound assignment operators Conditional (Ternary) Operator: ?: (Ternary operator) Logical Operators: &amp;&amp; (Logical AND) || (Logical OR) Bitwise Operators: &amp; (Bitwise AND) | (Bitwise OR) ^ (Bitwise XOR) Comma Operator: , (Comma operator, used for separating expressions or parameters) References https://en.cppreference.com/w/cpp/language/fold","link":"/cpp/cpp-fold-expressions/"},{"title":"extern keyword","text":"A summary of extern usage. 1. IntroductionThe primary purposes of using extern can be summarized as follows: Sharing variables or functions across multiple source files or translation units. Preventing name mangling when linking C++ code with C libraries. 2. Sharing variables/functionsIt is very important to remember that extern can only be used for declaration, not definition. 1234567891011121314// a.cppint var = 1;// main.cpp#include &lt;iostream&gt;extern int var; // Declaration of the variable defined in a.cppint main() { std::cout &lt;&lt; &quot;Shared variable value: &quot; &lt;&lt; var &lt;&lt; std::endl; var = 100; std::cout &lt;&lt; &quot;Modified shared variable: &quot; &lt;&lt; var &lt;&lt; std::endl; return 0;} 1234567891011121314151617181920212223// utils.h#ifndef UTILS_H#define UTILS_Hextern int add(int a, int b); // Function declaration#endif// utils.cpp#include &quot;utils.h&quot;int add(int a, int b) { // Function definition return a + b;}// main.cpp#include &lt;iostream&gt;#include &quot;utils.h&quot;int main() { std::cout &lt;&lt; &quot;5 + 3 = &quot; &lt;&lt; add(5, 3) &lt;&lt; std::endl; return 0;} 1234567891011121314// constants.hextern const int MAX_SIZE; // Declaration// constants.cppconst int MAX_SIZE = 100; // Definition// main.cpp#include &quot;constants.h&quot;#include &lt;iostream&gt;int main() { std::cout &lt;&lt; &quot;Max size: &quot; &lt;&lt; MAX_SIZE &lt;&lt; std::endl; return 0;} 3. Prevent name mangling3.1 Name mangling in C++Name mangling in C++ is the process by which the compiler generates unique names for functions, variables, and other symbols to support features such as function overloading, namespaces, and templates. For example, if we have the following source code. 1234// a.cppvoid foo(int x) {}void foo(float x) {}void foo(double x) {} We compile it and check the symbol table. The overloaded foo function is appended by different postfix. This is what we call name mangling. 12clang++ -c a.cpp -o a.onm a.o 123450000000000000020 T __Z3food0000000000000010 T __Z3foof0000000000000000 T __Z3fooi0000000000000000 t ltmp00000000000000030 s ltmp1 3.2 Issues with name manglingLet’s look at a simple example. 1234.├── function.c├── function.h└── main.cpp 123456789101112131415161718// function.hvoid foo(int value);// function.c#include &quot;function.h&quot;#include &lt;stdio.h&gt;void foo(int value) { printf(&quot;Value: %d\\n&quot;, value);}// main.cpp#include &quot;function.h&quot;int main() { foo(3); return 0;} Let’s compile the C source file to an object file. 1clang -c function.c -o function.o Then, compile the C++ source file to an object file. 1clang++ -c main.cpp -o main.o Link object files to generate an executable. We will get an error. 1clang++ function.o main.o -o main 12345Undefined symbols for architecture arm64: &quot;foo(int)&quot;, referenced from: _main in main.o (found _foo in function.o, declaration possibly missing extern &quot;C&quot;)ld: symbol(s) not found for architecture arm64 The reason is because, when we include function.h in main.cpp, the C++ compiler will mangle the function name. When we compile function.c, the C compiler will not perform name mangling. So, in main.cpp, it can not find the matching symbol name. 123456789101112131415&gt; nm main.o U __Z3fooi0000000000000000 T _main0000000000000000 t ltmp00000000000000030 s ltmp1&gt; nm function.o0000000000000000 T _foo U _printf0000000000000038 s l_.str0000000000000000 t ltmp00000000000000038 s ltmp10000000000000048 s ltmp2 3.3 Using extern “C”To solve this issue, we can introduce extern “C” when declaring functions to ensure that the function names remain consistent across both C and C++ code, enabling proper linkage. 1234567891011121314151617181920212223242526// function.h#ifdef __cplusplusextern &quot;C&quot; {#endifvoid foo(int value);#ifdef __cplusplus}#endif// function.c#include &quot;function.h&quot;#include &lt;stdio.h&gt;void foo(int value) { printf(&quot;Value: %d\\n&quot;, value);}// main.cpp#include &quot;function.h&quot;int main() { foo(3); return 0;} This time, the function symbol name should keep the same. 123456&gt; nm main.o U _foo0000000000000000 T _main0000000000000000 t ltmp00000000000000030 s ltmp1 We can sucessfully compile objects files and link them to create the executable. 1234clang -c function.c -o function.oclang++ -c main.cpp -o main.oclang++ main.o function.o -o main./main 1Value: 3","link":"/cpp/cpp-extern/"},{"title":"Function Visibility in C++","text":"Function visibility across translation units. Symbol visibility in shared libraries. 1. IntroductionIn C++, function visibility generally pertains to whether a function can be accessed from outside the translation unit in which it’s defined. Control over function visibility is essential for modular code, particularly in libraries. 2. Internal vs. External LinkageFunctions with internal linkage are visible only within the translate unit. Marking a function as static limits its visibility, meaning it can’t be used or “seen” outside that file. This helps avoid name conflicts across multiple files. 123static void internalFunction() { // Only visible within this file} A useful remind for using static in a header file: When you put a static variable definition in a header file, every .cpp file that includes that header will get its own separate instance of the static variable. This means: Each translation unit (each .cpp file) that includes the .h file will have its own unique copy of the static variable, rather than sharing one. The static variable is not shared across translation units because static gives the variable internal linkage. By default, functions without the static keyword have external linkage. This means they are visible to other translation units and can be used from other files, assuming they are declared in a shared header file. 123void externalFunction() { // Can be accessed from other files} 3. extern LinkageThe extern keyword in C++ is used for various purposes related to linkage and visibility of variables and functions. A function decorated with extern should only be defined once in its own translate unit. When shared across other translate units, it needs to be declared before using it. However, since functions without static have external linkage by default, simple forward declaration also works. 12345678910111213// a.cpp#include &lt;iostream&gt;void externalFunction() { std::cout &lt;&lt; &quot;externalFunction() from a.cpp\\n&quot;;}// main.cppextern void externalFunction();// void externalFunction(); // forward declaration also worksint main() { externalFunction(); return 1;} 4. extern “C” for C Linkage Purpose of extern “C”: When compiling in C++, function names are mangled to include extra information like return type and parameter types, enabling C++ to support function overloading. However, this name mangling means C++ functions have different names than C functions, making it difficult to link C++ code with C libraries. To solve this, extern “C” is used to instruct the compiler not to mangle the names of the functions declared within it, making them compatible with C linkage. This is often used in headers for C libraries to allow the functions to be linked and used in C++ code. 123456789#ifdef __cplusplusextern &quot;C&quot; {#endifvoid cFunction(int a);#ifdef __cplusplus}#endif 5. extern with const VariablesIn C++, const global variables have internal linkage by default (they are restricted to the file in which they’re defined). This prevents unintended access or modification, but if you need to access a const variable from other files, you can declare it with extern to give it external linkage. 1234567891011// a.cpp#include &lt;iostream&gt;extern const int myConstVar = 42; // Definition with extern// b.cpp#include &lt;iostream&gt;extern const int myConstVar; // Declaration (no initialization)void printConst() { std::cout &lt;&lt; &quot;myConstVar: &quot; &lt;&lt; myConstVar &lt;&lt; std::endl;} 6. Controlling Visibility in Shared Libraries__attribute__((visibility(&quot;default&quot;))): When creating shared libraries, function visibility can be controlled using this attribute on compilers like GCC and Clang. Functions marked with “default” visibility are exported and accessible outside the shared library. 123__attribute__((visibility(&quot;default&quot;))) void exportedFunction() { // Visible outside the shared library} It is common to define a macro that controls function or variable visibility. 12#define MYEXPORT __attribute__ ((visibility (&quot;default&quot;)))MYEXPORT int add(int a, int b);","link":"/cpp/cpp-function-visibility/"},{"title":"How to interpret complex C++ variable declarations","text":"From int* p to int (*(*p)[])() C++ variable definition can be very complex when *, &amp; and nested brackets exist. This tutorial lists some examples from easy to advanced level to help you walk you through each of them and understand how we should interpret them in a more systematic way. Example 1Definition like below is quite easy and straightfoward. It declares a pointer p that points to an Integer.p itself exists on stack but the Integer that it points to is on heap memory. 1int* p = new int; Example 21int* v[5]; This example represents an array of 5 pointers. These 5 pointers are pointing to Integers. Here’s a breakdown: int*: Indicates that the elements of the array are pointers to integers. v[5]: Indicates that v is an array with 5 elements. Example 31int (*v)[5]; This example represents a pointer v to an array of 5 Integers. Here’s a breakdown: (*v): Indicates that v is a pointer. [5]: Indicates that the elements pointed to by v form an array of size 5. int: Indicates that the elements of the array are of type int. Example 512int p(); // p is a function that returns a int valueint (*p)(); // p is a pointer to a function. The function takes no arguments and returns a int value. Here’s a breakdown: (*p)(): Indicates that p is a pointer to a function. int: Specifies that the function returns an integer. (): Indicates that the function takes no arguments. Example 61int (*v[])(); It represents an array of pointers. Each pointer points to functions that return int values. Here’s a breakdown: v[]: Indicates that v is an array. (*v[])(): Indicates that the elements of the array are pointers to functions. int: Specifies that the functions return integers. (): Indicates that the functions take no arguments. A simple demo code 1234567891011121314151617181920// Define two functions that match the pointer typeint function1() { return 1;}int function2() { return 2;}int main() { // Declare an array of pointers to functions int (*v[])() = { &amp;function1, &amp;function2 }; // Call the functions through the array of pointers and print the results for (int i = 0; i &lt; 2; ++i) { std::cout &lt;&lt; &quot;Result at index &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; v[i]() &lt;&lt; std::endl; } return 0;} Example 71int (*(*v)[])(); It declares a pointer v to an array of pointers. Each pointer points to functions returning integers. Here’s a breakdown: (*v)[]: This part declares a pointer to an array. The *v declares a pointer, and [] indicates that this pointer is pointing to an array. int ()(): This part declares a pointer to a function. The int is the return type of the function, () indicates it’s a pointer to a function, and () indicates that the function takes no parameters. A simple demo code: 1234567891011121314151617181920212223242526int func1() { std::cout &lt;&lt; &quot;Function 1\\n&quot;; return 1;}int func2() { std::cout &lt;&lt; &quot;Function 2\\n&quot;; return 2;}int main() { int (*funcs[2])() = {func1, func2}; int (*(*v)[2])() = &amp;funcs; // Call the first function in the array int result = ((*v)[0])(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; // Call the second function in the array result = ((*v)[1])(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;} Example 8123int* p(); // function p returns a pointer to an Integerint (*p)(); // p is a pointer to a function. The function takes no arguments and returns an Integer Example 912int const a;const int a; They are equivalent and a can not be modified. Example 1012int const *p; // p is a pointer to a const intint *const p; // p is a const pointer to an int 12345678910111213141516int main() { const int a = 5; int b = 6; int c = 8; int const *p1 = &amp;a; int *const p2 = &amp;b; std::cout &lt;&lt; &quot;p1: &quot; &lt;&lt; *p1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p2: &quot; &lt;&lt; *p2 &lt;&lt; std::endl; *p1 = 1; // error p2 = &amp;c; // error return 0;} Conclusionright-to-left ruleStart reading the declaration from the innermost parentheses, go right, and then go left. When you encounter parentheses, the direction should be reversed. Once everything in the parentheses has been parsed, jump out of it. Continue till the whole declaration has been parsed. for example: 1float ( * ( *p()) [] )(); Start from the variable name ————————– p Go right, find () ———- p is a function Nothing to the right, go left and find * ———— returns a pointer Go right, find [] ————– to an array Go left, find * ————— pointers Go right, find () ———- to functions Go left, find float ———- return float So, the result is: p is a function that returns a pointer. The pointer points to an array of pointers. Each pointer points to functions that return float value. References https://www.codeproject.com/Articles/7042/How-to-interpret-complex-C-C-declarations","link":"/cpp/cpp-how-to-interpret-complex-variable-definition/"},{"title":"Initializer","text":"(), {} and std::initializer_list 1. Commons and distinctions between () and {} .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle} () {} Commons Direct initialization int x(3); int x{3}; std::string name(\"Some Name\"); std::string name{\"Some Name\"}; int* y = new int(1); int* y = new int{1}; Call constructors MyClass mc(1); MyClass mc{1}; // If no initializer list constructor exists. Distincetions Narrowing Conversions int pi(3.14); // OK -- pi == 3. int pi{3.14}; // Compile error: narrowing conversion. Uniform Initialization std::vector v(100, 1); // A vector containing 100 items: All 1s. std::vector v{100, 1}; // A vector containing 2 items: 100 and 1. 2. std:: initializer_listUsing std::initializer_list allows a class to be constructed with a list of values, providing flexibility and ease of initialization. 123456789101112131415161718template&lt;typename T&gt;struct S { S(std::initializer_list&lt;T&gt; data) : _data(data) { std::cout &lt;&lt; &quot;initializer_list contructor called\\n&quot;; } S(T a, T b, T c) { std::cout &lt;&lt; &quot;3 params contructor called\\n&quot;; }private: std::initializer_list&lt;T&gt; _data;};int main() { S&lt;int&gt; s1{1, 2, 3}; // Ok, initializer_list contructor called. S&lt;int&gt; s2(1, 2, 3); // Ok, 3 params contructor called. S&lt;int&gt; s3{1.1, 2.2, 3.3}; // Error, narrowing conversion. return 0;} {} provides a more safer way(prevent type conversion) for initialization. In situations where {} and () are equivalent, we should choose {} over (); References https://google.github.io/styleguide/cppguide.html#Variable_and_Array_Initialization https://en.cppreference.com/w/cpp/utility/initializer_list","link":"/cpp/cpp-initializer/"},{"title":"Implement a JSON Parser","text":"C++ JSON Parser. To parse a JSON file without using any third-party libraries in C++, we need to manually process the JSON structure. This involves reading the file, extracting key-value pairs, and handling various data types like strings, numbers, arrays, and objects. Below is a header-only implementation of the JSON parser. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200// jsonParser.h#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;stdexcept&gt;class JSONValue;using JSONObject = std::map&lt;std::string, JSONValue&gt;;using JSONArray = std::vector&lt;JSONValue&gt;;class JSONValue {public: enum Type { Null, Boolean, Number, String, Array, Object }; JSONValue() : type(Null) {} JSONValue(bool b) : type(Boolean), boolean(b) {} JSONValue(double n) : type(Number), number(n) {} JSONValue(const std::string&amp; s) : type(String), str(s) {} JSONValue(const JSONArray&amp; a) : type(Array), array(a) {} JSONValue(const JSONObject&amp; o) : type(Object), object(o) {} Type getType() const { return type; } bool isNull() const { return type == Null; } bool isBoolean() const { return type == Boolean; } bool isNumber() const { return type == Number; } bool isString() const { return type == String; } bool isArray() const { return type == Array; } bool isObject() const { return type == Object; } bool asBoolean() const { return boolean; } double asNumber() const { return number; } const std::string&amp; asString() const { return str; } const JSONArray&amp; asArray() const { return array; } const JSONObject&amp; asObject() const { return object; }private: Type type; bool boolean; double number; std::string str; JSONArray array; JSONObject object;};class JSONParser {public: static JSONValue parse(const std::string&amp; json) { size_t index = 0; return parseValue(json, index); }private: static JSONValue parseValue(const std::string&amp; json, size_t&amp; index) { skipWhitespace(json, index); if (index &gt;= json.length()) { throw std::runtime_error(&quot;Unexpected end of input&quot;); } char c = json[index]; if (c == '{') { return parseObject(json, index); } else if (c == '[') { return parseArray(json, index); } else if (c == '&quot;') { return parseString(json, index); } else if (c == 't' || c == 'f') { return parseBoolean(json, index); } else if (c == 'n') { return parseNull(json, index); } else if (c == '-' || (c &gt;= '0' &amp;&amp; c &lt;= '9')) { return parseNumber(json, index); } throw std::runtime_error(&quot;Unexpected character&quot;); } static JSONObject parseObject(const std::string&amp; json, size_t&amp; index) { JSONObject obj; index++; // Skip '{' while (index &lt; json.length()) { skipWhitespace(json, index); if (json[index] == '}') { index++; return obj; } std::string key = parseString(json, index).asString(); skipWhitespace(json, index); if (index &gt;= json.length() || json[index] != ':') { throw std::runtime_error(&quot;Expected ':' after key in object&quot;); } index++; // Skip ':' JSONValue value = parseValue(json, index); obj[key] = value; skipWhitespace(json, index); if (index &lt; json.length() &amp;&amp; json[index] == ',') { index++; } } throw std::runtime_error(&quot;Unterminated object&quot;); } static JSONArray parseArray(const std::string&amp; json, size_t&amp; index) { JSONArray arr; index++; // Skip '[' while (index &lt; json.length()) { skipWhitespace(json, index); if (json[index] == ']') { index++; return arr; } arr.push_back(parseValue(json, index)); skipWhitespace(json, index); if (index &lt; json.length() &amp;&amp; json[index] == ',') { index++; } } throw std::runtime_error(&quot;Unterminated array&quot;); } static JSONValue parseString(const std::string&amp; json, size_t&amp; index) { std::string result; index++; // Skip opening quote while (index &lt; json.length()) { char c = json[index++]; if (c == '&quot;') { return JSONValue(result); } else if (c == '\\\\') { if (index &gt;= json.length()) { throw std::runtime_error(&quot;Unterminated string&quot;); } c = json[index++]; switch (c) { case '&quot;': case '\\\\': case '/': result += c; break; case 'b': result += '\\b'; break; case 'f': result += '\\f'; break; case 'n': result += '\\n'; break; case 'r': result += '\\r'; break; case 't': result += '\\t'; break; default: throw std::runtime_error(&quot;Invalid escape sequence&quot;); } } else { result += c; } } throw std::runtime_error(&quot;Unterminated string&quot;); } static JSONValue parseNumber(const std::string&amp; json, size_t&amp; index) { size_t start = index; while (index &lt; json.length() &amp;&amp; (json[index] == '-' || json[index] == '+' || json[index] == '.' || (json[index] &gt;= '0' &amp;&amp; json[index] &lt;= '9') || json[index] == 'e' || json[index] == 'E')) { index++; } std::string numStr = json.substr(start, index - start); return JSONValue(std::stod(numStr)); } static JSONValue parseBoolean(const std::string&amp; json, size_t&amp; index) { if (json.substr(index, 4) == &quot;true&quot;) { index += 4; return JSONValue(true); } else if (json.substr(index, 5) == &quot;false&quot;) { index += 5; return JSONValue(false); } throw std::runtime_error(&quot;Invalid boolean value&quot;); } static JSONValue parseNull(const std::string&amp; json, size_t&amp; index) { if (json.substr(index, 4) == &quot;null&quot;) { index += 4; return JSONValue(); } throw std::runtime_error(&quot;Invalid null value&quot;); } static void skipWhitespace(const std::string&amp; json, size_t&amp; index) { while (index &lt; json.length() &amp;&amp; (json[index] == ' ' || json[index] == '\\t' || json[index] == '\\n' || json[index] == '\\r')) { index++; } }}; To test it, we prepare a simple JSON file as: 123456789{ &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 30, &quot;hobbies&quot;: [&quot;reading&quot;, &quot;cycling&quot;, &quot;photography&quot;], &quot;address&quot;: { &quot;street&quot;: &quot;123 Main St&quot;, &quot;city&quot;: &quot;Anytown&quot; }} We have a simple test script to read the JSON content. 1234567891011121314151617181920212223242526272829303132333435// test.cpp#include &quot;jsonParser.h&quot;int main() { try { // Read JSON file std::ifstream file(&quot;data.json&quot;); std::string content((std::istreambuf_iterator&lt;char&gt;(file)), std::istreambuf_iterator&lt;char&gt;()); // Parse JSON JSONValue data = JSONParser::parse(content); // Access and print some data const JSONObject&amp; obj = data.asObject(); std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; obj.at(&quot;name&quot;).asString() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; obj.at(&quot;age&quot;).asNumber() &lt;&lt; std::endl; // Iterate through an array std::cout &lt;&lt; &quot;Hobbies:&quot; &lt;&lt; std::endl; for (const auto&amp; hobby : obj.at(&quot;hobbies&quot;).asArray()) { std::cout &lt;&lt; &quot;- &quot; &lt;&lt; hobby.asString() &lt;&lt; std::endl; } // Access nested objects const JSONObject&amp; address = obj.at(&quot;address&quot;).asObject(); std::cout &lt;&lt; &quot;Address:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Street: &quot; &lt;&lt; address.at(&quot;street&quot;).asString() &lt;&lt; std::endl; std::cout &lt;&lt; &quot; City: &quot; &lt;&lt; address.at(&quot;city&quot;).asString() &lt;&lt; std::endl; } catch (const std::exception&amp; e) { std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; } return 0;} To compile and run. 123456789101112g++ test.cpp -o test -std=c++11./testName: John DoeAge: 30Hobbies:- reading- cycling- photographyAddress: Street: 123 Main St City: Anytown","link":"/cpp/cpp-json-parser/"},{"title":"Vulkan Visualizations","text":"A collection of diagrams to help understand various Vulkan topics. 1. SwapChain &amp; FrameBuffer 2. RenderPass 3. Graphics Pipeline 4. Descriptor 5. Pipeline Layout 6. Pipeline Barrier 7. Data Transfer Adding more","link":"/CGV/cgv-vulkan-visualization/"},{"title":"lvalue, rvalue and their references","text":"Understanding lvalue, rvalue, their references and const references. 1. Introduction An lvalue refers to an object that occupies some identifiable location in memory (it has an address). Typically, lvalues are variables or objects that you can assign values to. It represents an object that persists beyond a single expression.(Persistent Memory Location, Identifiable Address, Modifiable) An rvalue on the other hand, is a temporary object that does not persist beyond the expression that uses it. Rvalues typically do not have a persistent memory location.(Temporary Storage, No Identifiable Address, Immutable in Context) An lvalue reference is a reference that binds to an lvalue. Marked as &amp;.123const int y{5};int&amp; invalidRef{y}; // invalid: can't bind to a non-modifiable lvalueint&amp; invalidRef2{0}; // invalid: can't bind to an rvalue An rvalue reference is a reference that binds to an rvalue. Marked as &amp;&amp;. A const lvalue reference is a reference that can bind to both lvalues and rvalues, providing an efficient way to access an object without modifying it.12345const int y{5};int x{3};const int&amp; ref1{y}; // ok, bind to a const lvalue.const int&amp; ref2{x}; // ok, bind to a modifiable lvalue.const int&amp; ref3{3}; // ok, bind to a rvalue. 2. More2.1 Const lvalue refernce extends the lifetime of temporary objects12345int main() { const int&amp; ref{5}; // The temporary object 5 has its lifetime extended to the end of the main function. std::cout &lt;&lt; ref &lt;&lt; '\\n'; // Therefore, we can safely use it here return 0;} // Both ref and the temporary object release here 2.2 Const lvalue references accept both lvalue and rvalue12345678910111213141516class LargeObject {public: std::string data; LargeObject(const std::string&amp; str) : data(str) {}};void processObject(const LargeObject&amp; obj) { std::cout &lt;&lt; &quot;Processing: &quot; &lt;&lt; obj.data &lt;&lt; std::endl;}int main() { LargeObject obj(&quot;Large data&quot;); processObject(obj); // Passes an lvalue processObject(LargeObject(&quot;Temporary large data&quot;)); // Passes an rvalue return 0;} 2.3 Passing lvalues to rvalue referenceAn rvalue reference is designed to bind to temporary objects (rvalues) that are about to be destroyed, allowing the program to safely “move” resources from those objects. However, there are situations where you might want to pass an lvalue to a function that takes an rvalue reference. This is where the std::move utility comes into play. 12345678910111213// Function that takes an rvalue referencevoid processVector(std::vector&lt;int&gt;&amp;&amp; vec) { std::cout &lt;&lt; &quot;Processing vector of size: &quot; &lt;&lt; vec.size() &lt;&lt; std::endl;}int main() { std::vector&lt;int&gt; myVector = {1, 2, 3, 4, 5}; // Pass lvalue to function expecting rvalue reference processVector(std::move(myVector)); // myVector can still be used, but its content is unspecified std::cout &lt;&lt; &quot;After move, myVector size: &quot; &lt;&lt; myVector.size() &lt;&lt; std::endl; return 0;} 2.4 Function overloading priorityBased on what we’ve learned, both rvalue references and const lvalue references can accept passed rvalues. However, if we have an overloaded function with these two as arguments and we pass an rvalue, which one will the compiler call? The rule for overload resolution is: exact match &gt; rvalue reference overload &gt; const lvalue reference overload. 123456789101112void f(const int&amp; x) { std::cout &lt;&lt; &quot;const lvalue reference\\n&quot;;}void f(int&amp;&amp; x) { std::cout &lt;&lt; &quot;rvalue reference\\n&quot;;}int main() { f(3); return 0;} 2.5 Constexpr lvalue referencesSince constexpr will evaluate expressions during compile time, when it applies to lvalue references, it can only bind to either global or static objects. This usage is pretty rare and has its limitations. We will not dive deep into this topic. 1234567891011121314int g_x{5};int main(){ [[maybe_unused]] constexpr int&amp; ref1 {g_x}; // ok, can bind to global static int s_x {6}; [[maybe_unused]] constexpr int&amp; ref2 {s_x}; // ok, can bind to static local int x { 6 }; [[maybe_unused]] constexpr int&amp; ref3 {x}; // compile error: can't bind to non-static object return 0;} 3. Universal ReferencesUniversal references in C++ refer to a special type of reference that can bind to both lvalues and rvalues. This concept was introduced with C++11 and is commonly associated with template programming. Sometimes, it is also called forwarding reference. Universal referenes are declared as T&amp;&amp; in templates. 12template&lt;typename T&gt;void f(T&amp;&amp; param) The actual type of param is determined by how function f is called. param is an lvalue reference if f receives an lvalue. param is an rvalue reference if f receives an rvalue. Universal references are often used to implement perfect forwarding in order to preserve the lvalue\\rvalue nature of the arguments. 1234template&lt;typename T&gt;void f(T&amp;&amp; param) { g(std::forward&lt;T&gt;(param));} In the following code, x in the context of f(T&amp;&amp; x) is an lvalue. This might be a little bit tricky at first sight. But whether x is an lvalue or rvalue really depends on the context we are referring to. In the context of the caller that calls f, for sure x would be an rvalue reference. If we directly call g(x) inside f, no matter we pass an lvalue or an rvalue to f, eventually, void g(int&amp; x) will be called since x inside f is always an lvalue. That’s why we need perfect forwarding here to make sure g gets exactly what passed to f. 1234567891011121314151617181920212223// Overload g for lvalue referencesvoid g(int&amp; x) { std::cout &lt;&lt; &quot;g received an lvalue reference\\n&quot;;}// Overload g for rvalue referencesvoid g(int&amp;&amp; x) { std::cout &lt;&lt; &quot;g received an rvalue reference\\n&quot;;}template&lt;typename T&gt;void f(T&amp;&amp; x) { // Forward the argument to g, preserving its value category // g(std::forward&lt;T&gt;(x)); g(x);}int main() { int a = 1; f(a); f(1); return 0;} References https://www.fluentcpp.com/2018/02/06/understanding-lvalues-rvalues-and-their-references/","link":"/cpp/cpp-lvalue-rvalue/"},{"title":"Memory Layout in C&#x2F;C++","text":"Memory layout of a process. 1. Process vs ProgramWhen we talk about memory layout, we are referring to a process, not a program. So, what is the difference between these two? Term Description Program A static entity — a file on disk (ELF, PE, Mach-O, etc.). It contains code, data, metadata, but no allocated memory yet. It contains all the needed information and data to describe how to construct a process at runtime. Process A dynamic instance of a program that is loaded into memory and being executed by the OS. It has an address space, threads, open file descriptors, etc. The memory layout essentially describes how the OS maps a program’s components(code, data, etc.) into a process’s virtual address space. The following diagram shows the full lifecycle of how a program creates a process with concrete memory layout. Step Description Step1 Program files are stored as bytes, nothing is loaded into the memory yet. Step2 The OS creates virtual address space and maps the executable to different segments, as well as dynamic linker and shared libraries. Step3 Different segments are loaded into memory. Step4 main() is used as execution entry point. Stack grows downwards while Heap grows upwards. Step5 The process exits by calling either eixt() or returning from main(). Allocated memory is released. 2. Memory Layout Let’s discuss each segment from bottom to top. Text/Code Segment This segments contains the compiled machine instructions which are loaded from the .text section of the ELF/PE/Mach-O file. Text/Code segment has read-only permission to prevent accidental modification. If we try to write to text/code segment, you will get a Segmentation Fault. Initialized Data Segment This segments holds all external, global, static and const variables whose values are explicitly initialized at the time when they are defined. We can further classify these variable into two categories: read-write and read-only. Since const variables can not be changed, they fall under read-only section. The rest types belong to read-write section, which means they can be modified during the execution. For example, all the variables will be stored in this segment. 123456789int a = 1;char* b = &quot;Hello World&quot;;const int c = 2;int main() { static int d = 10; // ... return 0;} Uninitialized Data Segment (BSS) An uninitialized data segment is also known as bss (b​lock started by symbol). It stores global and static variables that are not initialized. Data in BSS will be set to be 0(or nullptr for pointer types) by default. Because the values of these variables can be modified, so this is a read-write area. Heap Heap is used for dynamic memory allocation such as malloc(), new, etc. It grows and shrinks in the opposite direction of Stack. This is a read-write area. Stack Stack stores a variety of data types including stack frame, local variables, arguments and return values. A stack frame is a block of memory on the stack that is allocated for each function call. Each time you call a function, a new stack frame is pushed onto the stack. Stack grows downwards and is a read-write area. Stack has a fixed maximum size, exceeding its max capacity will lead to Stack Overflow. The maximum stack size is usually configurable. Here is a summary of default stack size on different OS. Linux (x86_64) 8 MBLinux (arm) 256 KB ~ 1 MBmacOS 8 MBWindows 1 MBPOSIX Thread (Linux pthread_create) 8 MB We can check the default Stack size on Linux/Mac using command: 12ulimit -s # show stack size in KBulimit -s 16384 # set stack size to 16 MB (in KB) References https://stackoverflow.com/questions/62556670/why-using-memory-layout-for-running-a-c-program https://www.scaler.com/topics/c/memory-layout-in-c/","link":"/cpp/cpp-memory-layout-in-process/"},{"title":"Most Vexing Parse","text":"The term “most vexing parse” was first used by Scott Meyers in his 2001 book Effective STL. 1. IntroductionThe “most vexing parse” is a famous ambiguity in C++ syntax. It occurs when the compiler interprets a statement as function declaration instead of an object construction. 12345678910#include &lt;iostream&gt;struct MyClass { MyClass() { std::cout &lt;&lt; &quot;Constructor called!\\n&quot;; }};int main() { MyClass obj(); // This looks like it creates an object, but it is not. return 0;} Some compilers provide warnings that can help catch potential most vexing parse issues using -Wvexing-parse. The above code will generate compile warnings if this option is enabled. 12345&lt;source&gt;:8:16: warning: empty parentheses interpreted as a function declaration [-Wvexing-parse] MyClass obj(); ^~&lt;source&gt;:8:16: note: remove parentheses to declare a variable MyClass obj(); C++ grammar allows declarations to look very similar to expressions. When the compiler encounters MyClass obj();, it prioritizes interpreting it as a declaration (because declarations are more fundamental in the language’s parsing rules) rather than an expression creating an object. Another common example when using std::vector 12std::vector&lt;int&gt; v(10, 20); // Correct: Creates a vector with 10 elements of value 20std::vector&lt;int&gt; v2(); // Most Vexing Parse! Declares a function v2 returning a vector&lt;int&gt; 2. How to fix?1234MyClass obj{}; // Use uniform initialization with braces (C++11 and later):MyClass obj;MyClass obj = MyClass();MyClass* obj = new MyClass(); References https://en.wikipedia.org/wiki/Most_vexing_parse","link":"/cpp/cpp-most-vexing-parse/"},{"title":"nodiscard in C++","text":"Introduced in C++17 1. IntroductionCheckout how the declaration of std::vector&lt;T, Allocator&gt;::empty changes over different C++ versions. Why is it important and how should we use it? [[nodiscard]] is a new attribute introduced in C++17. It can be appended to either a function signiture or type declaration to specify that the return value is important and should not be discarding. The compiler will shows warnings if we ignore the return value. 2. FunctionUse nodiscard as function signiture. 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;coroutine&gt;struct Vector { int* data; int size; Vector(int n) : size(n) { data = new int[n]; } ~Vector() { delete[] data; data = nullptr; } [[nodiscard(&quot;you might want to call clear()&quot;)]] bool empty() const { return size == 0 ? true : false; } void clear() { delete[] data; data = new int[0]; size = 0; }};int main() { Vector vec(5); vec.empty();} Console message: 1234567&lt;source&gt;: In function 'int main()':&lt;source&gt;:28:14: warning: ignoring return value of 'bool Vector::empty() const', declared with attribute 'nodiscard': 'you might want to call clear()' [-Wunused-result] 28 | vec.empty(); | ~~~~~~~~~^~&lt;source&gt;:15:58: note: declared here 15 | [[nodiscard(&quot;you might want to call clear()&quot;)]] bool empty() const { | This is a common misuse of the empty() method. The purpose might seem to empty the vector’s contents, but the correct method to use is clear(). In this instance, the [[nodiscard]] attribute warns the compiler that the return value from empty() should not be ignored, highlighting its importance. From C++20 onwards, it’s possible to include a custom message within the [[nodiscard]] attribute, which can help explicitly point out this kind of issue in the code. 3. Type declaration12345678910111213#include &lt;iostream&gt;enum class [[nodiscard(&quot;This is an error type, you might want to capture the return value&quot;)]] ErrorType { Error, Warning, Ok};ErrorType doSomethingOk();int main() { doSomethingOk();} Console output: 12345678910&lt;source&gt;: In function 'int main()':&lt;source&gt;:12:18: warning: ignoring returned value of type 'ErrorType', declared with attribute 'nodiscard': 'This is an error type, you might want to capture the return value' [-Wunused-result] 12 | doSomethingOk(); | ~~~~~~~~~~~~~^~&lt;source&gt;:9:11: note: in call to 'ErrorType doSomethingOk()', declared here 9 | ErrorType doSomethingOk(); | ^~~~~~~~~~~~~&lt;source&gt;:3:95: note: 'ErrorType' declared here 3 | enum class [[nodiscard(&quot;This is an error type, you might want to capture the return value&quot;)]] ErrorType { | It is important to capture the type of error and execute appropriate actions based on the returned value. Doing so can help avert possible bugs in the code. 4. ConstructorSometimes, instead of applying [[nodiscard]] to an entire type declaration, as in the case above with an ErrorType that indicates the results of execution, we might prefer to specifically apply [[nodiscard]] to constructors. 123std::unique_lock&lt;std::mutex&gt; lock{mu};int* p = new int;std::unique_ptr&lt;int&gt; uniPtr{p}; In this scenario, constructors for both unique_lock and unique_ptr are invoked, returning objects that are then used for further operations and resource management. Consider a situation where we create our own class or struct that allocates resources within its constructor. If, in the main function, we call this constructor without assigning the returned object to a variable, the allocated resources would become inaccessible, leading to memory leaks and potential issues with resource management. Let’s reuse the example from section 1. 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;coroutine&gt;struct Vector { int* data; int size; [[nodiscard(&quot;You are trying to allocate resouces, make sure to assign to an object&quot;)]] Vector(int n) : size(n) { data = new int[n]; } ~Vector() { delete[] data; data = nullptr; }};int main() { Vector{5};} Console output: 1234567&lt;source&gt;: In function 'int main()':&lt;source&gt;:18:14: warning: ignoring return value of 'Vector::Vector(int)', declared with attribute 'nodiscard': 'You are trying to allocate resouces, make sure to assign to an object' [-Wunused-result] 18 | Vector{5}; | ^&lt;source&gt;:8:92: note: declared here 8 | [[nodiscard(&quot;You are trying to allocate resouces, make sure to assign to an object&quot;)]] Vector(int n) : size(n) { | Start using [[nodiscard]], you can make your code more robust. References https://en.cppreference.com/w/cpp/language/attributes/nodiscard","link":"/cpp/cpp-nodiscard/"},{"title":"C++ Null Pointer Function Calls","text":"Null pointers don’t mean nothing at all. 1234567891011121314151617181920212223242526272829class A {public: void func1() { std::cout &lt;&lt; &quot;func1()\\n&quot;; } virtual void func2() { std::cout &lt;&lt; &quot;func2 in A\\n&quot;; }};class B : public A {public: virtual void func2() override { std::cout &lt;&lt; &quot;func2 in B\\n&quot;; }};int main() { B* ptr = nullptr; ptr-&gt;func1(); // ptr-&gt;func2(); crash return 0;}/*output:func1()*/ func1 can be called and executed even when the pointer is null because: Non-virtual function call: func1() is a non-virtual function. In C++, non-virtual function calls are resolved at compile-time based on the static type of the pointer or reference. Static binding: Because func1() is non-virtual, the compiler uses static binding to determine which function to call. It looks at the declared type of the pointer (B*) and finds the func1() method in the base class A. No object access: The implementation of func1() doesn’t access any member variables or call any other member functions that would require a valid object. It only prints a string to the standard output. Function call mechanism: When calling a non-virtual function through a pointer, the compiler essentially translates ptr-&gt;func1() to something like A::func1(ptr). The this pointer is passed as a hidden argument, but it’s not actually used in the function. Undefined behavior: It’s important to note that while this code may appear to work, it’s actually undefined behavior. The C++ standard doesn’t guarantee that this will work on all systems or with all compilers. It just happens to work in many common implementations. As previously mentioned, func1() doesn’t interact with any other variables or functions, so it’s safe to call it using a null pointer. However, if we modify it to rely on other variables or functions, the behavior would change drastically. 12345678910111213141516171819202122232425262728293031class A {public: int x; void func1() { std::cout &lt;&lt; &quot;func1()\\n&quot;; std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; std::endl; // Accessing member variable helperFunc(); // Calling another member function } void helperFunc() { std::cout &lt;&lt; &quot;Helper function called\\n&quot;; } virtual void func2() { std::cout &lt;&lt; &quot;func2 in A\\n&quot;; }};class B : public A { virtual void func2() override { std::cout &lt;&lt; &quot;func2 in B\\n&quot;; }};int main() { B* ptr = nullptr; ptr-&gt;func1(); // error return 0;} Undefined Behavior: Attempting to access x or call helperFunc() through a null pointer is undefined behavior. The program is likely to crash or produce unexpected results. Segmentation Fault: On most systems, this will result in a segmentation fault or access violation when trying to read the value of x or when trying to call helperFunc(). No “this” pointer: Since ptr is null, there’s no valid “this” pointer. Attempts to access member variables or call other member functions effectively try to dereference a null pointer.","link":"/cpp/cpp-null-ptr-calls/"},{"title":"Google C++ Style Quick Reference","text":"A concise summary of essential Google C++ style guidelines to elevate your code quality. https://google.github.io/styleguide/cppguide.html 1. Naming Conventions Type Convention Example Namespaces snake_case namespace image_processing Class/Struct/Enum/Type Names CamelCase class AudioEncoder Public Functions CamelCase void ComputeValue() Private/Protected Functions CamelCase (same as public) void UpdateInternalState() Local Variables snake_case int local_count; Public Member Variables (if used) snake_case int frame_count; Private/Protected Member Variables snake_case_ (with trailing underscore) int buffer_size_; Static Member Variables snake_case_ (with trailing underscore) static int instance_count_; Constants (constexpr, const) kCamelCase const int kMaxWidth = 800; Macros ALL_CAPS_WITH_UNDERSCORES #define BUFFER_SIZE 256 Enumerators (enum values) kCamelCase enum Color { kRed, kGreen, kBlue }; Template Parameters CamelCase template &lt;typename InputIterator&gt; Files snake_case.h / snake_case.cc audio_encoder.h, audio_encoder.cc 2. Formatting Only use spaces(no tab). Use 2 spaces at a time. Maximum of 80 characters for each line. Pointers and references: int* p and int&amp; r. Formatting could be easily resolved using clang-format. Create a .clang-format file in your project’s root directory. 123BasedOnStyle: GoogleIndentWidth: 2ColumnLimit: 80 And run the following command line to apply the format. 1clang-format -i file1.cpp 3. Include Files Orders: Related header -&gt; C system headers -&gt; C++ standard library headers -&gt; other libraries’ headers -&gt; your project’s headers. All project’s header files need to be listed as descendants of the project’s source directory. No . or ... 12345678910111213#include &quot;example_encoder.h&quot; // Related header#include &lt;sys/types.h&gt; // C system headers#include &lt;unistd.h&gt;#include &lt;algorithm&gt; // C++ standard library headers#include &lt;vector&gt;#include &quot;third_party/libx/libx.h&quot; // Other libraries' headers#include &quot;third_party/liby/liby.h&quot;#include &quot;media/base/audio_frame.h&quot; // Your project's headers#include &quot;media/base/buffer_pool.h&quot; 4. Classes and Structs Use a struct only for passive objects that carry data; everything else is a class. Explicitly declare constructors as explicit if they take a single argument. 5. Const CorrectnessMark member functions as const if they do not modify object state. 6. Lambda ExpressionsPrefer explicit capture over [=] or [&amp;] to avoid accidental capture. 7. Defining Functions in HeadersFunctions defined at the point of declaration are inline by default. Based on the guide, there are PROs and CONs doing that. The rule is: the definition has 10 lines or fewer. Adding More","link":"/cpp/cpp-google-cpp-style-guideline/"},{"title":"Observer Design Pattern","text":"Design pattern. 1. IntroductionThe Observer design pattern is a behavioral pattern that defines a one-to-many relationship between objects. When one object (the subject) changes state, all its dependents (observers) are notified and updated automatically. 2. ExampleA classic example of the Observer design pattern is a Publisher-Subscriber system. The Publisher is a single entity responsible for sending messages and can add or remove multiple subscribers. Multiple subscribers listen for message notifications from the publisher. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class Observer;// Subject(abstract)class Subject {public: virtual void attach(Observer* o) = 0; virtual void detach(Observer* o) = 0; virtual void notify(const std::string&amp; message) const = 0;};// Observer(abstract)class Observer {public: virtual void update(const std::string&amp; message) = 0; virtual std::string getSubscriberName() const = 0;};// Concrete subjectclass Publisher : public Subject {public: void attach(Observer* o) override { std::cout &lt;&lt; &quot;User &quot; &lt;&lt; o-&gt;getSubscriberName() &lt;&lt; &quot; subscribed\\n&quot;; _obs.push_back(o); } void detach(Observer* o) override { std::cout &lt;&lt; &quot;User &quot; &lt;&lt; o-&gt;getSubscriberName() &lt;&lt; &quot; unsubscribed\\n&quot;; _obs.erase(std::remove(_obs.begin(), _obs.end(), o), _obs.end()); } void notify(const std::string&amp; message) const override { for (auto ob : _obs) { ob-&gt;update(message); } }private: std::vector&lt;Observer*&gt; _obs;};// Concrete oberverclass Subscriber : public Observer {public: Subscriber(const std::string&amp; name) : _name(name) {} void update(const std::string&amp; message) { std::cout &lt;&lt; &quot;Subscriber &quot; &lt;&lt; _name &lt;&lt; &quot; received message: &quot; &lt;&lt; message &lt;&lt; '\\n'; } std::string getSubscriberName() const { return _name; }private: std::string _name;};int main() { Subscriber s1(&quot;A&quot;); Subscriber s2(&quot;B&quot;); Subscriber s3(&quot;C&quot;); Publisher p; p.attach(&amp;s1); p.attach(&amp;s2); p.attach(&amp;s3); p.notify(&quot;Morning news.&quot;); p.notify(&quot;Noon news.&quot;); p.notify(&quot;Evening news.&quot;); p.detach(&amp;s2); p.notify(&quot;Late night news&quot;); return 0;} 123456789101112131415User A subscribedUser B subscribedUser C subscribedSubscriber A received message: Morning news.Subscriber B received message: Morning news.Subscriber C received message: Morning news.Subscriber A received message: Noon news.Subscriber B received message: Noon news.Subscriber C received message: Noon news.Subscriber A received message: Evening news.Subscriber B received message: Evening news.Subscriber C received message: Evening news.User B unsubscribedSubscriber A received message: Late night newsSubscriber C received message: Late night news","link":"/cpp/cpp-observer/"},{"title":"Keep Track of Commit id in Code Development","text":"Obtaining the current Git commit ID in C++ code serves several purposes, mainly for debugging, version tracking, and reproducibility. 1. ImportanceHere are some common reasons. 1.1 Version Identification Embedding the commit ID allows you to track exactly which version of the code was used in a given build. Useful in applications where users report issues, so developers can quickly identify the codebase version. 1.2 Reproducibility and Debugging When debugging issues, knowing the exact commit helps developers check out the same version and reproduce bugs. If a crash report or log includes the commit ID, developers can match it to the corresponding source code. 1.3 CI/CD Including the commit ID in the build helps with tracking which commit was deployed. This is essential in automated deployment pipelines. 2. The Most Common PracticeWe can embed the commit ID into the C++ program at compile time by using git rev-parse --short HEAD. We can achieve that by adding the following to our CMakeLists.txt to extract the Git commit ID and define it as a macro. 12345678910# Get the current Git commit IDexecute_process( COMMAND git rev-parse --short HEAD WORKING_DIRECTORY ${CMAKE_SOURCE_DIR} OUTPUT_VARIABLE GIT_COMMIT_ID OUTPUT_STRIP_TRAILING_WHITESPACE)# Define the commit ID as a preprocessor macroadd_definitions(-DGIT_COMMIT_ID=&quot;${GIT_COMMIT_ID}&quot;) And then we can use the macro in C++ code. 12345678910#include &lt;iostream&gt;#ifndef GIT_COMMIT_ID#define GIT_COMMIT_ID &quot;unknown&quot;#endifint main() { std::cout &lt;&lt; &quot;Current Git Commit ID: &quot; &lt;&lt; GIT_COMMIT_ID &lt;&lt; std::endl; return 0;} Here is the complete CMakeLists.txt file. 1234567891011121314151617181920212223242526272829# Minimum CMake version requiredcmake_minimum_required(VERSION 3.10)# Project nameproject(GitCommitExample VERSION 1.0)# Set C++ standardset(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# Get the current Git commit IDexecute_process( COMMAND git rev-parse --short HEAD WORKING_DIRECTORY ${CMAKE_SOURCE_DIR} OUTPUT_VARIABLE GIT_COMMIT_ID OUTPUT_STRIP_TRAILING_WHITESPACE RESULT_VARIABLE GIT_RESULT)# Check if the git command succeeded, otherwise set a fallback valueif(NOT GIT_RESULT EQUAL 0) set(GIT_COMMIT_ID &quot;unknown&quot;)endif()# Define the commit ID as a preprocessor macroadd_definitions(-DGIT_COMMIT_ID=&quot;${GIT_COMMIT_ID}&quot;)# Add the executableadd_executable(main main.cpp)","link":"/cpp/cpp-obtain-commit-id/"},{"title":"Parameter Pack in C++","text":"Template parameter pack and function parameter pack 1. IntroductionA parameter pack can pack multiple parameters into a single parameter by placing an ellipsis to the left of the parameter name. The basic systax of parameter pack can look like this. 12template&lt;class... Types&gt;struct Tuple {}; Based on the context of parameter pack is used, we have two types of parameter pack, namely, template parameter pack and function parameter pack. 2. Template Parameter PackBased on the type declared in template parameter pack. There are 3 kinds of template parameter pack. Type parameter pack Non-type parameter pack Template template parameter pack We will only talk about the first two types. 2.1 Type parameter packThis kind of parameter pack captures a sequence of types passed as template arguments. It allows you to work with a variable number(zero or more) of types within a template. You can then expand this pack to generate type-specific code or to pass the types to other templates or functions. 1234567template&lt;class... Types&gt;struct Tuple {}; Tuple&lt;&gt; t0; // Types contains no argumentsTuple&lt;int&gt; t1; // Types contains one argument: intTuple&lt;int, float&gt; t2; // Types contains two arguments: int and floatTuple&lt;0&gt; t3; // error: 0 is not a type 2.2 Non-type parameter packThis type of parameter pack captures a sequence of non-type template arguments. Non-type parameters can be integral types, pointers, references, or enums. They are used when you need to work with values known at compile time. 1234567template&lt;int... Values&gt;struct Tuple {}; Tuple&lt;&gt; t0; // Values contains no argumentsTuple&lt;1&gt; t1; // Values contains one argument: intTuple&lt;1, 2&gt; t2; // Values contains two arguments: int and intTuple&lt;1, 2.0&gt; t3; // error: 2.0 is a double value 2.3 Position in parameter listIn a primary class template, the template parameter pack must be at the end of the parameter list. 12template&lt;typename... U, typename T&gt;struct InvalidTuple {}; 123&lt;source&gt;:9:10: error: parameter pack 'U' must be at the end of the template parameter list 9 | template&lt;typename... U, typename T&gt; | ^~~~~~~~ 3. Function Parameter PackA function parameter pack is a function parameter that represents any number of function parameters. To use function parameter pack, we often use a template parameter pack as a function parameter. The template parameter pack then is expanded by the function parameter pack. 123456template&lt;class... Types&gt;void f(Types... args);f(); // OK: args contains no argumentsf(1); // OK: args contains one argument: intf(2, 1.0); // OK: args contains two arguments: int and double 3.1 trailing function parameter pack and non-trailing function parameter packIf a function parameter pack is the last function parameter of a function template, then it is a trailing function parameter pack. Otherwise, it is a non-trailing function parameter pack. Rule for non-trailing function parameter pack instantiation A non-trailing function parameter pack can be deduced only from the explicitly specified arguments when the function template is called. If the function template is called without explicit arguments, the non-trailing function parameter pack must be empty. 1234567891011121314template&lt;class...A, class...B&gt; void func(A...arg1,int sz1, int sz2, B...arg2) { std::cout &lt;&lt; sz1 &lt;&lt; &quot; &quot; &lt;&lt; sz2 &lt;&lt; '\\n';}int main(void){ //A:(int, int, int), B:(int, int, int, int, int) func&lt;int,int,int&gt;(1,2,3,4,5,1,2,3,4,5); //A: empty, B:(int, int, int, int, int) func(0,5,1,2,3,4,5); return 0;} 4. Parameter pack expansion4.1 Function argument list123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;class... Us&gt;void f(Us... pargs) { ((std::cout &lt;&lt; pargs &lt;&lt; std::endl), ...); // Parameter pack expansion std::cout &lt;&lt; &quot;--------------\\n&quot;;}template&lt;class... Ws&gt;int h(Ws... args) { return (args + ...);} template&lt;class... Ts&gt;void g1(Ts... args) { f(&amp;args...); // “&amp;args...” is a pack expansion // “&amp;args” is its pattern // expand to f(&amp;E1, &amp;E2, &amp;E3)}template&lt;class... Ts&gt;void g2(Ts... args) { f(args...); // expand to f(E1, E2, E3)}template&lt;class... Ts&gt;void g3(Ts... args) { f(5, ++args...); // expand to f(n, ++E1, ++E2, ++E3)}template&lt;class... Ts&gt;void g4(Ts... args) { f(h(args...) + args...); /* expand to f(h(E1, E2, E3) + E1, h(E1, E2, E3) + E2, h(E1, E2, E3) + E3, */}int main() { g1(1, 0.2, &quot;a&quot;); // Ts... args expand to int E1, double E2, const char* E3 // &amp;args... expands to &amp;E1, &amp;E2, &amp;E3 // Us... pargs expand to int* E1, double* E2, const char** E3 g2(1, 0.2, &quot;a&quot;); g3(1, 0.2, 5); g4(1, 2, 3);} 12345678910111213141516170x7ffd02d21a0c0x7ffd02d21a100x7ffd02d21a18--------------10.2a--------------521.26--------------789-------------- 4.2 Parenthesized initializersUsed as a class initializer. 123456789template&lt;typename... T&gt;struct Tuple { Tuple(T... args) : elements(args...) {} std::tuple&lt;T...&gt; elements;};int main() { Tuple t{1, 2, &quot;a&quot;};} 4.3 sizeof…sizeof... is an operator in C++ that returns the number of elements in a parameter pack. 12345678910template&lt;typename... Args&gt;void printNumArgs(Args... args) { std::cout &lt;&lt; &quot;Number of arguments: &quot; &lt;&lt; sizeof...(args) &lt;&lt; std::endl;}int main() { printNumArgs(1, 2, 3); // Outputs: Number of arguments: 3 printNumArgs(&quot;hello&quot;, 42, 3.14, 'a'); // Outputs: Number of arguments: 4 printNumArgs(); } 4.4 Braced-enclosed initializersUsed in braced-init-list. 1234567891011template&lt;typename... Ts&gt;void func(Ts... args){ const int size = sizeof...(args) + 2; int res[size] = {1, args..., 2};}int main() { func(1, 2, 3);} 4.5 Function parameter listAn ellipsis appears in a parameter declaration, even if the parameter name is being ignored, it is still a valid parameter pack and can be expanded. 1234567template&lt;typename... Ts&gt;void f(Ts...) {}int main() { f('a', 1); // Ts... expands to void f(char, int) f(0.1); // Ts... expands to void f(double)} 123456789101112131415template&lt;typename T, class... Us&gt;void h(T value, Us... args) { std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; value &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;args: \\n&quot;; ((std::cout &lt;&lt; args &lt;&lt; std::endl), ...);}template&lt;class... Ts&gt;void g5(Ts... args) { // g5 forward parameter pack &quot;args&quot; to h h(args...); // compiler deduces &quot;T value&quot; from the parameter pack}int main() { g5(1, 2, 3);} 4.6 Template parameter list12345678910111213141516171819template&lt;typename... T&gt;struct ValueHolder { template&lt;T... Values&gt; // expand to non-type template parameter pack struct Apply { Apply() { ((std::cout &lt;&lt; Values &lt;&lt; std::endl), ...); } };};int main() { // Initializing an instance of Apply with values 1, 2, 3 ValueHolder&lt;int, int, int&gt;::Apply&lt;1, 2, 3&gt; instance1; // Initializing an instance of Apply with values 'a', 'b', 'c' ValueHolder&lt;char, char, char&gt;::Apply&lt;'a', 'b', 'c'&gt; instance2; return 0;} 4.7 Lambda captures12345678910111213141516template&lt;class... T&gt;void g(T... args) { ((std::cout &lt;&lt; args &lt;&lt; std::endl), ...);}template&lt;class... Args&gt;void f(Args... args) { auto lm = [&amp;, args...] { return g(args...); }; lm();}int main() { f(1, 0.2, 'a');} 4.8 MoreMore usages can be found at cppreference.com 5. Variadic macro5.1 __VA_ARGS__ __VA_ARGS__ is a predefined macro in C++. It represents a variable number of arguments passed to a variadic macro. It is used within a macro definition to refer to the arguments passed to the macro. It allows you to create macros that can accept a variable number of arguments. 1234567891011#define SUM(...) sum(__VA_ARGS__)template&lt;class... Args&gt;int sum(Args... args) { return (args + ...);}int main() { std::cout &lt;&lt; &quot;Total: &quot; &lt;&lt; SUM(1, 2, 3) &lt;&lt; &quot;\\n&quot;; return 0;} The following example is a misuse case of __VA_ARGS__. The reason is that the stream insertion operator &lt;&lt; expects its right-hand side to be a single expression, not a list of potentially different types of expressions. As a result, this can lead to compilation errors or unexpected behavior. 123456#define DEBUG_PRINT(...) std::cout &lt;&lt; &quot;Debug: &quot; &lt;&lt; __VA_ARGS__ &lt;&lt; std::endl;int main() { DEBUG_PRINT(&quot;Hello, world!&quot;); // ok DEBUG_PRINT(&quot;Hello, world!&quot;, 1); // error} 5.2 #__VA_ARGS__#__VA_ARGS__ is a stringizing operator in C++.When used within a macro definition, #__VA_ARGS__ converts the arguments passed to the macro into a string literal.It is typically used to stringify the arguments for debugging or logging purposes. 1234567#define DEBUG_PRINT(...) std::cout &lt;&lt; &quot;Debug: &quot; &lt;&lt; #__VA_ARGS__ &lt;&lt; std::endl;int main() { DEBUG_PRINT(&quot;Hello, world!&quot;); DEBUG_PRINT(42); DEBUG_PRINT(3.14, &quot;pi&quot;);} 6. Practice1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;// Primary template for tupletemplate&lt;typename... Ts&gt;struct Tuple { Tuple() { std::cout &lt;&lt; &quot;Base Case\\n&quot;; }};// Specialization for non-empty tupletemplate&lt;typename T, typename... Ts&gt;struct Tuple&lt;T, Ts...&gt; { T value; Tuple&lt;Ts...&gt; rest; // Constructor to initialize value and rest Tuple(T t, Ts... ts) : value(t), rest(ts...) {} // Get element by index template&lt;size_t index&gt; auto&amp; get() { if constexpr (index == 0) { return value; } else { return rest.template get&lt;index - 1&gt;(); } }};// Helper function to make tuplestemplate&lt;typename... Ts&gt;Tuple&lt;Ts...&gt; make_tuple(Ts... ts) { return Tuple&lt;Ts...&gt;(ts...);}// Example usageint main() { auto t = make_tuple(1, 2.3, &quot;hello&quot;); std::cout &lt;&lt; &quot;Tuple elements: &quot; &lt;&lt; t.get&lt;0&gt;() &lt;&lt; &quot;, &quot; &lt;&lt; t.get&lt;1&gt;() &lt;&lt; &quot;, &quot; &lt;&lt; t.get&lt;2&gt;() &lt;&lt; std::endl; return 0;} Recursive construction builds the Tuple structure from the provided arguments First call, Tuple&lt;int, double, const char*&gt; Inside the constructor of Tuple&lt;int, double, const char*&gt;, value is initialized with 1. The constructor of rest (of type Tuple&lt;double, const char*&gt;) is called recursively with the remaining arguments 2.3 and “hello”. Second call, inside the constructor of Tuple&lt;double, const char*&gt;, value is initialized with 2.3. The constructor of rest (of type Tuple&lt;const char*&gt;) is called recursively with the remaining argument “hello”. Third call, inside the constructor of Tuple&lt;const char*&gt;, value is initialized with “hello”. Since there are no more arguments, the constructor of rest (of type Tuple&lt;&gt;) is called. Since Tuple&lt;&gt; is the primary template without any arguments, its constructor does nothing. It serves as the base case of the recursion. Recursive get() function The expression rest.template get&lt;index - 1&gt;() is calling the get() function on the member rest of the Tuple. template is used to specify that get is a template member function of the rest object. This disambiguates the use of the get() member function. References https://www.ibm.com/docs/it/i/7.4?topic=c11-parameter-packs https://www.scs.stanford.edu/~dm/blog/param-pack.html#expanding-parameter-packs https://en.cppreference.com/w/cpp/language/parameter_pack#Alignment_specifier https://learn.microsoft.com/en-us/cpp/preprocessor/variadic-macros?view=msvc-170","link":"/cpp/cpp-parameter-pack/"},{"title":"RTTI (Run-Time Type Information)","text":"Run-time type information (RTTI) is a mechanism that allows the type of an object to be determined at runtime. 1. Key Components of RTTIThe dynamic_cast operator. Used for conversion of polymorphic types. The typeid operator. Used for identifying the exact type of an object. The type_info class. Used to hold the type information returned by the typeid operator. 2. typeid operatorThe typeid operator is used to obtain type information about an expression. It returns a reference to a type_info object that represents the type of the expression. 123456789101112#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base {};class Derived : public Base {};int main() { Base* b = new Derived(); std::cout &lt;&lt; typeid(*b).name() &lt;&lt; std::endl; delete b; return 0;} 14Base // Output is a compiler-dependent mangled name In this code, typeid(*b).name() is used to get the name of the type of the object that b points to. However, since Base does not have any virtual functions, it is not a polymorphic base class. For non-polymorphic classes, typeid performs a compile-time type check rather than a runtime type check. This means that typeid(*b) will return the type information for Base, not Derived, even though b points to a Derived object. To get the Derived class, we need to make Base a polymorphic class by adding at least one virtual function. In this example, adding a virtual destructor to the Base class results in the creation of static vtables for both the Base and Derived classes. When the statement Base* b = new Derived(); is executed, b actually points to a Derived object. This is because of a hidden pointer, known as the vptr, which points to the vtable of the Derived class. More details on vtable: https://chuzcjoe.github.io/2023/12/12/cpp-vtable/ 123456789101112131415#include &lt;iostream&gt;#include &lt;typeinfo&gt;class Base {public: virtual ~Base() {}};class Derived : public Base {};int main() { Base* b = new Derived(); std::cout &lt;&lt; typeid(*b).name() &lt;&lt; std::endl; delete b; return 0;} 17Derived // Output is a compiler-dependent mangled name 3. dynamic_cast operatorThe dynamic_cast operator in C++ is used for safely converting pointers and references to classes up, down, and sideways within an inheritance hierarchy. It is primarily used in situations where you need to ensure that a cast is valid at runtime, especially when dealing with polymorphic types. dynamic_cast only works with polymophic classes, which are classes that contain at least one virtual function. This ensures that the class has a vtable that dynamic_cast can use to determine the actual type of the object at runtime. DowncastingConverting a Base pointer to a Derived pointer in order to access some Derived class specific members. 1234567891011121314151617181920212223#include &lt;iostream&gt;class Base {public: virtual ~Base() {} // Virtual destructor makes Base polymorphic};class Derived : public Base {public: void show() { std::cout &lt;&lt; &quot;Derived class method&quot; &lt;&lt; std::endl; }};int main() { Base* basePtr = new Derived(); Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr); if (derivedPtr) { derivedPtr-&gt;show(); // Safe to call Derived methods } else { std::cout &lt;&lt; &quot;Invalid cast&quot; &lt;&lt; std::endl; } delete basePtr; return 0;} 1Derived class method If we do: 12Base* basePtr = new Base();Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr); It will return Invalid cast because dynamic_cast performs a type-safe downcast, which means it only succeeds if the object being cast is actually of the derived type (or a type derived from it). Here, the object is not of the derived type, so the cast returns nullptr. UpcastingConverting a Derived pointer to Base pointer. This operation is implicitly supported in C++ and does not involve RTTI. However, we can still use dynamic_cast. 12Derived* dPtr = new Derived();Base* bPtr = dynamic_cast&lt;Base*&gt;(dPtr); SidecastingCasting between sibling classes within a class hierarchy. It requires that both the source and target types must inherit from a common base class that has at least one virtual function. This makes the base class polymorphic, enabling RTTI to work correctly. Sidecasting is less common, if you find yourself using sidecasting a lot, you may need to re-design your class hierarchy.Sidecasting is less common 4. Use cases of RTTI Type-Safe Downcasting: Ensuring that a cast from a base class pointer/reference to a derived class pointer/reference is valid. Object Type Identification: Determining the actual type of an object at runtime.","link":"/cpp/cpp-rtti/"},{"title":"Rule of Zero, Three, Five","text":"Guidelines for managing object resources. 1. Rule of Zero If a class doesn’t manage resources directly, it shouldn’t declare any special member functions. Rely on the compiler-generated defaults for these functions. This simplifies the class design and reduces the likelihood of resource management bugs. 2. Rule of ThreeA struct or class that manages resources should define these three special member functions: Destructor Copy constructor Copy assignment 12345678910111213141516171819202122232425class MyClass {private: int* data; size_t size;public: MyClass(size_t size) : data(new int[size]), size(size) {} ~MyClass() { delete[] data; } MyClass(const MyClass&amp; other) : data(new int[other.size]), size(other.size) { std::copy(other.data, other.data + size, data); } MyClass&amp; operator=(const MyClass&amp; other) { if (this != &amp;other) { delete[] data; size = other.size; data = new int[size]; std::copy(other.data, other.data + size, data); } return *this; }}; 3. Rule of FiveIt extends the Rule of Three to include move semantics. Destructor Copy constructor Copy assignment operator Move constructor Move assignment operator 1234567891011121314151617181920212223242526272829303132333435363738394041class MyClass {private: int* data; size_t size;public: MyClass(size_t size) : data(new int[size]), size(size) {} ~MyClass() { delete[] data; } MyClass(const MyClass&amp; other) : data(new int[other.size]), size(other.size) { std::copy(other.data, other.data + size, data); } MyClass&amp; operator=(const MyClass&amp; other) { if (this != &amp;other) { delete[] data; size = other.size; data = new int[size]; std::copy(other.data, other.data + size, data); } return *this; } MyClass(MyClass&amp;&amp; other) noexcept : data(other.data), size(other.size) { other.data = nullptr; other.size = 0; } MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept { if (this != &amp;other) { delete[] data; data = other.data; size = other.size; other.data = nullptr; other.size = 0; } return *this; }};","link":"/cpp/cpp-rule-of-zero-three-five/"},{"title":"Scope Resolution Operator Use Cases","text":"Summary of some common use cases of scope resolution operator. 1. Access namespace mmebers(variables, functions, classes) 123456789101112namespace A { int a = 10; void printA() { std::cout &lt;&lt; a &lt;&lt; '\\n'; }}int main() { std::cout &lt;&lt; A::x &lt;&lt; '\\n'; // Outputs 10 myNamespace::printA(); // Outputs 10 return 0;} 2. Access global variables, function, … 1234567int x = 10; // Global xint main() { int x = 20; std::cout &lt;&lt; ::x &lt;&lt; '\\n'; // Print 10} 3. Enum class members 123enum class Color { RED, GREEN, BLUE };Color myColor = Color::RED; 4. Access static class members 123456789101112131415class A {public: static int x; static void printX() { std::cout &lt;&lt; x &lt;&lt; std::endl; }};int A::x = 10; // Initialize static member variableint main() { std::cout &lt;&lt; A::x &lt;&lt; '\\n'; A::printX(); return 0;} 5. Call class member functions with a pointer 123456789101112class A {public: void printVal(int x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }};int main() { A* p = new A; p-&gt;A::printVal(10); return 0;} 6. Access base class members 123456789101112131415161718class A {public: int x; void foo() { std::cout &lt;&lt; &quot;A foo(), x = &quot; &lt;&lt; x &lt;&lt; '\\n'; }};class B : public A {public: void setValue(int value) { A::x = value + 1; // Explicit access to x from the Base class A::foo(); } void foo() { std::cout &lt;&lt; &quot;B foo(), x = &quot; &lt;&lt; x &lt;&lt; '\\n'; }}; 7. Defining and Using Type Aliases with Namespaces 1234567891011121314151617181920namespace A { // Type alias for an integer vector using IntVector = std::vector&lt;int&gt;; // Another type alias for a pointer to a function returning int and taking two int parameters using FuncPtr = int(*)(int, int);}int main() { A::IntVector numbers = {1, 2, 3, 4, 5}; // Using the type alias for a function pointer defined in MyNamespace auto lm = [](int a, int b){ return a + b; }; A::FuncPtr fptr = lm; int result = fptr(10, 20); return 0;} 8. Resolving ambiguity in multiple inheritance 123456789101112131415161718192021222324class A {public: int x = 5;};class B : public A { // inherits from class Apublic: int i = 6;};class C : public A { // inherits from class Apublic: int i = 7;};class D : public B, public C { // inherits from both classes B and C};int main() { D obj; std::cout &lt;&lt; obj.B::x &lt;&lt; std::endl; // Accessing x from B's A std::cout &lt;&lt; obj.C::x &lt;&lt; std::endl; // Accessing x from C's A return 0;}","link":"/cpp/cpp-scope-resolution-operator/"},{"title":"Load Functions from Shared Libraries","text":"Loading the partial shared library can be beneficial for two reasons: Original shared library can be very large sometimes(100+ Mb). Original shared library is not accessible until runtime(OEM specific libraries such OpenCL). 1. DemoWe will start with a customized demo example to illustrate how to load partial shared library at runtime. We will generate a simplified math library containing basic algorithmic operations(add, subtract, multiply and divide). test.cpp will load these functions at runtime. 1.1 Code1234.├── mathOP.cpp├── mathOP.h└── test.cpp 123456789101112// mathOP.h#ifndef MATH_OPERATIONS_H#define MATH_OPERATIONS_Hextern &quot;C&quot; { double add(double a, double b); double subtract(double a, double b); double multiply(double a, double b); double divide(double a, double b);}#endif // MATH_OPERATIONS_H 1234567891011121314151617181920212223// math.cpp#include &lt;cmath&gt;extern &quot;C&quot; { double add(double a, double b) { return a + b; } double subtract(double a, double b) { return a - b; } double multiply(double a, double b) { return a * b; } double divide(double a, double b) { if (b != 0) { return a / b; } return INFINITY; }} 12345678910111213141516171819202122232425262728293031323334// test.cpp#include &lt;iostream&gt;#include &lt;dlfcn.h&gt;#include &quot;mathOP.h&quot;int main() { void* handle = dlopen(&quot;./mathOP.so&quot;, RTLD_LAZY); if (!handle) { std::cerr &lt;&lt; &quot;Cannot open library: &quot; &lt;&lt; dlerror() &lt;&lt; '\\n'; return 1; } // Load the functions double (*add)(double, double) = (double (*)(double, double)) dlsym(handle, &quot;add&quot;); double (*subtract)(double, double) = (double (*)(double, double)) dlsym(handle, &quot;subtract&quot;); double (*multiply)(double, double) = (double (*)(double, double)) dlsym(handle, &quot;multiply&quot;); double (*divide)(double, double) = (double (*)(double, double)) dlsym(handle, &quot;divide&quot;); if (!add || !subtract || !multiply || !divide) { std::cerr &lt;&lt; &quot;Cannot load functions: &quot; &lt;&lt; dlerror() &lt;&lt; '\\n'; dlclose(handle); return 1; } // Use the functions std::cout &lt;&lt; &quot;5 + 3 = &quot; &lt;&lt; add(5, 3) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;5 - 3 = &quot; &lt;&lt; subtract(5, 3) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;5 * 3 = &quot; &lt;&lt; multiply(5, 3) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;5 / 3 = &quot; &lt;&lt; divide(5, 3) &lt;&lt; '\\n'; dlclose(handle); return 0;} 1.2 Compile and Run1g++ -fPIC -shared -o mathOP.so mathOP.cpp 1g++ -o test test.cpp -ldl 1234567./testoutput:5 + 3 = 85 - 3 = 25 * 3 = 155 / 3 = 1.66667 2. Practice on libJpegIf you’re using a Mac with Apple silicon, you can follow my tutorial step by step to reproduce the results. For other operating systems, like Linux or Windows, the process is generally similar, but you may need to do some research and make a few adjustments. To install jpeg library: 1brew install libjpeg You should be able to see the installed location in your terminal message. For example, mine is: 123456If you need to have jpeg first in your PATH, run: echo 'export PATH=&quot;/opt/homebrew/opt/jpeg/bin:$PATH&quot;' &gt;&gt; ~/.zshrcFor compilers to find jpeg you may need to set: export LDFLAGS=&quot;-L/opt/homebrew/opt/jpeg/lib&quot; export CPPFLAGS=&quot;-I/opt/homebrew/opt/jpeg/include&quot; Let’s write a C++ program to read a jpeg format image. In our program, we only load needed functions to read an image. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;dlfcn.h&gt;#include &lt;cstdio&gt;#include &lt;jpeglib.h&gt;// Function pointer types using modern C++ syntaxusing jpeg_std_error_type = struct jpeg_error_mgr* (*)(struct jpeg_error_mgr* err);using jpeg_CreateDecompress_type = void (*)(j_decompress_ptr cinfo, int version, size_t structsize);using jpeg_destroy_decompress_type = void (*)(j_decompress_ptr cinfo);using jpeg_read_header_type = int (*)(j_decompress_ptr cinfo, boolean require_image);using jpeg_start_decompress_type = boolean (*)(j_decompress_ptr cinfo);using jpeg_abort_decompress_type = void (*)(j_decompress_ptr cinfo);using jpeg_stdio_src_type = void (*)(j_decompress_ptr cinfo, FILE* infile);int main(int argc, char* argv[]) { if (argc != 2) { std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;JPEG file&gt;&quot; &lt;&lt; std::endl; return 1; } // Open the shared library void* handle = dlopen(&quot;/opt/homebrew/opt/jpeg/lib/libjpeg.dylib&quot;, RTLD_LAZY); if (!handle) { // Try an alternative path if the first one fails handle = dlopen(&quot;./libjpeg.dylib&quot;, RTLD_LAZY); if (!handle) { std::cerr &lt;&lt; &quot;Cannot open library: &quot; &lt;&lt; dlerror() &lt;&lt; std::endl; return 1; } } // Load the functions auto jpeg_std_error = reinterpret_cast&lt;jpeg_std_error_type&gt;(dlsym(handle, &quot;jpeg_std_error&quot;)); auto jpeg_CreateDecompress = reinterpret_cast&lt;jpeg_CreateDecompress_type&gt;(dlsym(handle, &quot;jpeg_CreateDecompress&quot;)); auto jpeg_destroy_decompress = reinterpret_cast&lt;jpeg_destroy_decompress_type&gt;(dlsym(handle, &quot;jpeg_destroy_decompress&quot;)); auto jpeg_read_header = reinterpret_cast&lt;jpeg_read_header_type&gt;(dlsym(handle, &quot;jpeg_read_header&quot;)); auto jpeg_start_decompress = reinterpret_cast&lt;jpeg_start_decompress_type&gt;(dlsym(handle, &quot;jpeg_start_decompress&quot;)); auto jpeg_abort_decompress = reinterpret_cast&lt;jpeg_abort_decompress_type&gt;(dlsym(handle, &quot;jpeg_abort_decompress&quot;)); auto jpeg_stdio_src = reinterpret_cast&lt;jpeg_stdio_src_type&gt;(dlsym(handle, &quot;jpeg_stdio_src&quot;)); if (!jpeg_std_error || !jpeg_CreateDecompress || !jpeg_destroy_decompress || !jpeg_read_header || !jpeg_start_decompress || !jpeg_abort_decompress || !jpeg_stdio_src) { std::cerr &lt;&lt; &quot;Cannot load function: &quot; &lt;&lt; dlerror() &lt;&lt; std::endl; dlclose(handle); return 1; } // Open the JPEG file FILE* infile = fopen(argv[1], &quot;rb&quot;); if (!infile) { std::cerr &lt;&lt; &quot;Can't open &quot; &lt;&lt; argv[1] &lt;&lt; std::endl; dlclose(handle); return 1; } // Set up the JPEG decompression object struct jpeg_decompress_struct cinfo; struct jpeg_error_mgr jerr; cinfo.err = jpeg_std_error(&amp;jerr); jpeg_CreateDecompress(&amp;cinfo, JPEG_LIB_VERSION, sizeof(struct jpeg_decompress_struct)); // Specify the source file jpeg_stdio_src(&amp;cinfo, infile); // Read the JPEG header jpeg_read_header(&amp;cinfo, TRUE); // Start decompression jpeg_start_decompress(&amp;cinfo); // Print image information std::cout &lt;&lt; &quot;Image Width: &quot; &lt;&lt; cinfo.output_width &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Image Height: &quot; &lt;&lt; cinfo.output_height &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Color Components: &quot; &lt;&lt; cinfo.output_components &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Color Space: &quot; &lt;&lt; cinfo.out_color_space &lt;&lt; std::endl; // Clean up jpeg_abort_decompress(&amp;cinfo); jpeg_destroy_decompress(&amp;cinfo); fclose(infile); dlclose(handle); return 0;} To compile and run: 12345678g++ -o test test.cpp -I/opt/homebrew/opt/jpeg/include -std=c++11./test img.jpgoutput:Image Width: 4000Image Height: 6000Color Components: 3Color Space: 2","link":"/cpp/cpp-load-functions-from-shared-library/"},{"title":"Singleton Design Pattern","text":"Design pattern. A Singleton is a design pattern that ensures a class has only one instance and provides a global point of access to that instance. 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;class Singleton {private: static Singleton* _instance; Singleton() { std::cout &lt;&lt; &quot;Singleton created\\n&quot;; } // Prevent copying Singleton(const Singleton&amp; rhs) = delete; // Prevent assignment Singleton&amp; operator=(const Singleton&amp; rhs) = delete;public: static Singleton* getInstance() { if (_instance == nullptr) { _instance = new Singleton(); } return _instance; }};Singleton* Singleton::_instance = nullptr;int main() { Singleton* a = Singleton::getInstance(); Singleton* b = Singleton::getInstance(); Singleton* c = Singleton::getInstance(); std::cout &lt;&lt; &quot;Memory addresses of a, b and c: &quot; &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; c &lt;&lt; '\\n';} 12Singleton createdMemory addresses of a, b and c: 0x17662b0 0x17662b0 0x17662b0","link":"/cpp/cpp-singleton/"},{"title":"Object Slicing","text":"Slicing in C++ and how to prevent it. IntroductionIn C++, when a derived class object is assigned to a base class object, the fields and methods in the derived class object will be sliced off. Since these extra components are not used, the priority is given to base class. The following example shows how slicing happens. 1234567891011121314151617181920212223242526272829303132333435363738class Base {public: Base() { std::cout &lt;&lt; &quot;Base() called\\n&quot;; } Base(Base&amp; obj) { std::cout &lt;&lt; &quot;Base(Base&amp; obj) called\\n&quot;; } virtual void getName() const { std::cout &lt;&lt; &quot;Base getName()\\n&quot;; }};class Derived : public Base {public: Derived() { std::cout &lt;&lt; &quot;Derived() called\\n&quot;; } void getName() const override { std::cout &lt;&lt; &quot;Derived getName()\\n&quot;; }};int main() { Base b; Derived d; std::cout &lt;&lt; &quot;--------\\n&quot;; b = d; b.getName(); return 0;} 12345Base() calledBase() calledDerived() called--------Base getName() Let’s take a look at another example. When a vector holds Base type, however Derived objects are pushed to the vector, object slicing will occur. 12345678910111213141516171819202122232425262728293031323334353637class Base {public: Base() { std::cout &lt;&lt; &quot;Base() called\\n&quot;; } Base(const Base&amp; obj) { std::cout &lt;&lt; &quot;Base(Base&amp; obj) called\\n&quot;; } virtual void getName() const { std::cout &lt;&lt; &quot;Base getName()\\n&quot;; }};class Derived : public Base {public: Derived() { std::cout &lt;&lt; &quot;Derived() called\\n&quot;; } void getName() const override { std::cout &lt;&lt; &quot;Derived getName()\\n&quot;; }};int main() { std::vector&lt;Base&gt; vec; Derived d; vec.push_back(d); // 1. Base b = d; 2. Base(const Base&amp; obj) vec[0].getName(); return 0;} 1234Base() calledDerived() calledBase(Base&amp; obj) calledBase getName() The solutions to this problem is either using reference or pointer. Use references12345678910111213141516171819202122232425262728293031323334class Base {public: Base() { std::cout &lt;&lt; &quot;Base() called\\n&quot;; } Base(const Base&amp; obj) { std::cout &lt;&lt; &quot;Base(Base&amp; obj) called\\n&quot;; } virtual void getName() const { std::cout &lt;&lt; &quot;Base getName()\\n&quot;; }};class Derived : public Base {public: Derived() { std::cout &lt;&lt; &quot;Derived() called\\n&quot;; } void getName() const override { std::cout &lt;&lt; &quot;Derived getName()\\n&quot;; }};int main() { Derived d; Base&amp; b = d; b.getName(); return 0;} 123Base() calledDerived() calledDerived getName() Note that std::vector&lt;Base&amp;&gt; vec; is not legal. Containers like std::vector manage memory for their elements, and they assume ownership of the objects stored in them. Objects stored in a container need to be owned by the container to ensure proper memory management. References, on the other hand, do not own the objects they refer to. They are just aliases or alternative names for existing objects. Allowing a container to hold references could lead to dangling references if the original objects are destroyed while the container still holds references to them. Use PointersA better way to prevent object slicing is to use pointers. 123456789101112131415161718192021222324252627282930313233343536class Base {public: Base() { std::cout &lt;&lt; &quot;Base() called\\n&quot;; } Base(const Base&amp; obj) { std::cout &lt;&lt; &quot;Base(Base&amp; obj) called\\n&quot;; } virtual void getName() const { std::cout &lt;&lt; &quot;Base getName()\\n&quot;; }};class Derived : public Base {public: Derived() { std::cout &lt;&lt; &quot;Derived() called\\n&quot;; } void getName() const override { std::cout &lt;&lt; &quot;Derived getName()\\n&quot;; }};int main() { std::vector&lt;Base*&gt; vec; Derived d; vec.push_back(&amp;d); vec[0]-&gt;getName(); return 0;} 123Base() calledDerived() calledDerived getName() References https://www.geeksforgeeks.org/object-slicing-in-c/ https://www.youtube.com/watch?v=qe5s9oTsY0s https://www.youtube.com/watch?v=99xTGkdxAdc&amp;t=2s","link":"/cpp/cpp-slicing/"},{"title":"Static Assertion and Type Trait","text":"Use static assertion and type trait for error check. 1. Static Assertionstatic_assert is a compile-time assertion that checks if a given condition is true. 1234567891011121314151617#include &lt;type_traits&gt;template &lt;typename T, int Size&gt;class Vector{ static_assert(Size &lt; 5, &quot;Size is too large&quot;); T _points[Size];};int main(){ Vector&lt;int, 16&gt; a1; Vector&lt;double, 2&gt; a2; static_assert(sizeof(int) == 4, &quot;The size of int is not 4 bytes.&quot;); return 0;} 12345&lt;source&gt;:6:4: error: static_assert failed due to requirement '16 &lt; 5' &quot;Size is too large&quot; static_assert(Size &lt; 5, &quot;Size is too large&quot;); ^ ~~~~~~~~&lt;source&gt;:12:20: note: in instantiation of template class 'Vector&lt;int, 16&gt;' requested here Vector&lt;int, 16&gt; a1; 2. Type TraitType traits provide ways to query and modify types at compile time. Common Type TraitsHere are some common type traits and their purposes: Type Information: std::is_integral: Checks if T is an integral type. std::is_floating_point: Checks if T is a floating-point type. std::is_pointer: Checks if T is a pointer type. std::is_array: Checks if T is an array type. Type Modifiers: std::remove_cv: Removes const and volatile qualifiers from T. std::remove_reference: Removes reference qualifiers from T. std::remove_pointer: Removes pointer qualifiers from T. Composite Type Traits: std::is_same&lt;T, U&gt;: Checks if T and U are the same type. std::is_base_of&lt;Base, Derived&gt;: Checks if Base is a base class of Derived. std::is_convertible&lt;From, To&gt;: Checks if From can be implicitly converted to To. Property Queries: std::is_const: Checks if T is const-qualified. std::is_volatile: Checks if T is volatile-qualified. std::is_signed: Checks if T is a signed type. std::is_unsigned: Checks if T is an unsigned type. 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;typename T&gt;void check_integral() { if (std::is_integral&lt;T&gt;::value) { std::cout &lt;&lt; &quot;T is an integral type.\\n&quot;; } else { std::cout &lt;&lt; &quot;T is not an integral type.\\n&quot;; }}template &lt;typename T, typename U&gt;void check_same() { if (std::is_same&lt;T, U&gt;::value) { std::cout &lt;&lt; &quot;T and U are the same type.\\n&quot;; } else { std::cout &lt;&lt; &quot;T and U are not the same type.\\n&quot;; }}int main() { check_integral&lt;int&gt;(); // T is an integral type. check_integral&lt;double&gt;(); // T is not an integral type. check_same&lt;int, int&gt;(); check_same&lt;int, float&gt;();} 3. Use them togetherCombining static_assert and type traits in C++ allows you to enforce compile-time checks on template parameters or any other types, ensuring that the types meet certain criteria before the code is allowed to compile. This can be very useful for template programming to provide clear and immediate feedback to the developer. If the type or condition is determined at runtime, static_assert can not be used directly to do such checks. 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;type_traits&gt;template &lt;typename T&gt;void process(T value) { // Static assertion to ensure T is either an integral or floating-point type static_assert(std::is_arithmetic&lt;T&gt;::value, &quot;Template parameter T must be an arithmetic type.&quot;); if constexpr (std::is_integral&lt;T&gt;::value) { std::cout &lt;&lt; &quot;Processing integral type: &quot; &lt;&lt; value &lt;&lt; '\\n'; } else if constexpr (std::is_floating_point&lt;T&gt;::value) { std::cout &lt;&lt; &quot;Processing floating-point type: &quot; &lt;&lt; value &lt;&lt; '\\n'; }}int main() { process(42); // Processing integral type: 42 process(3.14); // Processing floating-point type: 3.14 process(&quot;Hello&quot;); // Compilation error return 0;}","link":"/cpp/cpp-static-assert-type-trait/"},{"title":"Static Polymorphism","text":"Compile time polymorphism. 1. IntroductionStatic polymorphism in C++ is achieved using templates and compile-time mechanisms. Unlike dynamic polymorphism (achieved with inheritance and virtual functions), static polymorphism determines which function to call at compile time, resulting in better performance because there is no runtime overhead like virtual table lookups. The most common method to achieve static polymorphism in C++ is through templates and CRTP (Curiously Recurring Template Pattern). 2. CRTP(Curiously Recurring Template Pattern)CRTP is a design pattern where a derived class inherits from a base class that is templated on the derived class. This allows compile-time polymorphism with no runtime overhead. CRTP.cpp1234567891011121314151617181920212223#include &lt;iostream&gt;template &lt;typename Derived&gt;class Base {public: void interface() { // Call the derived class implementation static_cast&lt;Derived*&gt;(this)-&gt;implementation(); }};class Derived : public Base&lt;Derived&gt; {public: void implementation() { std::cout &lt;&lt; &quot;Derived implementation called.&quot; &lt;&lt; std::endl; }};int main() { Derived d; d.interface(); // Calls Derived::implementation return 0;} Here is a more generic example. shape.cpp12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;// Base class templatetemplate &lt;typename Derived&gt;class Shape {public: void draw() { // Call the derived class's implementation static_cast&lt;Derived*&gt;(this)-&gt;draw(); }};// Derived classclass Circle : public Shape&lt;Circle&gt; {public: void draw() { std::cout &lt;&lt; &quot;Drawing a Circle&quot; &lt;&lt; std::endl; }};// Another derived classclass Square : public Shape&lt;Square&gt; {public: void draw() { std::cout &lt;&lt; &quot;Drawing a Square&quot; &lt;&lt; std::endl; }};int main() { Shape&lt;Circle&gt; c; Shape&lt;Square&gt; s; c.draw(); // Outputs: Drawing a Circle s.draw(); // Outputs: Drawing a Square return 0;} 3. Comparison with Dynamic Polymorphism Feature Static Polymorphism Dynamic Polymorphism Binding Time Compile-time Runtime Implementation Templates, CRTP Virtual functions, inheritance Performance Faster (no vtable lookup) Slower due to runtime overhead Flexibility Limited (known types at compile time) Flexible (can use any derived type at runtime) 4. ConclusionYou should use static polymorphism when: You need polymorphism but want to avoid the overhead of dynamic dispatch. In scenarios where the type of objects involved is known at compile-time. Your system is performance-critical.","link":"/cpp/cpp-static-polymorphism/"},{"title":"Static And Shared Library","text":"Code distribution among different programs and machines. 1. IntroductionA static library is a collection of object files that are linked into the program during the linking phase of compilation, becoming part of the final executable. A shared library is a collection of object files that are loaded into the program at runtime. Multiple programs can share the same library code in memory. 2. Example2.1 ImplementationSource code can be found at: https://github.com/chuzcjoe/static_shared_lib Project structure 12345678.├── CMakeLists.txt├── README.md├── main.cpp└── math ├── CMakeLists.txt ├── mathlib.cpp └── mathlib.h We have a simple math library that does simple math operations. 123456789101112131415161718192021222324252627282930313233343536373839// mathlib.h#pragma onceclass MathLib {public: MathLib(); ~MathLib(); double add(double, double); double subtract(double, double); double multiply(double, double); double divide(double, double);};// mathlib.cpp#include &quot;mathlib.h&quot;#include &lt;iostream&gt;double MathLib::add(double a, double b) { return a + b;}double MathLib::subtract(double a, double b) { return a - b;}double MathLib::multiply(double a, double b) { return a * b;}double MathLib::divide(double a, double b) { if (b == 0) { throw std::domain_error(&quot;Division by zero.&quot;); } return a / b;}MathLib::MathLib() {}MathLib::~MathLib() {} We will compile it into both static and shared libraries. 1234567891011cmake_minimum_required(VERSION 3.5.0)project(Math VERSION 0.0.1 LANGUAGES CXX)set(CMAKE_CXX_STANDARD 14)set(CMAKE_CXX_STANDARD_REQUIRED ON)# Create a shared libraryadd_library(math_shared SHARED mathlib.cpp)# Create a static libraryadd_library(math_static STATIC mathlib.cpp) For the most outside CMakeLists.txt, we will generate different executables that link to static/shared libraries. 123456789101112131415161718cmake_minimum_required(VERSION 3.5.0)project(main VERSION 0.0.1 LANGUAGES CXX)set(CMAKE_CXX_STANDARD 14)set(CMAKE_CXX_STANDARD_REQUIRED ON)add_subdirectory(${CMAKE_SOURCE_DIR}/math)# add an executable that links to a shared libraryadd_executable(main_shared main.cpp)target_include_directories(main_shared PRIVATE ${CMAKE_SOURCE_DIR}/math)target_link_libraries(main_shared PRIVATE math_shared)# add an executable that links to a static libraryadd_executable(main_static main.cpp)target_include_directories(main_static PRIVATE ${CMAKE_SOURCE_DIR}/math)target_link_libraries(main_static PRIVATE math_static) 2.2 BuildLet’s build it. 1234mkdir buildcd buildcmake ..make In the build folder, we can get two executables and inside the math folder, we have generated static/shared libraries. They should have the same output. 12345678├── main_shared├── main_static└── math ├── CMakeFiles ├── Makefile ├── cmake_install.cmake ├── libmath_shared.dylib └── libmath_static.a 12345678910111213&gt; ./main_staticinput x and y: 10, 5Addition: 15Subtraction: 5Multiplication: 50Division: 2&gt; ./main_shared input x and y: 10, 5Addition: 15Subtraction: 5Multiplication: 50Division: 2 2.3 InspectWe could use otool on MacOS to check the dependencies of each executable. Or on Linux we could use ldd. 1234&gt; otool -L main_static main_static: /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 1500.65.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1319.100.3) 12345&gt; otool -L main_shared main_shared: @rpath/libmath_shared.dylib (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 1500.65.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1319.100.3) Because static libraries will become part of the executable, so libmath_static.a is not a dependency. On the other hand, shared libraries are loaded during runtime, so main_shared replies on libmath_shared.dylib. 2.4 File sizeLinking a static library involves incorporating the entire library into the final executable. Compared with linking shared library, executables that link to static library usually will have larger file size. 1234&gt; ls -lh main_static -rwxr-xr-x 1 zongchengchu staff 40K Jun 29 13:55 main_static&gt; ls -lh main_shared -rwxr-xr-x 1 zongchengchu staff 39K Jun 29 13:55 main_shared 2.5 Delete dependenciesIf we delete both libmath_static.a and libmath_shared.dylib, main_static can still run without any issues. 123456&gt; ./main_static input x and y: 10, 5Addition: 15Subtraction: 5Multiplication: 50Division: 2 However, main_shared needs to load libmath_shared.dylib at runtime, and it looks for the library at current project as well as system paths. If this library is not found, then we will get a link error. 1234&gt; ./main_shared dyld[55250]: Library not loaded: @rpath/libmath_shared.dylib Referenced from: &lt;4F8039F2-AFFB-303C-999C-FAF867191A7C&gt; /Users/zongchengchu/Documents/repos/static_shared_lib/build/main_shared Reason: tried: '/Users/zongchengchu/Documents/repos/static_shared_lib/build/math/libmath_shared.dylib' (no such file), '/System/Volumes/Preboot/Cryptexes/OS/Users/zongchengchu/Documents/repos/static_shared_lib/build/math/libmath_shared.dylib' (no such file), '/Users/zongchengchu/Documents/repos/static_shared_lib/build/math/libmath_shared.dylib' (no such file), '/System/Volumes/Preboot/Cryptexes/OS/Users/zongchengchu/Documents/repos/static_shared_lib/build/math/libmath_shared.dylib' (no such file), '/usr/local/lib/libmath_shared.dylib' (no such file), '/usr/lib/libmath_shared.dylib' (no such file, not in dyld cache) 2.5 MoreIf a static/shared library depends on another library. The relationship can be: dependencies valid? shared_lib links to static_lib &cross; shared_lib links to shared_lib &check; static_lib links to static_lib &check; static_lib links to shared_lib &check; Shared libraries can only be linked to shared libraries. Static libraries can be linked to both shared and static library. 3. Conclusionstatic library Advantages: Simplicity: No external dependencies are required at runtime. Performance: Sometimes faster to start and run due to the absence of the need to resolve symbols or load additional libraries at runtime. Disadvantages: File Size: Can lead to larger executable sizes because each program has its own copy of the library. Updates: If the library is updated, all applications using it must be recompiled and redeployed to benefit from the updates. shared library Advantages: Reduced Memory Usage: Since the library is shared in memory among multiple programs, it can reduce memory usage overall. Ease of Updating: Updating a shared library can provide immediate benefits to all programs that use it, without needing recompilation. Disadvantages: Complexity: Requires careful management of versions and dependencies to ensure compatibility. Startup Time: Can have slower startup times as the operating system needs to link the external libraries dynamically when the program is launched. void GLRender::nextImage() { LOG_INFO(“switch to next image.”); int next_index = (image_idx + 1) % IMAGE_NUM; sdrImage.setFilepath(files[next_index]); glBindTexture(GL_TEXTURE_2D, 0); glBindTexture(GL_TEXTURE_2D, _texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); sdrImage.loadJPEG(); auto data = sdrImage.data(); int width = sdrImage.getWidth(); int height = sdrImage.getHeight(); if (data) { // generate texture glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); LOG_INFO(&quot;load texture success, width: %d, height: %d\\n&quot;, width, height); } else { LOG_ERROR(&quot;load texture error&quot;); } glUseProgram(tProgram); glUniform1i(glGetUniformLocation(tProgram, &quot;texture_load&quot;), 0); }","link":"/cpp/cpp-static-shared-library/"},{"title":"Static in C++","text":"Static variables/functions, static in the context of class/struct Internal linkage and external linkageWhen you write an implementation file (.cpp, .cxx, etc) your compiler generates a translation unit. This is the source file from your implementation plus all the headers you #included in it. Internal linkage refers to everything only in scope of a translation unit. External linkage refers to things that exist beyond a particular translation unit. In other words, accessible through the whole program, which is the combination of all translation units (or object files). Internal linkage can be achieved by using static keyword. Let’s see an example where we have two .cpp files. main.cpp 1234567#include &lt;iostream&gt;extern int a;int main() { std::cout &lt;&lt; a &lt;&lt; std::endl;} static.cpp 1int a = 5; compile and run: 1234g++ main.cpp static.cpp -o main./main5 int a = 5; is extern by default. Other translation unit (main.cpp) has access to it. If we change static.cpp to: static.cpp 1static int a = 5; The compiler will give us errors as following. This is because a is now only visible in the scope of its translation unit. Other translation units are not accessible. 1main.cpp:(.text+0xa): undefined reference to `a' const variables are also static by default and only accessible in the scope of a translation unit. However, we can explicitly declare them as extern to be able to extend to other files. main.cpp 123456789#include &lt;iostream&gt;int a = 8;extern int ci;int main() { std::cout &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; ci &lt;&lt; std::endl;} static.cpp 12static int a = 5;extern const int ci = 10; compile and run: 12810 We are using ci declared in static.cpp. Static in a functionWhen a variable is declared as static, memory will be allocated for the lifetime of the program. Even if the function gets called multiple times, the space for the static variable will only be allocated once and the its value will get carried through the next call. 1234567891011void foo() { static int a = 0; std::cout &lt;&lt; a &lt;&lt; std::endl; a++;}int main() { for (int i = 0; i &lt; 10; i++) { foo(); }} output: 123456789100123456789 Static in classWhen we declare a member of class as static, only one copy of the static member is maintained no matter how many objects of the class we create. Thus, a static member is shared by all the objects. It can be initialized outside of the class using scope resolution operator ::. Static members can not be initialized using constructors. 123456789101112131415161718class Base {public: static int m_count; Base() { m_count++; }};// Initialize static member of Baseint Base::m_count = 0;int main() { Base b1; Base b2; std::cout &lt;&lt; &quot;number of objects: &quot; &lt;&lt; Base::m_count &lt;&lt; std::endl;} 1number of objects: 2 Just like static variables, static member functions also do not depend on the object of the class. We can use the class name followed by :: to invoke the static member functions. Note that static member functions can only access the static member variable and functions. They can not access non-static data of the class. 1234567891011121314151617181920212223class Base {public: static int m_count; int m_a; Base(int a) : m_a(a) { m_count++; } static void foo() { std::cout &lt;&lt; m_a &lt;&lt; std::endl; }};// Initialize static member of Baseint Base::m_count = 0;int main() { Base b1(1); Base b2(2); b1.foo();} 123Line 12: Char 22: error: invalid use of member 'm_a' in static member function std::cout &lt;&lt; m_a &lt;&lt; std::endl; ^~~ We change m_a to m_count in foo() 123456789101112131415161718192021222324class Base {public: static int m_count; int m_a; Base(int a) : m_a(a) { m_count++; } static void foo() { std::cout &lt;&lt; m_count &lt;&lt; std::endl; }};// Initialize static member of Baseint Base::m_count = 0;int main() { Base b1(1); Base b2(2); b1.foo(); b2.foo();} 1222 References https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage https://www.geeksforgeeks.org/static-keyword-cpp/ https://www.tutorialspoint.com/cplusplus/cpp_static_members.htm","link":"/cpp/cpp-static/"},{"title":"std::string_view","text":"Work with string efficiently. 1. Basicsstring_view (which lives in &lt;string_view&gt; header) provides read-only access to existing strings (C-style string, std::string or string_view) without making a copy. It acts as an observer, allowing us to view and utilize the string’s contents without the need for duplication or alteration. 1.1 Initialize with different types of strings12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt;int main(){ std::string_view s1{&quot;Hello, world!&quot;}; // initialize with C-style string literal std::cout &lt;&lt; s1 &lt;&lt; '\\n'; std::string s{&quot;Hello, world!&quot;}; std::string_view s2{s}; // initialize with std::string std::cout &lt;&lt; s2 &lt;&lt; '\\n'; std::string_view s3{s2}; // initialize with std::string_view std::cout &lt;&lt; s3 &lt;&lt; '\\n';} 1.2 Accept different types of strings as parameters1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt;void printSV(std::string_view str) { std::cout &lt;&lt; str &lt;&lt; '\\n';}int main() { printSV(&quot;Hello, world!&quot;); // call with C-style string literal std::string s2{ &quot;Hello, world!&quot; }; printSV(s2); // call with std::string std::string_view s3 { s2 }; printSV(s3); // call with std::string_view} 2. Use string_view safelyIf you try the provided examples, you probably won’t see any compiler generated warnings. This is typically due to the absence of warning-related flags in the compilation command. Here is the compile command that I use. 1-std=c++20 -Wpedantic -Wall -Wextra -Wconversion -O3 -Werror 2.1 std::string_view to std::stringC++ doesn’t allow implicit conversion from std::string_view to std::string to prevent expensive copy. However, we can still achieve that by doing: Explicitly creating std::string with std::string_view initializer. Using static_cast to convert a string_view to string. 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt;void printString(std::string str) { std::cout &lt;&lt; str &lt;&lt; '\\n';}int main() { std::string_view sv{ &quot;Hello, world!&quot; }; // printString(sv); // compile error: won't implicitly convert std::string_view to a std::string std::string s{ sv }; // okay: we can create std::string using std::string_view initializer printString(s); // and call the function with the std::string printString(static_cast&lt;std::string&gt;(sv)); // okay: we can explicitly cast a std::string_view to a std::string} 2.2 Dangling viewerMake sure it always points to valid objects 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt;std::string getName() { std::string s {&quot;Hello World\\n&quot;}; return s;}int main() { // -----case 1----- std::string_view name {getName()}; // name initialized with return value of function std::cout &lt;&lt; name &lt;&lt; '\\n'; // undefined behavior // -----case 2----- std::string_view sv{}; { // create a nested block std::string s{ &quot;Hello, world!&quot; }; // create a std::string local to this nested block sv = s; // sv is now viewing s } // s is destroyed here, so sv is now viewing an invalid string std::cout &lt;&lt; sv &lt;&lt; '\\n'; // undefined behavior} 2.3 Return std::string_view safelyReturning a std::string_view is not suggested since local variables will be destroyed at the end of the function, leading to invalid string_view. However, we can still achieve that by: Returning C-style literals that exist for the entire program. Returning a function parameter of type std::string_view since it exists in the scope of the caller. 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string_view&gt;std::string_view getBoolName(bool b) { if (b) return &quot;true&quot;; // return a std::string_view viewing &quot;true&quot; return &quot;false&quot;; // return a std::string_view viewing &quot;false&quot;} // &quot;true&quot; and &quot;false&quot; are not destroyed at the end of the functionstd::string_view firstAlphabetical(std::string_view s1, std::string_view s2) { return s1 &lt; s2 ? s1: s2; // uses operator?: (the conditional operator)}int main() { std::cout &lt;&lt; getBoolName(true) &lt;&lt; ' ' &lt;&lt; getBoolName(false) &lt;&lt; '\\n'; // ok std::string a {&quot;World&quot;}; std::string b {&quot;Hello&quot;}; std::cout &lt;&lt; firstAlphabetical(a, b) &lt;&lt; '\\n'; // prints &quot;Hello&quot;} References https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/ https://www.learncpp.com/cpp-tutorial/stdstring_view-part-2/","link":"/cpp/cpp-string-view/"},{"title":"Theading Pool","text":"Basic threading pool Advanced threading pool 1. Basic Threading PoolIn a simple threading pool setup, there’s a set number of threads and a queue for tasks. Tasks are processed in a first-in, first-out (FIFO) manner. Any idle threads will promptly handle the task at the front of the queue. A few things to note. Line 22 added predicate to prevent spurious wakeup. Once the thread is blocked by the wait(), will automatically call lock.unlock() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;functional&gt;#include &lt;chrono&gt;class ThreadPool {private: std::mutex queueMutex; std::condition_variable condition; bool stop; std::vector&lt;std::thread&gt; workers; std::queue&lt;std::function&lt;void()&gt;&gt; tasks;public: ThreadPool(size_t num) : stop(false) { for (size_t i = 0; i &lt; num; i++) { workers.emplace_back([this]{ for(;;) { std::unique_lock&lt;std::mutex&gt; lock(queueMutex); condition.wait(lock, [this]{return stop || !tasks.empty();}); if (stop &amp;&amp; tasks.empty()) return; auto task = std::move(tasks.front()); tasks.pop(); lock.unlock(); task(); } }); } } ~ThreadPool() { std::cout &lt;&lt; &quot;~ThreadPool() start\\n&quot;; std::unique_lock&lt;std::mutex&gt; lock(queueMutex); stop = true; lock.unlock(); condition.notify_all(); for (auto&amp; worker : workers) worker.join(); std::cout &lt;&lt; &quot;~ThreadPool() end\\n&quot;; } template&lt;class F&gt; void enqueue(F&amp;&amp; task) { std::unique_lock&lt;std::mutex&gt; lock(queueMutex); tasks.emplace(std::forward&lt;F&gt;(task)); lock.unlock(); condition.notify_one(); std::cout &lt;&lt; &quot;notify thread...\\n&quot;; }};int main() { ThreadPool pool(3); std::cout &lt;&lt; &quot;adding tasks\\n&quot;; for (int i = 0; i &lt; 15; i++) { pool.enqueue([i](){ std::cout &lt;&lt; &quot;Task &quot; &lt;&lt; i &lt;&lt; &quot; executed by thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); }); } std::cout &lt;&lt; &quot;finish adding tasks\\n&quot;; std::cout &lt;&lt; &quot;This is main thread running\\n&quot;; return 0;} Advanced Threading PoolA sophisticated threading pool implementation employs a design where each individual thread is assigned its own distinct task queue. Tasks are added to these queues, and each thread processes the tasks present in its corresponding queue in sequential order. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;functional&gt;#include &lt;chrono&gt;#include &lt;vector&gt;class ThreadPool {private: std::mutex queueMutex; std::condition_variable condition; bool stop; std::vector&lt;std::thread&gt; workers; std::vector&lt;std::queue&lt;std::function&lt;void()&gt;&gt;&gt; taskQueues;public: ThreadPool(size_t num) : stop(false), taskQueues(num) { for (size_t i = 0; i &lt; num; i++) { workers.emplace_back([this, i] { for (;;) { std::unique_lock&lt;std::mutex&gt; lock(queueMutex); condition.wait(lock, [this, i] { return stop || !taskQueues[i].empty(); }); if (stop &amp;&amp; taskQueues[i].empty()) return; auto task = std::move(taskQueues[i].front()); taskQueues[i].pop(); lock.unlock(); task(); } }); } } ~ThreadPool() { { std::unique_lock&lt;std::mutex&gt; lock(queueMutex); stop = true; } condition.notify_all(); for (auto&amp; worker : workers) worker.join(); } template &lt;class F&gt; void enqueue(F&amp;&amp; task, size_t queueIndex = 0) { std::unique_lock&lt;std::mutex&gt; lock(queueMutex); taskQueues[queueIndex].emplace(std::forward&lt;F&gt;(task)); lock.unlock(); condition.notify_one(); }};int main() { ThreadPool pool(3); std::cout &lt;&lt; &quot;adding tasks\\n&quot;; for (int i = 0; i &lt; 15; i++) { pool.enqueue([i]() { std::cout &lt;&lt; &quot;Enqueued Task &quot; &lt;&lt; i &lt;&lt; &quot; to Queue &quot; &lt;&lt; i % 3 &lt;&lt; &quot;, and executed by thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); }, i % 3); // Distribute tasks evenly across the threads } std::cout &lt;&lt; &quot;finish adding tasks\\n&quot;; std::cout &lt;&lt; &quot;This is main thread running\\n&quot;; return 0;}","link":"/cpp/cpp-threading-pool/"},{"title":"ThreadPool 2","text":"Design a ThreadPool model with advanced features. Previously, I wrote a post that implements a simplified ThreadPool model https://chuzcjoe.github.io/2024/03/24/cpp-threading-pool/ Based on that, in this post, we will designed a more advanced one. The requirements for the new ThreadPool model: Each thread should have a unique name. Each thread should have a task queue and can handle certain number of tasks. More incoming tasks will be discarded if the queue is full. A new task will be queued based on its priority. Tasks with higher priority numbers will be executed first. A new task should have some metainfo and will be sent to the matching thread for execution. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;struct TaskInfo { std::string threadName; int priority; std::string taskType; TaskInfo(std::string threadName, int priority, std::string taskType) : threadName(std::move(threadName)), priority(priority), taskType(std::move(taskType)) {}};class Task {public: Task(TaskInfo metadata, std::function&lt;void()&gt; func) : metadata(std::move(metadata)), func(std::move(func)) {} void execute() { func(); } const TaskInfo&amp; getMetadata() const { return metadata; }private: TaskInfo metadata; std::function&lt;void()&gt; func;};struct CompareTask { bool operator()(const Task&amp; t1, const Task&amp; t2) { return t1.getMetadata().priority &lt; t2.getMetadata().priority; }};class Worker {public: Worker(std::string name, size_t maxTasks) : name(std::move(name)), maxTasks(maxTasks), shouldStop(false) {} void start() { thread = std::thread(&amp;Worker::run, this); } void stop() { { std::unique_lock&lt;std::mutex&gt; lock(mutex); shouldStop = true; } condition.notify_one(); if (thread.joinable()) { thread.join(); } } bool runTask(const Task&amp; task) { std::unique_lock&lt;std::mutex&gt; lock(mutex); if (tasks.size() &gt;= maxTasks) { std::cout &lt;&lt; &quot;Queue is full on thread: &quot; &lt;&lt; getName() &lt;&lt; '\\n'; return false; } tasks.push(task); condition.notify_one(); return true; } const std::string&amp; getName() const { return name; }private: void run() { while (true) { std::unique_lock&lt;std::mutex&gt; lock(mutex); condition.wait(lock, [this]() { return shouldStop || !tasks.empty(); }); if (shouldStop &amp;&amp; tasks.empty()) { return; } auto task = tasks.top(); tasks.pop(); lock.unlock(); task.execute(); } } std::string name; size_t maxTasks; std::thread thread; std::priority_queue&lt;Task, std::vector&lt;Task&gt;, CompareTask&gt; tasks; std::mutex mutex; std::condition_variable condition; bool shouldStop;};class ThreadPool {public: ThreadPool() {} ~ThreadPool() { for (auto&amp; [_, worker] : workers) { worker-&gt;stop(); } } void allocateThread(const std::string&amp; name, size_t maxTasks) { if (workers.find(name) != workers.end()) { std::cout &lt;&lt; &quot;Thread with this name already exists\\n&quot;; return; } auto worker = std::make_unique&lt;Worker&gt;(name, maxTasks); worker-&gt;start(); workers[name] = std::move(worker); } bool runTask(const Task&amp; task) { const std::string&amp; threadName = task.getMetadata().threadName; auto it = workers.find(threadName); if (it != workers.end()) { return it-&gt;second-&gt;runTask(task); } else { // If no matching thread, try to assign to any available worker for (auto&amp; [_, worker] : workers) { if (worker-&gt;runTask(task)) { return true; } } return false; // All queues are full } }private: std::unordered_map&lt;std::string, std::unique_ptr&lt;Worker&gt;&gt; workers;};// Example usageint main() { ThreadPool pool; // Allocating named threads with max tasks pool.allocateThread(&quot;Thread1&quot;, 5); pool.allocateThread(&quot;Thread2&quot;, 3); pool.allocateThread(&quot;Thread3&quot;, 4); // Running tasks with different priorities and metadata pool.runTask(Task(TaskInfo(&quot;Thread2&quot;, 2, &quot;TypeB&quot;), []() { std::cout &lt;&lt; &quot;Task executed on thread 2 (priority 2)\\n&quot;; })); pool.runTask(Task(TaskInfo(&quot;Thread3&quot;, 3, &quot;TypeC&quot;), []() { std::cout &lt;&lt; &quot;Task executed on thread 3 (priority 3)\\n&quot;; })); pool.runTask(Task(TaskInfo(&quot;Thread1&quot;, 1, &quot;TypeA&quot;), []() { std::cout &lt;&lt; &quot;Task executed on thread 1 (priority 1)\\n&quot;; })); // Trying to run a task on a full queue for (int i = 10; i &gt; 5; --i) { pool.runTask(Task(TaskInfo(&quot;Thread2&quot;, i, &quot;TypeB&quot;), [i]() { std::cout &lt;&lt; &quot;Task executed on Thread 2 (priority &quot; &lt;&lt; i &lt;&lt; &quot;)\\n&quot;; })); } // Allow tasks to be processed std::this_thread::sleep_for(std::chrono::seconds(2)); return 0;} 12345678Task executed on thread 3 (priority 3)Task executed on thread 1 (priority 1)Queue is full on thread: Thread2Queue is full on thread: Thread2Queue is full on thread: Thread2Task executed on Thread 2 (priority 10)Task executed on Thread 2 (priority 9)Task executed on thread 2 (priority 2)","link":"/cpp/cpp-threadpool2/"},{"title":"Revisit Static Cast and Dynamic Cast","text":"From a low level perspective. 1. Static Caststatic_cast for downcasting(cast Base to Derived) is unsafe and will cause undefined behavior. For example: 123456789101112131415class Base {public: int x;};class Derived : public Base {public: int y;};int main() { Base* bPtr = new Base{}; Derived* dPtr = static_cast&lt;Derived*&gt;(bPtr); dPtr-&gt;y = 10;} The Problem here is the object pointed to by bPtr is a Base instance, not a Derived instance. Base doesn’t have a y member, so accessing dPtr-&gt;y is undefined behavior (UB). From the memory layout perspective, Base and Derived have different structures. 123456789Base object memory layout:Address Contentb+0 x (4 bytes)Derived object memory layout:Address Contentd+0 x (inherited from Base, 4 bytes)d+4 y (4 bytes) Base* b = new Base{}; sets bPtr to the address of the Base object, e.g., 0x1000. The object at 0x1000 contains only x. Derived* dPtr = static_cast&lt;Derived*&gt;(bPtr); tells the compiler to treat the pointer bPtr as if it points to a Derived object. dPtr also points to 0x1000 Since static_cast is compile-time casting and now the compiler assumes dPtr points to a Derived object with layout {x, y}. When we do dPtr-&gt;y = 10;, the compiler knows the layout of Derived and calculates the offset of y relative to the start of a Derived object. Since x is at offset 0 (4 bytes) and y is at offset 4 (next 4 bytes), dPtr-&gt;y translates to *(dPtr + 4) (in byte terms). Writing to 0x1004 (for dPtr-&gt;y) accesses memory beyond the allocated Base object. This is undefined behavior. It is now easy to understand that upcasting using static_cast is safe since Base memory layout is part of the Derived memory layout, and there is no memory overrun issue. 2. Dynamic Castdynamic_cast can also be used for downcasting (Base to Derived). dynamic_cast relies on Run-Time Type Information (RTTI), which is implemented using vptr (virtual table pointer) and vtable in polymorphic classes. In other words, for dynamic_cast to work, the base class must have at least one virtual function. 12345678910111213141516171819class Base {public: virtual ~Base() {} // Enables RTTI};class Derived : public Base {};int main() { Base* b = new Derived(); // Upcasting Derived* d = dynamic_cast&lt;Derived*&gt;(b); // Downcasting if (d) { std::cout &lt;&lt; &quot;Cast successful\\n&quot;; } else { std::cout &lt;&lt; &quot;Cast failed!\\n&quot;; } delete b;} What happens internally when we do dynamic_cast&lt;Derived*&gt;(b) is: Since the inheritance is polymorhic, we have a vptr pointing to a vtable. Retrieve vptr from b and find the corresponding vtable. Read RTTI metadata to get type info. Check if b‘s actual type is Derived. Return a valid pointer if the retrived type matches the target cast type. We can inpsect the raw memory to verify it. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;cstdint&gt;class Base {public: virtual ~Base() {}};class Derived : public Base {};int main() { Base* b = new Derived{}; // Get vptr (first pointer in the object) uintptr_t* vptr = reinterpret_cast&lt;uintptr_t*&gt;(b); // Get vtable uintptr_t* vtable = reinterpret_cast&lt;uintptr_t*&gt;(*vptr); std::cout &lt;&lt; &quot;vtable address: &quot; &lt;&lt; vtable &lt;&lt; std::endl; // Get RTTI metadata (located before the first function pointer) std::cout &lt;&lt; &quot;RTTI address: &quot; &lt;&lt; reinterpret_cast&lt;uintptr_t*&gt;(vtable[-1]) &lt;&lt; std::endl; // Access type_info from RTTI metadata std::cout &lt;&lt; &quot;Type name: &quot; &lt;&lt; ((std::type_info*)vtable[-1])-&gt;name() &lt;&lt; std::endl; return 0;} 123vtable address: 0x5618a6a30d38RTTI address: 0x5618a6a30d58Type name: 7Derived b is indeed a Derived type, so the cast is Ok. From the analysis above, we can conclude that dynamic_cast only works when there is at least one virtual function in Base class as it relies on RTTI metadata to decide the runtime type information.","link":"/cpp/cpp-revisit-static-cast-dynamic-cast/"},{"title":"The emplace_back() Trap","text":"A not-so-obvious caveat when using emplace_back() To reproduce the issue i recently came across, here is the smallest self-contained example showing the problem. 123456789101112131415161718192021222324252627struct Sample { int value; int* alias; explicit Sample(int val = 0) : value(val), alias(&amp;value) {}};std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Sample&amp; sample) { os &lt;&lt; &quot;{ value=&quot; &lt;&lt; sample.value &lt;&lt; &quot; , alias=&quot; &lt;&lt; sample.alias &lt;&lt; &quot; , &amp;value=&quot; &lt;&lt; &amp;sample.value &lt;&lt; &quot; }&quot;; return os;}int main() { std::vector&lt;Sample&gt; vec; vec.emplace_back(1); std::cout &lt;&lt; &quot;after 1st emplace: vec[0] &quot; &lt;&lt; vec[0] &lt;&lt; &quot;\\n&quot;; // memroy reallocation vec.emplace_back(2); std::cout &lt;&lt; &quot;after 1st emplace: vec[0] &quot; &lt;&lt; vec[0] &lt;&lt; &quot;\\n&quot;; // WARNING: Dereferencing vec[0].alias here is undefined behavior. std::cout &lt;&lt; &quot;*alias = &quot; &lt;&lt; *(vec[0].alias) &lt;&lt; &quot;\\n&quot;;} output: 123after 1st emplace: vec[0] { value=1 , alias=0x5a1202d0d2b0 , &amp;value=0x5a1202d0d2b0 }after 1st emplace: vec[0] { value=1 , alias=0x5a1202d0d2b0 , &amp;value=0x5a1202d0e2e0 }*alias = -1591726835 The issue is:When calling emplace_back(), memory will be reallocated to fit more data, and elements will be copied/moved to new addresses. However, float* alias is just copied/moved as a raw address, meaning its value will not be modified. To fix this issue, we can explicitly override the default copy/move constructors that compilers generate. 12345678910111213141516171819202122232425262728293031323334353637383940414243struct Sample { int value = 0; int* alias = &amp;value; Sample() = default; explicit Sample(int v) : value(v), alias(&amp;value) {} // Rebind alias for copies Sample(const Sample&amp; rhs) : value(rhs.value), alias(&amp;value) {} Sample&amp; operator=(const Sample&amp; rhs) { value = rhs.value; alias = &amp;value; return *this; } // Rebind alias for moves Sample(Sample&amp;&amp; rhs) noexcept : value(rhs.value), alias(&amp;value) {} Sample&amp; operator=(Sample&amp;&amp; rhs) noexcept { value = rhs.value; alias = &amp;value; return *this; }};std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Sample&amp; sample) { os &lt;&lt; &quot;{ value=&quot; &lt;&lt; sample.value &lt;&lt; &quot; , alias=&quot; &lt;&lt; sample.alias &lt;&lt; &quot; , &amp;value=&quot; &lt;&lt; &amp;sample.value &lt;&lt; &quot; }&quot;; return os;}int main() { std::vector&lt;Sample&gt; vec; vec.emplace_back(1); std::cout &lt;&lt; &quot;after 1st emplace: vec[0] &quot; &lt;&lt; vec[0] &lt;&lt; &quot;\\n&quot;; // memroy reallocation vec.emplace_back(2); std::cout &lt;&lt; &quot;after 1st emplace: vec[0] &quot; &lt;&lt; vec[0] &lt;&lt; &quot;\\n&quot;; // WARNING: Dereferencing vec[0].alias here is undefined behavior. std::cout &lt;&lt; &quot;*alias = &quot; &lt;&lt; *(vec[0].alias) &lt;&lt; &quot;\\n&quot;;} output: 123after 1st emplace: vec[0] { value=1 , alias=0x5eee05be82b0 , &amp;value=0x5eee05be82b0 }after 1st emplace: vec[0] { value=1 , alias=0x5eee05be92e0 , &amp;value=0x5eee05be92e0 }*alias = 1 It’s not just emplace_back: operations such as push_back, insert, emplace, and resize can also expose the issue if they involve rearranging the container’s data.","link":"/cpp/cpp-the-emplace-back-trap/"},{"title":"Type Punning and Strict Aliasing Rule","text":"Be aware of type manipulation at low level. IntroductionModern C++ programs are expected to be both correct and fast. When it comes to type manipulation, these two goals can sometimes come into conflict. This is especially true when we engage in “type punning” – the practice of accessing memory through a different type than it was originally defined with. While type punning can be a powerful technique for certain low-level operations, it interacts with an important concept in the C++ language specification: the strict aliasing rule. Misunderstanding this relationship can lead to subtle bugs, undefined behavior, and optimization barriers. This article will help you understand: What type punning is and why it’s sometimes necessary The strict aliasing rule and its implications Safe approaches to type punning in modern C++ Common pitfalls and how to avoid them Part 1: Understanding Type PunningWhat is Type Punning?Type punning is a programming technique that involves treating data of one type as if it were another type. The term “punning” comes from the linguistic concept of using a word in a way that exploits multiple meanings – similarly, in programming, we’re using a memory location in a way that exploits multiple interpretations of its contents. Consider a simple example: 12float f = 3.14f;uint32_t bits = *reinterpret_cast&lt;uint32_t*&gt;(&amp;f); // Type punning Here, we’re taking a float value and accessing its raw memory representation as a uint32_t. This allows us to see the IEEE 754 bit pattern that represents the floating-point value. Why Use Type Punning?There are several legitimate use cases for type punning: Bit-level manipulation: Examining or modifying the binary representation of values Performance optimization: In certain scenarios, reinterpreting data can be faster than conversion Serialization/deserialization: Converting between in-memory data structures and standardized formats Memory-mapped hardware interfaces: Interacting with memory-mapped registers or specialized hardware Implementation of specialized algorithms: Such as the famous “fast inverse square root” algorithm A Historical Example: Fast Inverse Square RootOne of the most well-known examples of type punning is the “Fast Inverse Square Root” algorithm from the Quake III Arena game engine: 123456789101112131415float Q_rsqrt(float number){ long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = *reinterpret_cast&lt;long*&gt;(&amp;y); // Type punning: float bits as long i = 0x5f3759df - (i &gt;&gt; 1); // The magic happens here y = *reinterpret_cast&lt;float*&gt;(&amp;i); // Type punning: long bits as float y = y * (threehalfs - (x2 * y * y)); // Newton's method iteration return y;} This ingenious algorithm uses type punning to convert between float and integer types, allowing it to perform a numerical approximation much faster than standard methods of the time. Part 2: The Strict Aliasing RuleWhat is Strict Aliasing?The strict aliasing rule is a fundamental part of the C and C++ language standards that dictates how pointers of different types can be used to access the same memory location. In essence, the rule states: An object shall have its stored value accessed only by an lvalue expression that has one of the following types: The declared type of the object A type that is the signed or unsigned version of the declared type A type that is an aggregate or union type that includes one of the aforementioned types among its elements A character type (char, unsigned char, or std::byte) Why Does Strict Aliasing Matter?The strict aliasing rule exists to enable compiler optimizations. When the compiler can assume that objects of different types don’t refer to the same memory (don’t “alias” each other), it can perform optimizations like: Reordering memory reads and writes Caching values in registers rather than re-reading from memory Eliminating seemingly redundant loads and stores These optimizations can significantly improve performance, but they rely on the programmer following the aliasing rules. The Consequences of Violating Strict AliasingWhen you violate the strict aliasing rule, you enter the realm of undefined behavior. The compiler is free to generate code based on assumptions that your illegal aliasing violates, which can lead to: Unexpected program behavior Different results with different optimization levels Bugs that only appear in release builds Code that works on one compiler but fails on another Part 3: Type Punning Methods and SafetyLet’s examine different approaches to type punning, from the most dangerous to the safest. Method 1: Direct Casting (Unsafe)12float f = 3.14f;uint32_t bits = *reinterpret_cast&lt;uint32_t*&gt;(&amp;f); // DANGEROUS: Violates strict aliasing This approach violates strict aliasing because we’re accessing a float object through a uint32_t pointer. While it might work in practice on many compilers, it’s technically undefined behavior. Method 2: Using memcpy (Safe)123float f = 3.14f;uint32_t bits;std::memcpy(&amp;bits, &amp;f, sizeof(float)); // Safe: No aliasing violation This approach is safe because it doesn’t involve accessing the same memory through different typed pointers - it makes a copy instead. The compiler understands memcpy and can often optimize it to be as efficient as direct casting. Method 3: Using Unions (Conditionally Safe)12345678union FloatBits { float f; uint32_t bits;};FloatBits fb;fb.f = 3.14f;uint32_t bits = fb.bits; // Not guaranteed by C++ standard but widely supported The C++ standard historically didn’t guarantee this would work, though C99 explicitly allowed it. In practice, most C++ compilers support it, and C++20 has improved the situation with support for “active union members.” Method 4: Using std::bit_cast (C++20, Safe)12float f = 3.14f;uint32_t bits = std::bit_cast&lt;uint32_t&gt;(f); // Safe and elegant in C++20 std::bit_cast was introduced in C++20 specifically to provide a safe, well-defined way to perform type punning. It requires that both types have the same size and that the destination type is trivially copyable. Part 4: Common Use Cases with Safe ImplementationsExample 1: IEEE 754 Bit ManipulationLet’s say we want to extract the sign, exponent, and mantissa from a floating-point number: 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;struct IEEE754Float { uint32_t mantissa : 23; uint32_t exponent : 8; uint32_t sign : 1;};void inspectFloat(float f) { IEEE754Float parts; std::memcpy(&amp;parts, &amp;f, sizeof(float)); // Safe type punning std::cout &lt;&lt; &quot;Float value: &quot; &lt;&lt; f &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;Sign bit: &quot; &lt;&lt; parts.sign &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;Exponent: &quot; &lt;&lt; parts.exponent &lt;&lt; &quot; (bias 127: &quot; &lt;&lt; (parts.exponent - 127) &lt;&lt; &quot;)\\n&quot;; std::cout &lt;&lt; &quot;Mantissa bits: &quot; &lt;&lt; std::bitset&lt;23&gt;(parts.mantissa) &lt;&lt; &quot;\\n&quot;;} Example 2: SerializationWhen transmitting data over a network or saving to a file, we might need to convert between native types and standardized formats: 12345678910111213141516171819202122232425#include &lt;cstdint&gt;#include &lt;cstring&gt;#include &lt;vector&gt;// Convert a 32-bit integer to network byte order and add to buffervoid addInt32ToBuffer(std::vector&lt;uint8_t&gt;&amp; buffer, int32_t value) { // Convert to network byte order (big endian) uint32_t networkValue = htonl(static_cast&lt;uint32_t&gt;(value)); // Get raw bytes using safe type punning uint8_t bytes[4]; std::memcpy(bytes, &amp;networkValue, sizeof(networkValue)); // Add to buffer buffer.insert(buffer.end(), bytes, bytes + 4);}// Read a 32-bit integer from network byte orderint32_t readInt32FromBuffer(const uint8_t* buffer) { uint32_t networkValue; std::memcpy(&amp;networkValue, buffer, sizeof(uint32_t)); // Convert from network byte order (big endian) to host byte order return static_cast&lt;int32_t&gt;(ntohl(networkValue));} Part 5: Compiler-Specific ConsiderationsThe -fno-strict-aliasing OptionGCC and Clang provide a -fno-strict-aliasing compiler flag that disables optimizations based on the strict aliasing rule. While this can make unsafe type punning “work,” it’s generally better to use safe techniques than to disable important optimizations. __attribute__((may_alias)) in GCCGCC provides an attribute that can be used to indicate that a type is allowed to alias other types: 123456typedef float __attribute__((may_alias)) alias_float;void unsafe_but_marked(uint32_t* ptr) { alias_float* fptr = (alias_float*)ptr; *fptr = 3.14f; // Marked as intentionally violating strict aliasing} Microsoft Visual C++ BehaviorMSVC historically has been more lenient with aliasing violations, sometimes not performing optimizations that would break common type punning code. However, as the compiler evolves, relying on this behavior is risky. Part 6: Best Practices Prefer standard-approved methods: Use std::bit_cast in C++20 Use std::memcpy in earlier versions Document type punning clearly: Comment your code to explain why type punning is necessary Consider encapsulating punning operations in well-named functions Be aware of alignment requirements: Different types have different alignment requirements Misaligned access can cause performance penalties or hardware exceptions Consider portability concerns: Endianness differences between platforms Differences in floating-point representations Padding and alignment variations Use appropriate compiler flags during development: Enable warnings about strict aliasing violations Consider using -fstrict-aliasing to catch issues early ConclusionType punning is a powerful technique that allows programmers to manipulate data at a low level, but it must be done with care to avoid undefined behavior. The strict aliasing rule exists for good reason – it enables important compiler optimizations that improve performance. In modern C++, we have safe alternatives to traditional type punning techniques: std::bit_cast in C++20 std::memcpy in earlier versions Carefully documented union-based approaches where appropriate By understanding the relationship between type punning and strict aliasing, you can write code that is both correct and efficient, avoiding the subtle bugs that can arise from undefined behavior. Remember: just because code works doesn’t mean it’s correct. Undefined behavior might appear to work until a compiler update or optimization setting change reveals the latent bug. Stick to well-defined approaches to ensure your code remains reliable for years to come.","link":"/cpp/cpp-type-punning/"},{"title":"Performance Gains with Union","text":"The power of Unions for efficient memory usage and performance improvement. 1. Union BasicsIn C++, a union is a special data structure that allows multiple members to share the same memory location. All members of a union start at the same memory address, meaning that at any given time, only one member of the union can hold a value. This contrasts with a struct, where each member has its own memory location. The memory allocated for a union is equal to the size of its largest member, and all members share that same memory space. Only one member can hold a valid value at any time, though the union can store different types of values across its members. 2. Use CaseHere we have a typical senario where we can use union to enhance the cod efficiency. Our goal is to assign values to non-trivial types like int, float, and bool. In the less efficient implementation, we dynamically allocate memory for each data type. However, in the optimized version, we use a union to hold all the required variable types. This approach allows different types of variables to share the same memory address, eliminating redundant memory allocations. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;cstring&gt;const int numOperations = 1000000;// Without union - traditional struct approachstruct RegularData { // Pointer to hold the actual data void* value; // Constructor for int RegularData(int val) { value = new int(val); } // Constructor for float RegularData(float val) { value = new float(val); } // Constructor for bool RegularData(bool val) { value = new bool(val); } // Constructor for string RegularData(const char* val) { // Allocate memory and copy the string size_t len = std::strlen(val) + 1; // Include null terminator value = new char[len]; std::strcpy(static_cast&lt;char*&gt;(value), val); }}; // With union - optimized approachstruct OptimizedData { enum class Type {INT, FLOAT, BOOL, STRING} type; union DataUnion { // Size of largest member: 16 bytes int a; float b; bool c; char d[16]; } data; OptimizedData(int val) { data.a = val; } OptimizedData(float val) { data.b = val; } OptimizedData(bool val) { data.c = val; } OptimizedData(const char* val) { std::strncpy(data.d, val, sizeof(data.d) - 1); data.d[sizeof(data.d) - 1] = '\\0'; }};void performanceTestRegular() { std::vector&lt;RegularData&gt; data; auto start = std::chrono::high_resolution_clock::now(); // Perform operations using the union for (int i = 0; i &lt; numOperations; ++i) { switch (i % 4) { case 0: // Use int data data.emplace_back(1); break; case 1: // Use float data data.emplace_back(1.f); break; case 2: // use bool data data.emplace_back(true); break; case 3: // Use string data data.emplace_back(&quot;hello&quot;); break; default: break; } } auto end = std::chrono::high_resolution_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start); std::cout &lt;&lt; &quot;Performance Test (Regular):\\n&quot;; std::cout &lt;&lt; &quot;Time taken for &quot; &lt;&lt; numOperations &lt;&lt; &quot; operations: &quot; &lt;&lt; duration.count() &lt;&lt; &quot; milliseconds\\n&quot;;}void performanceTestOptimized() { std::vector&lt;OptimizedData&gt; data; auto start = std::chrono::high_resolution_clock::now(); // Perform operations using the union for (int i = 0; i &lt; numOperations; i++) { switch (i % 4) { case 0: // Use int data data.emplace_back(1); break; case 1: // Use float data data.emplace_back(1.f); break; case 2: // use bool data data.emplace_back(true); break; case 3: // Use string data data.emplace_back(&quot;hello&quot;); break; default: break; } } auto end = std::chrono::high_resolution_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start); std::cout &lt;&lt; &quot;Performance Test (Optimized):\\n&quot;; std::cout &lt;&lt; &quot;Time taken for &quot; &lt;&lt; numOperations &lt;&lt; &quot; operations: &quot; &lt;&lt; duration.count() &lt;&lt; &quot; milliseconds\\n&quot;;}int main() { performanceTestOptimized(); performanceTestRegular(); return 0;} 1234Performance Test (Optimized):Time taken for 1000000 operations: 74 millisecondsPerformance Test (Regular):Time taken for 1000000 operations: 96 milliseconds ~23% performance improvement by using union. 3. ConclusionThe optimized version using a union is faster because: Regular version uses new, requiring dynamic allocation on heap memory. The optimized version uses a union which pre-allocates fixed space on the stack. Heap allocations are much slower than stack operations. Dynamically allocated memory is scattered across the heap, making memory access less predictable and potentially resulting in cache misses. The optimized version stores data within the object, making it contiguous in memory and improving cache locality. In regular version, every access requires dereferencing the pointer, introducing additional overhead. Copying or moving a RegularData object involves duplicating or reassigning pointers, potentially leading to more heap operations. The union stores the data inline, so no pointer dereferencing is required. Copying or moving OptimizedData objects is more efficient because it only involves copying the fixed-size union.","link":"/cpp/cpp-union-performance-gain/"},{"title":"User-defined Types as Hash Keys in C++","text":"User-defined types can not be used as keys in containers like std::unordered_map unless we provide some extra features to them. First, we need to figure out what does hashmap do under the hood. There are two important features in hashmap structure. To find out where to put the key-value pairs in the hash table. How to tell if two keys are identical. That’s exactly what we need to provide to our user-defined types to help hash map do its work easily. Basically, We need to implement these two: A equality operator. A hash function. If we directly use struct Pointer as the key type in std::unordered_map, we will get tons of compile errors. 12345struct Point { int x, y;};std::unordered_map&lt;Point, int&gt; map; To make the Point type hashable, we need to modify the code to be: 123456789101112131415161718192021222324struct Point { int x, y; bool operator==(const Point&amp; other) const { return other.x == x &amp;&amp; other.y == y; }};template&lt;&gt;struct std::hash&lt;Point&gt; { std::size_t operator()(const Point&amp; p) const noexcept { std::size_t h1 = std::hash&lt;int&gt;{}(p.x); std::size_t h2 = std::hash&lt;int&gt;{}(p.y); return h1 ^ (h2 + 0x9e3779b97f4a7c15ULL + (h1&lt;&lt;6) + (h1&gt;&gt;2)); }};int main() { std::unordered_map&lt;Point, int&gt; map; map[{1, 2}] = 1; std::cout &lt;&lt; &quot;key: {1, 2}, value: &quot; &lt;&lt; map[{1, 2}] &lt;&lt; std::endl; map[{1, 2}] = 3; std::cout &lt;&lt; &quot;key: {1, 2}, value: &quot; &lt;&lt; map[{1, 2}] &lt;&lt; std::endl;} 1234output:key: {1, 2}, value: 1key: {1, 2}, value: 3","link":"/cpp/cpp-user-defined-types-as-hash-key/"},{"title":"Union in C++","text":"A union is a special class type that can hold only one of its non-static data members at a time. 1. IntroductionA union declaration is similar to struct/class declaration. Just like in struct declaration, the default member access in a union is public. A union can have member functions (including constructors and destructors), but not virtual functions. A union cannot have base classes and cannot be used as a base class. A union cannot have non-static data members of reference types. In a union, only one member can be activated at a time. We can only access the currently activated member. Accessing other inactivated members will have undefined behavior. 123456789101112131415161718192021222324252627282930313233343536consteval auto union_size() { union U1 { std::int32_t x; // 4 bytes std::int8_t y; // 1 bytes float z[2]; // 8 bytes }; // The whole U1 occupies 8 bytes U1 u1; u1.x = {0x12345678}; return sizeof(u1);}consteval auto union_activation() { union U2 { float i; // 4 bytes double j; // 8 bytes }; U2 u2; u2.i = {1.}; return u2.j;}int main() { [[maybe_unused]] constexpr auto a = union_size(); std::cout &lt;&lt; &quot;size of union: &quot; &lt;&lt; a &lt;&lt; '\\n'; // 8 /* Error: accessing 'union_activation()::U2::j' member instead of initialized 'union_activation()::U2::i' member in constant expression */ [[maybe_unused]] constexpr auto b = union_activation();} 2. Switch activated members2.1 Trivial typesFor trivial types, we can simply assign a new value to the member we want to activate. 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;union U { int x; float y; char z[15]; U() : x(1) {} U(float v) : y(v) {} U(const char* c) { std::strncpy(z, c, sizeof(z) - 1); z[sizeof(z) - 1] = '\\0'; } // operator overload U&amp; operator=(float v) { y = v; return *this; } U&amp; operator=(const char* c) { std::strncpy(z, c, sizeof(z) - 1); z[sizeof(z) - 1] = '\\0'; return *this; }};int main() { U u; std::cout &lt;&lt; u.x &lt;&lt; '\\n'; u = 2.; std::cout &lt;&lt; u.y &lt;&lt; '\\n'; u = &quot;hello, world&quot;; std::cout &lt;&lt; u.z &lt;&lt; '\\n';} 2.2 Non-trivial typesFor non-trivial types, we need to carefully manage the construction and destruction of the union members. This involves using placement new to construct a new member and explicitly calling the destructor of the previously active member. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;new&gt;#include &lt;string&gt;#include &lt;vector&gt;class A {public: A(int val) { x = new int{val}; std::cout &lt;&lt; &quot;A(int x) called, x = &quot; &lt;&lt; *x &lt;&lt; '\\n'; } ~A() { delete x; x = nullptr; std::cout &lt;&lt; &quot;~A() called\\n&quot;; } void print() const { std::cout &lt;&lt; &quot;print x = &quot; &lt;&lt; *x &lt;&lt; '\\n'; }private: int* x;};union U { std::vector&lt;int&gt; vec; std::string str; A a; // Constructor U() { std::cout &lt;&lt; &quot;U()\\n&quot;; } // Destructor ~U() { std::cout &lt;&lt; &quot;~U()\\n&quot;; }};int main() { U u; // Initialize std::vector&lt;int&gt; new (&amp;u.vec) std::vector&lt;int&gt;({1, 2, 3}); std::cout &lt;&lt; &quot;Vector content: &quot;; for (int i : u.vec) { std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; u.vec.~vector&lt;int&gt;(); // Explicitly call the destructor // Switch to std::string new (&amp;u.str) std::string{&quot;Hello, Union&quot;}; std::cout &lt;&lt; &quot;String content: &quot; &lt;&lt; u.str &lt;&lt; std::endl; u.str.~basic_string(); // Explicitly call the destructor // Switch to CustomClass new (&amp;u.a) A(3); u.a.print(); u.a.~A(); // Explicitly call the destructor return 0;} 1234567U()Vector content: 1 2 3 String content: Hello, UnionA(int x) called, x = 3print x = 3~A() called~U() 3. Anonymous unionsAn anonymous union is a union without a name. Anonymous unions allow you to define a union directly within a class or a struct, and their members are accessed as if they are members of the enclosing class or struct. This feature can simplify the code by avoiding the need to explicitly refer to the union name when accessing its members. 123456789101112131415161718192021222324252627282930313233343536373839struct A { enum class Tag { CHAR, INT, DOUBLE } tag; // Anonymous union union { char c; int i; double d; };};void print(const A&amp; a) { switch(a.tag) { case A::Tag::CHAR: std::cout &lt;&lt; a.c &lt;&lt; '\\n'; break; case A::Tag::INT: std::cout &lt;&lt; a.i &lt;&lt; '\\n'; break; case A::Tag::DOUBLE: std::cout &lt;&lt; a.d &lt;&lt; '\\n'; break; default: break; }}int main() { A a{A::Tag::CHAR, 'A'}; print(a); a.tag = A::Tag::INT; a.i = 1; print(a); a.tag = A::Tag::DOUBLE; a.d = 3.; print(a);} Some limitations of anonymous unions. Cannot have member functions. All members must be public, no access specifiers. Cannot have static members. The types contained within the anonymous union must be trivially constructible, trivially destructible. Ambiguity with local vaiables sharing the same name. References https://en.cppreference.com/w/cpp/language/union","link":"/cpp/cpp-union/"},{"title":"Virtual destructor","text":"Virtual destructor is used to prevent memory leak in the context of polymorphism. Let’s start with a simple example. 12345678910111213141516171819202122232425262728293031class Base {public: Base() { std::cout &lt;&lt; &quot;Base constructor called\\n&quot;; } ~Base() { std::cout &lt;&lt; &quot;Base deconstructor called\\n&quot;; }};class Derived : public Base {public: Derived() { std::cout &lt;&lt; &quot;Derived constructor called\\n&quot;; } ~Derived() { std::cout &lt;&lt; &quot;Derived deconstructor called\\n&quot;; }};int main() { Base* b = new Base(); delete b; std::cout &lt;&lt; &quot;----------\\n&quot;; Derived* d = new Derived(); delete d;} output: 1234567Base constructor calledBase deconstructor called----------Base constructor calledDerived constructor calledDerived deconstructor calledBase deconstructor called When we define a Base type pointer and the pointer points to Derived, things are different. The ~Derived() is not called. 1234567891011121314151617181920212223242526class Base {public: Base() { std::cout &lt;&lt; &quot;Base constructor called\\n&quot;; } ~Base() { std::cout &lt;&lt; &quot;Base deconstructor called\\n&quot;; }};class Derived : public Base {public: Derived() { std::cout &lt;&lt; &quot;Derived constructor called\\n&quot;; } ~Derived() { std::cout &lt;&lt; &quot;Derived deconstructor called\\n&quot;; }};int main() { Base* b = new Derived(); delete b;} output: 123Base constructor calledDerived constructor calledBase deconstructor called This is when we might have memory leak in C++. Suppose we have data created in Derived, the destructor is responsible for cleaning up the memeory, however, it never gets called. 123456789101112131415161718192021222324252627282930class Base {public: Base() { std::cout &lt;&lt; &quot;Base constructor called\\n&quot;; } ~Base() { std::cout &lt;&lt; &quot;Base deconstructor called\\n&quot;; }};class Derived : public Base {private: int* m_data;public: Derived() { m_data = new int[5]; std::cout &lt;&lt; &quot;Derived constructor called\\n&quot;; } ~Derived() { std::cout &lt;&lt; &quot;Derived deconstructor called\\n&quot;; delete[] m_data; }};int main() { Base* b = new Derived(); delete b;} All we need to do is to make Base destructor virtual. That will fix this problem. 123456789101112131415161718192021222324252627282930class Base {public: Base() { std::cout &lt;&lt; &quot;Base constructor called\\n&quot;; } virtual ~Base() { std::cout &lt;&lt; &quot;Base deconstructor called\\n&quot;; }};class Derived : public Base {private: int* m_data;public: Derived() { m_data = new int[5]; std::cout &lt;&lt; &quot;Derived constructor called\\n&quot;; } ~Derived() { std::cout &lt;&lt; &quot;Derived deconstructor called\\n&quot;; delete[] m_data; }};int main() { Base* b = new Derived(); delete b;} output: 1234Base constructor calledDerived constructor calledDerived deconstructor calledBase deconstructor called References https://www.geeksforgeeks.org/virtual-destructor/","link":"/cpp/cpp-virtual-destructor/"},{"title":"Virtual Functions in Constructor and Descturctor","text":"What is the behavior of invoking virtual functions from constructors or destructors? You should avoid invoking virtual functions from constructors or destructors. 1. BehaviorInvoking virtual functions from constructors and destructors will restrict the dynamic dispatch. 123456789101112131415161718192021222324252627282930313233class Base {public: Base() { init(); } virtual ~Base() { release(); } virtual void init() { std::cout &lt;&lt; &quot;Base::init()\\n&quot;; } virtual void release() { std::cout &lt;&lt; &quot;Base::release()\\n&quot;; }};class Derived : public Base {public: Derived() {} ~Derived() {} virtual void init() override { std::cout &lt;&lt; &quot;Derived::init()\\n&quot;; } virtual void release() override { std::cout &lt;&lt; &quot;Derived::release()\\n&quot;; }};int main() { Base* b = new Derived; delete b;} 12Base::init()Base::release() The core reason C++ disables dynamic dispatch in constructors and destructors is safety—to avoid invoking virtual functions on an incompletely constructed or already partially destroyed object, which would lead to undefined behavior. References https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP50-CPP.+Do+not+invoke+virtual+functions+from+constructors+or+destructors","link":"/cpp/cpp-virtual-function-in-constructor-and-destructor/"},{"title":"Variable Template","text":"Since C++14 1. IntroductionVariable templates in C++ are a feature introduced in C++14 that allows you to define a variable that is parameterized by one or more template parameters. This is similar to how you define template functions or classes, but for variables. Variable templates can be useful for defining constants or other variables that need to vary based on the type or other template parameters. 2. A Starter Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;template&lt;typename T&gt;constexpr T pi = T(3.1415926535897932385L); // variable template // function templatetemplate&lt;typename T&gt;T circular_area(T r) { return pi&lt;T&gt; * r * r; // pi&lt;T&gt; is a variable template instantiation}int main() { std::cout &lt;&lt; &quot;circular_area&lt;int&gt;(1) = &quot; &lt;&lt; circular_area&lt;int&gt;(1) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;circular_area&lt;float&gt;(1.) = &quot; &lt;&lt; circular_area&lt;float&gt;(1.) &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;circular_area&lt;double&gt;(1.) = &quot; &lt;&lt; circular_area&lt;double&gt;(1.) &lt;&lt; '\\n';} 123circular_area&lt;int&gt;(1) = 3circular_area&lt;float&gt;(1.) = 3.14159circular_area&lt;double&gt;(1.) = 3.14159 3. In Class ScopeWhen used within class scope, variable templates usually declare as static. 1234567891011121314template&lt;typename T&gt;class MathConstants {public: static constexpr T pi = T(3.1415926535897932385); static constexpr T e = T(2.7182818284590452353); template&lt;int N&gt; static constexpr T power_of_two = T(1 &lt;&lt; N);};// Usagedouble pi_value = MathConstants&lt;double&gt;::pi;float e_value = MathConstants&lt;float&gt;::e;int eight = MathConstants&lt;int&gt;::power_of_two&lt;3&gt;; 4. Fibonacci Using Variable Template12345678910template&lt;int N&gt;constexpr int fibonacci = fibonacci&lt;N-1&gt; + fibonacci&lt;N-2&gt;;// specialized template for base case 0template&lt;&gt;constexpr int fibonacci&lt;0&gt; = 0;// specialized template for base case 1template&lt;&gt;constexpr int fibonacci&lt;1&gt; = 1; References https://en.cppreference.com/w/cpp/language/variable_template","link":"/cpp/cpp-variable-template/"},{"title":"Virtual Function","text":"Virtual function, pure virtual function, abstract class Virtual functionA virtual function is a member function in the base class that we expect to redefine in derived classes. override identifier is not necessary but highly recommended to use to avoid bugs. When using override, the compiler will display related error messages when bugs exists. For examples: Functions with incorrect names Functions with different return types Functions with different parameters 123456789101112131415161718192021222324class Base {public: Base() {} virtual void print() { std::cout &lt;&lt; &quot;Base print()\\n&quot;; }};class Derived : public Base {public: Derived() {} void print() override { std::cout &lt;&lt; &quot;Derived print()\\n&quot;; }};int main() { Base* b = new Derived(); b-&gt;print(); // Derived print() delete b;} One thing to note is that, the Derived class does not have to implement a virtual function defined in Base class. The following example also works. 123456789101112131415161718192021222324class Base {public: Base() {} virtual void print() { std::cout &lt;&lt; &quot;Base print()\\n&quot;; }};class Derived : public Base {public: Derived() {} // void print() override{ // std::cout &lt;&lt; &quot;Derived print()\\n&quot;; // }};int main() { Base* b = new Derived(); b-&gt;print(); // Base print() delete b;} You may hear of another terminology called dynamic dispatch. By declaring a method as virtual, the C++ compiler uses a vtable to define the name-to-implementation mapping for a given class as a set of member function pointers. However, one can use explicit scoping, rather than dynamic dispatch, to ensure a specific version of a function is called. 1234567891011121314151617181920212223242526272829303132333435class Base {public: Base() { std::cout &lt;&lt; &quot;Base constructor called\\n&quot;; } virtual void foo() { std::cout &lt;&lt; &quot;Base foo()\\n&quot;; } virtual ~Base() { std::cout &lt;&lt; &quot;Base deconstructor called\\n&quot;; }};class Derived : public Base {public: Derived() { std::cout &lt;&lt; &quot;Derived constructor called\\n&quot;; } void foo() override { std::cout &lt;&lt; &quot;Derived foo()\\n&quot;; } ~Derived() { std::cout &lt;&lt; &quot;Derived deconstructor called\\n&quot;; }};int main() { Base* b = new Derived(); b-&gt;Base::foo(); delete b;} 12345Base constructor calledDerived constructor calledBase foo()Derived deconstructor calledBase deconstructor called Pure virtual functionA pure virtual function is a function defined in base class but has no implementation. It requires its derived classes to implement their own versions of this function. A class containing pure virtual function(s) is called abstract class. 123456class Base {public: Base() {} virtual void print() = 0; // pure virtual function}; A abstract class can not be instantiate. If the derived class does not implement the pure virtual function, it makes the derived class an abstract class as well. We can neither instantiate the derived class. 12345678910111213141516class Base {public: Base() {} virtual void print() = 0;};class Derived : public Base {public: Derived() {}};int main() { Base b; // Error Derived d; // Error} Abstract class can have its own constructor. 1234567891011121314151617181920212223242526272829303132class Base {protected: int m_x;public: Base(int x) : m_x(x) {} virtual void print() = 0;};class Derived : public Base {private: int m_y;public: Derived(int x, int y) : Base(x) { m_y = y; } void print() override { std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; m_x &lt;&lt; &quot; &quot; &lt;&lt; &quot;y: &quot; &lt;&lt; m_y &lt;&lt; std::endl; }};int main() { Base* d1 = new Derived(1, 2); Base* d2 = new Derived(2, 1); d1-&gt;print(); // x: 1 y: 2 d2-&gt;print(); // x: 2 y: 1 delete d1; delete d2;} References https://www.programiz.com/cpp-programming/virtual-functions https://www.geeksforgeeks.org/pure-virtual-functions-and-abstract-classes/","link":"/cpp/cpp-virtual-function/"},{"title":"Virtual Inheritance","text":"Solve diamond problem. 1. IntroductionVirtual inheritance is used to solve the diamond problem in multiple inheritance. A typical diamond problem is: when a class inherits two classes that both inherit from a common base class. Without the virtual inheritance, the common base class is duplicated, causing compiler ambiguity when accessing base class members or functions. 12345678(left) without virtual inheritance(right) with virtual inheritance A A A | | / \\ B C B C \\ / \\ / D D 2. Examples2.1 Without virtual inheritanceWe keep two instances of base class A. To avoid compiler ambiguity, we need to use scope resolution operator(::) to access a specific instance of A. 12345678910111213141516171819202122232425class A {public: int value = 0;};class B : public A {};class C : public A {};class D : public B, public C {};int main() { D obj; // obj.value; // Error: ambiguous access obj.B::value = 1; // Access value through B's A obj.C::value = 2; // Access value through C's A std::cout &lt;&lt; &quot;obj.B::value: &quot; &lt;&lt; obj.B::value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;obj.C::value: &quot; &lt;&lt; obj.C::value &lt;&lt; std::endl; return 0;} 2.2 With virtual inheritanceVirtual inheritance ensures that there is only one instance of the common base class, shared by all derived classes. A virtual base pointer (vptr) is used to point to the shared instance of the base class. 1234567891011121314151617181920212223class A {public: int value = 0;};class B : virtual public A {};class C : virtual public A {};class D : public B, public C {};int main() { D obj; obj.value = 1; std::cout &lt;&lt; &quot;obj.value: &quot; &lt;&lt; obj.value &lt;&lt; std::endl; obj.value = 2; std::cout &lt;&lt; &quot;obj.value: &quot; &lt;&lt; obj.value &lt;&lt; std::endl; return 0;} 2.3 Contructor initializationWhen using virtual inheritance, the most derived class is responsible for initializing the base class. 12345678910111213141516171819202122232425262728293031323334class A {public: int value; A(int val) : value(val) { std::cout &lt;&lt; &quot;A(int) called with val = &quot; &lt;&lt; val &lt;&lt; std::endl; }};class B : virtual public A {public: B() : A(0) { // Provide a default value to A std::cout &lt;&lt; &quot;B() called&quot; &lt;&lt; std::endl; }};class C : virtual public A {public: C() : A(0) { // Provide a default value to A std::cout &lt;&lt; &quot;C() called&quot; &lt;&lt; std::endl; }};class D : public B, public C {public: D(int val) : A(val), B(), C() { // Initialize A with a specific value std::cout &lt;&lt; &quot;D(int) called with val = &quot; &lt;&lt; val &lt;&lt; std::endl; }};int main() { D obj(5); std::cout &lt;&lt; &quot;obj.value: &quot; &lt;&lt; obj.value &lt;&lt; std::endl; return 0;} 12345A(int) called with val = 5B() calledC() calledD(int) called with val = 5obj.value: 5","link":"/cpp/cpp-virtual-inheritance/"},{"title":"Volatile in C++","text":"Understand volatile from assembly perspective. 1. IntroductionWhen we declare a variable as volatile, it indicates that its value might be altered by external factors such as hardware, other threads, or signal handlers. A volatile variable cannot be optimized by the compiler, ensuring that the only way to obtain its value is by accessing its memory address directly. 2. ExamplesLet’s try a simple example first and optimize it with -O3 option. C++ 12345int main() { int age = 1; age = 2; return 0;} Assembly 123main: xor eax, eax ret Since -O3 perform aggresive optimization and the compiler recognizes that age is only assigned and reassigned within the scope of main, and its value is never used afterward. Therefore, both the initial and subsequent assignments to age are redundant. The optimized code will eliminate the age variable entirely. But when we declare age as volatile. C++ 12345int main() { volatile int age = 1; age = 2; return 0;} Assembly 12345main: mov DWORD PTR [rsp-4], 1 xor eax, eax mov DWORD PTR [rsp-4], 2 ret Any modification to a volatile variable directly accesses its memory address. The compiler does not optimize volatile variables.","link":"/cpp/cpp-volatile/"},{"title":"Vtable Hack","text":"Exploring vtable internals. 1. IntroductionIn C++, the virtual table (vtable) is an implementation detail used by compilers to support dynamic polymorphism through virtual functions. In one of my previous blogs, we discussed about how vptr and vtable work to achieve dynamic polymorphism. In short, each derived object has a hidden virtual table pointer that points to a vtable. Vtable is just an array of function pointers. The C++ standard doesn’t expose the vtable or vptr as part of the language. Its layout and existence depend on the compiler (e.g., GCC, MSVC, Clang) and platform. We can approximate access to the vtable by dereferencing the vptr manually, but this is undefined behavior in strict C++ terms and should only be done for learning or debugging purposes. vptr Location: The vptr is typically the first hidden member of the object (on most compilers like GCC and MSVC), but this isn’t guaranteed by the standard. vtable Layout: The vtable is an array of function pointers. The order corresponds to the declaration order of virtual functions, but again, this is compiler-specific. 2. Access Vptr and Vtable123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;class Base {public: virtual void func1() { std::cout &lt;&lt; &quot;Base::func1\\n&quot;; } virtual void func2() { std::cout &lt;&lt; &quot;Base::func2\\n&quot;; }};class Derived : public Base {public: void func1() override { std::cout &lt;&lt; &quot;Derived::func1\\n&quot;; } void func2() override { std::cout &lt;&lt; &quot;Derived::func2\\n&quot;; }};int main() { Base* obj = new Derived(); // Polymorphic object // Step 1: Get the vptr (assumes it's the first hidden member) uintptr_t* vptr = reinterpret_cast&lt;uintptr_t*&gt;(obj); // Step 2: Dereference vptr to get the vtable address uintptr_t* vtable = reinterpret_cast&lt;uintptr_t*&gt;(*vptr); // Step 3: Access function pointers from the vtable // (Assuming func1 is at index 0, func2 at index 1) using FuncPtr = void (*)(); FuncPtr f1 = reinterpret_cast&lt;FuncPtr&gt;(vtable[0]); FuncPtr f2 = reinterpret_cast&lt;FuncPtr&gt;(vtable[1]); // Step 4: Call the functions f1(); // Should call Derived::func1 f2(); // Should call Derived::func2 delete obj; return 0;}","link":"/cpp/cpp-vtable-hack/"},{"title":"push_back() vs emplace_back()","text":"why we use emplace_back()? When should we use emplace_back()? Let’s first define our class 12345678910111213141516171819202122class Base {public: Base(int id, const string&amp; name) : m_id(id), m_name(name) { cout &lt;&lt; &quot;Base(int, string&amp;)\\n&quot;; } Base(const Base&amp; obj): m_id(obj.m_id), m_name(obj.m_name) { cout &lt;&lt; &quot;Base(const Base&amp;)\\n&quot;; } Base(Base&amp;&amp; obj) : m_id(obj.m_id), m_name(move(obj.m_name)) { cout &lt;&lt; &quot;Base(Base&amp;&amp;)\\n&quot;; } ~Base() { cout &lt;&lt; &quot;~Base()\\n&quot;; }private: int m_id; string m_name;}; Let’s take a look at example 1Call basic constructor. 123456789101112131415int main() { Base b1(0, &quot;Joe&quot;); cout &lt;&lt; &quot;---------push_back()\\n&quot;; vector&lt;Base&gt; vec1; vec1.push_back(b1); // Base(const Base&amp;) cout &lt;&lt; &quot;---------emplace_back()\\n&quot;; vector&lt;Base&gt; vec2; vec2.emplace_back(b1); // Base(const Base&amp;) cout &lt;&lt; &quot;---------finish\\n&quot;; return 0;} example 2Use std::move() semantic to make Base objects rvalues. 12345678910111213141516int main() { Base b1(0, &quot;Joe&quot;); Base b2(0, &quot;Jack&quot;); cout &lt;&lt; &quot;---------push_back()\\n&quot;; vector&lt;Base&gt; vec1; vec1.push_back(move(b1)); // Base(Base&amp;&amp;) cout &lt;&lt; &quot;---------emplace_back()\\n&quot;; vector&lt;Base&gt; vec2; vec2.emplace_back(move(b2)); // Base(Base&amp;&amp;) cout &lt;&lt; &quot;---------finish\\n&quot;; return 0;} example 3Create class objects in-place. 12345678910111213int main() { cout &lt;&lt; &quot;---------push_back()\\n&quot;; vector&lt;Base&gt; vec1; vec1.push_back(Base(0, &quot;Joe&quot;)); // Base(int, string&amp;) Base(Base&amp;&amp;) ~Base() cout &lt;&lt; &quot;---------emplace_back()\\n&quot;; vector&lt;Base&gt; vec2; vec2.emplace_back(Base(1, &quot;Jack&quot;)); // Base(int, string&amp;) Base(Base&amp;&amp;) ~Base() cout &lt;&lt; &quot;---------finish\\n&quot;; return 0;} Explain: Base(0, “Joe”) creates a temporary class instance. After it is being used, it get deleted. example 5Emplace_back() creates an object instance directly on the stack. Skip the temporary creation. 12345678910111213int main() { cout &lt;&lt; &quot;---------push_back()\\n&quot;; vector&lt;Base&gt; vec1; vec1.push_back(Base(0, &quot;Joe&quot;)); // Base(int, string&amp;) Base(Base&amp;&amp;) ~Base() cout &lt;&lt; &quot;---------emplace_back()\\n&quot;; vector&lt;Base&gt; vec2; vec2.emplace_back(1, &quot;Jack&quot;); // Base(int, string&amp;) cout &lt;&lt; &quot;---------finish\\n&quot;; return 0;} ConclusionIn the majority of cases, they are interchangeable. However, emplace_back() is more efficient when constructing objects directly within the container.","link":"/cpp/emplace-back/"},{"title":"C++20 new feature - std::span","text":"std::span was introduced as a new feature in C++20 std::span provides an efficient way to view a contiguous sequence of objects. span class is defined as below 1234template&lt; class T, std::size_t Extent = std::dynamic_extent&gt; class span; syntax1std::span&lt;type&gt; span_name; usage12345678//1. from an arraystd::span&lt;float&gt; name(array);//2. from a vectorstd::span&lt;float&gt; name(vector);//1. from a stringstd::span&lt;char&gt; name(string); more member functions data(): A pointer to the first element of the sequence. size(): Returns the size of the sequence that is the number of elements in the sequence. empty(): Returns a boolean value that indicates whether the sequence is empty. front(): A reference to the first element of the sequence. back(): A reference to the last element of the sequence. operator[]: An accessor that returns a reference to the element at the specified index. at(): An accessor that returns a reference to the element at the specified index, throwing an exception if the index is out of bounds. begin(): A function that returns an iterator to the beginning of the sequence. end(): A function that returns an iterator to the end of the sequence. example123456789101112131415161718#include &lt;iostream&gt; #include &lt;span&gt; using namespace std; int main() { std::vector&lt;int&gt; vec = { 1, 2, 3, 4, 5 }; span&lt;int&gt; span_vec(vec); for (const auto&amp; num : span_vec) { cout &lt;&lt; num &lt;&lt; &quot; &quot;; } return 0; }// output// 1 2 3 4 5 motivations for using std::span Non-owning View: std::span does not own the data it points to. It simply provides a view over an existing sequence, allowing you to work with the data without creating a copy. This can improve performance and memory efficiency, especially when dealing with large amounts of data. Safety: When you use std::span, you can perform bounds checking and ensure that you do not inadvertently access elements beyond the bounds of the underlying data. Slicing: You can create sub-spans from an existing std::span, allowing you to work with specific portions of the data. This can be useful when you want to process only a part of a larger data set. references https://www.geeksforgeeks.org/cpp-20-std-span/ https://en.cppreference.com/w/cpp/container/span","link":"/cpp/cpp20span/"},{"title":"C++ Cheat Sheet","text":"Great quick reference for C++ STL C++ Cheat Sheets","link":"/cpp/cppstlcheatsheet/"},{"title":"Vtable in C++","text":"Also known as virtual function table, dispatch table. IntroductionA virtual table is a static array that contains entries for each virtual function. Each entry is a function pointer that points to the most-derived function. For classes that have virtual functions, a hidden pointer will be added as a member of that class (*__vptr) ExampleFor the following example, a diagram indicating different vtables of each class can be shown below. Each *__vptr points to a vtable belongs to a class. Since foo1() is overriden by D1 and foo2() is overriden by D2, D1 vatble and D2 vtable will be updated during compile time, and foo1() in D1 now points to D1::foo1(), foo2() in D2 points to D2::foo2(). However, since D1 didn’t implement foo2(), foo2() in D1 vtable still points to Base::foo2(). Same for foo1() in D2. 123456789101112131415161718192021222324252627282930313233343536class Base{public: virtual void foo1() { std::cout &lt;&lt; &quot;Base foo1()\\n&quot;; } virtual void foo2() { std::cout &lt;&lt; &quot;Base foo2()\\n&quot;; }};class D1: public Base{public: void foo1() override { std::cout &lt;&lt; &quot;D1 foo1()\\n&quot;; }};class D2: public Base{public: void foo2() override { std::cout &lt;&lt; &quot;D2 foo2()\\n&quot;; }};int main() { Base* b1 = new D1; Base* b2 = new D2; b1-&gt;foo1(); b2-&gt;foo2(); delete b1; delete b2;} 12D1 foo1()D2 foo2() References https://www.learncpp.com/cpp-tutorial/the-virtual-table/","link":"/cpp/cpp-vtable/"},{"title":"halloween","text":"坐标： Fremont家小区 终于切身体验了一把传统美国人的万圣节了, 热闹程度堪比国内过年！","link":"/life/halloween/"},{"title":"一年一度的万圣节","text":"今年精心装扮的还是那几户人家","link":"/life/life-2024-Halloween/"},{"title":"2025生日","text":"记录下每年生日 去年生日写的生日薅羊毛的blog含金量还在上升 https://chuzcjoe.github.io/life/life-birthday-rewards/ 有很多东西去年薅了之后发现并不好吃，今年就只拿了一些好吃/喝的，分别有： 星巴克 Panera Bread一份pastry 麦当劳 Buffalo鸡翅 孩子妈妈中午下厨给做了自制越南粉+越南春卷 👍 下午带上吃的，带娃去公园野餐","link":"/life/life-2025-birthday/"},{"title":"Lambda expression","text":"An introduction of Lambda expression in C++ Lambda expression is introduced in C++11. The purpose is to use a function without explicitly defining a function. Syntax1234[ capture clause ] (parameters) -&gt; return-type { definition of method }; example 1123456789101112131415int main() { std::vector&lt;int&gt; vec = {8, 3, 10, 1, 2}; // sort in descending order std::sort(vec.begin(), vec.end(), [](const auto&amp; a, const auto&amp; b){ return a &gt;= b; }); for (const auto&amp; num : vec) { std::cout &lt;&lt; num &lt;&lt; &quot; \\n&quot;; }}// output// 10 8 3 2 1 example 2Lambda expression can access external variables by []. There are 3 ways to capture variables. [&amp;]: capture all external variables by reference. [=]: capture all external variables by value. [a, &amp;b]: capture a by value and b by reference. []: an empty [] can access local variables. 123456789101112131415161718192021222324252627282930int main() { std::vector&lt;int&gt; vec = {8, 3, 10, 1, 2}; // access vec by reference auto print1 = [&amp;]() { for (const auto v : vec) std::cout &lt;&lt; v &lt;&lt; &quot; &quot;; }; print1(); // 8 3 10 1 2 std::cout &lt;&lt; &quot;\\n&quot;; // access vec by value auto print2 = [vec]() { for (const auto v : vec) std::cout &lt;&lt; v &lt;&lt; &quot; &quot;; }; print2(); // 8 3 10 1 2 std::cout &lt;&lt; &quot;\\n&quot;; int N = 5; // access N by value vector&lt;int&gt;:: iterator p = find_if(vec.begin(), vec.end(), [&amp;N](const auto&amp; num) { return num &gt; N; }); std::cout &lt;&lt; &quot;first value greater than &quot; &lt;&lt; N &lt;&lt; &quot;: &quot; &lt;&lt; *p &lt;&lt; std::endl; // first value greater than 5: 8} example 3Pass lambda expressions to a function. 1234567891011121314151617181920int performOperation(int x, int y, std::function&lt;int(int, int)&gt; op) { return op(x, y);}int main() { auto add = [](int x, int y) -&gt; int { return x+y; }; auto multiply = [](int x, int y) -&gt; int { return x*y; }; // pass lambda expression as function parameter int result1 = performOperation(5, 3, add); int result2 = performOperation(5, 3, multiply); std::cout &lt;&lt; &quot;Result of addition: &quot; &lt;&lt; result1 &lt;&lt; std::endl; // Result of addition: 8 std::cout &lt;&lt; &quot;Result of multiplication: &quot; &lt;&lt; result2 &lt;&lt; std::endl; // Result of multiplication: 15} example 4Use lambda expression in a class. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Calculator {public: // Constructor Calculator() { // Define lambda expressions for different operations add = [](int x, int y) -&gt; int { return x + y; }; subtract = [](int x, int y) -&gt; int { return x - y; }; multiply = [](int x, int y) -&gt; int { return x * y; }; divide = [](int x, int y) -&gt; int { if (y != 0) { return x / y; } else { std::cerr &lt;&lt; &quot;Error: Division by zero!&quot; &lt;&lt; std::endl; return 0; } }; } // Perform addition using the add lambda expression int performAddition(int a, int b) { return add(a, b); } // Perform subtraction using the subtract lambda expression int performSubtraction(int a, int b) { return subtract(a, b); } // Perform multiplication using the multiply lambda expression int performMultiplication(int a, int b) { return multiply(a, b); } // Perform division using the divide lambda expression int performDivision(int a, int b) { return divide(a, b); }private: // Lambda expressions for different operations std::function&lt;int(int, int)&gt; add; std::function&lt;int(int, int)&gt; subtract; std::function&lt;int(int, int)&gt; multiply; std::function&lt;int(int, int)&gt; divide;};int main() { Calculator calculator; int a = 10; int b = 5; std::cout &lt;&lt; &quot;Addition: &quot; &lt;&lt; calculator.performAddition(a, b) &lt;&lt; std::endl; // Addition: 15 std::cout &lt;&lt; &quot;Subtraction: &quot; &lt;&lt; calculator.performSubtraction(a, b) &lt;&lt; std::endl; // Subtraction: 5 std::cout &lt;&lt; &quot;Multiplication: &quot; &lt;&lt; calculator.performMultiplication(a, b) &lt;&lt; std::endl; // Multiplication: 50 std::cout &lt;&lt; &quot;Division: &quot; &lt;&lt; calculator.performDivision(a, b) &lt;&lt; std::endl; // Division: 2 return 0;} References https://www.geeksforgeeks.org/lambda-expression-in-c/ https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170","link":"/cpp/lambdaExpressionCPP/"},{"title":"Father&#39;s Day","text":"收获一份来自幼儿园的礼物","link":"/life/life-2025-father-day/"},{"title":"Oahu Hawaii","text":"2022圣诞假期trip ./u","link":"/life/life-Oahu-Hawaii/"},{"title":"宝宝七个月了","text":"七月打卡 Image Slideshow ❮ ❯ #slideshow-container { display: flex; justify-content: center; align-items: center; min-height: 400px; padding: 20px; } .frame { position: relative; padding: 15px; background: white; box-shadow: 0 0 15px rgba(0,0,0,0.1); border-radius: 5px; } #slideshow { max-width: 600px; height: auto; display: block; border-radius: 2px; opacity: 1; transition: opacity 0.5s ease-in-out; } .nav-btn { position: absolute; top: 50%; transform: translateY(-50%); background: rgba(0, 0, 0, 0.5); color: white; padding: 16px 12px; border: none; cursor: pointer; border-radius: 4px; font-size: 18px; transition: background 0.3s; } .nav-btn:hover { background: rgba(0, 0, 0, 0.8); } .prev-btn { left: 25px; } .next-btn { right: 25px; } .slide-number { position: absolute; bottom: 25px; right: 25px; background: rgba(0, 0, 0, 0.5); color: white; padding: 8px 12px; border-radius: 4px; font-size: 14px; } #slideshow.fade-out { opacity: 0; } const images = [ '0.jpg', '1.jpg', '3.jpg', '4.jpg' // Add more image paths as needed ]; let currentImageIndex = 0; const slideshowElement = document.getElementById('slideshow'); const slideNumberElement = document.querySelector('.slide-number'); function updateSlideNumber() { slideNumberElement.textContent = `${currentImageIndex + 1} / ${images.length}`; } function showImage(index) { slideshowElement.classList.add('fade-out'); setTimeout(() => { slideshowElement.src = images[index]; slideshowElement.classList.remove('fade-out'); updateSlideNumber(); }, 500); } function showNextImage() { currentImageIndex = (currentImageIndex + 1) % images.length; showImage(currentImageIndex); } function showPrevImage() { currentImageIndex = (currentImageIndex - 1 + images.length) % images.length; showImage(currentImageIndex); } // Handle keyboard navigation document.addEventListener('keydown', (e) => { if (e.key === 'ArrowLeft') { showPrevImage(); } else if (e.key === 'ArrowRight') { showNextImage(); } }); // Initial load slideshowElement.src = images[0]; updateSlideNumber();","link":"/life/life-7month-baby/"},{"title":"Lakeshore Park in Newark","text":"Newark一个宝藏的湖边公园 地址：5119 Ipswich Ct, Newark, CA 94560 环境挺好，路也是铺好的适合推车遛娃，景色十分出片。唯一的缺点就是路上的鸭屎太多，我们的婴儿车轮子上遛完一圈全是屎，走之前用光了一包湿纸巾才擦干净。","link":"/life/life-Lakeshore-Park-newark/"},{"title":"Alviso Marina County Park","text":"圣何塞北部的粉色盐湖 本来以为四点多到，天有点黑，会影响观感，没想到夕阳的衬托格外美","link":"/life/life-alviso-marina-county-park/"},{"title":"Ardenwood Farm","text":"第二次来Ardenwood farm，原因是里面的小火车营业了。","link":"/life/life-ardenwood-farm-train/"},{"title":"Ardenwood Historic Farm","text":"Fremont的一个小农场，适合周末亲子游 地址：34600 Ardenwood Blvd, Fremont, CA 94555门票：$4","link":"/life/life-ardenwood-historic-farm/"},{"title":"十月龄","text":"过去一个月会自己扶着站起来，稍微把着能自己走路","link":"/life/life-baby-10-month/"},{"title":"晒娃日常","text":"近期(2-3个月)合集","link":"/life/life-baby-2-to-3-month/"},{"title":"宝宝二月打卡","text":"那些成长的瞬间","link":"/life/life-baby-2month/"},{"title":"宝宝四个月","text":"四个月打卡","link":"/life/life-baby-4months/"},{"title":"宝宝五个月","text":"打卡留念","link":"/life/life-baby-5month/"},{"title":"宝宝三月打卡","text":"时间过得好快","link":"/life/life-baby-3-month/"},{"title":"宝宝半岁了","text":"里程碑：6个月，时间过得好快，一转眼就长大了","link":"/life/life-baby-6month/"},{"title":"宝宝八个月","text":"八个月打卡","link":"/life/life-baby-8month/"},{"title":"Baby Funny Clips","text":"Sharing some funny clips.","link":"/life/life-baby-clips/"},{"title":"第一个生日","text":"一岁生日，from zero to hero","link":"/life/life-baby-first-birthday/"},{"title":"第一次带宝宝出远门","text":"发一波库存，产假结束前的周末（06-15-2024）带宝宝去了halfmoon bay，第一次出这么远的门。 原本打算去Santa Cruz，路上要堵车半个小时，临时决定去Halfmoon Bay。 直接导航到了吃中饭的地儿，一家秘鲁餐厅：260 Capistrano Rd, Half Moon Bay, CA 94019 买了一顶小帽子，结果还是太大了😂 生蚝，海鲜饭，这家有点小贵 边吃边哄 餐厅环境 旁边就是码头，有一艘船居然在卖海胆 打开之后，用清水稍微洗了下就可以吃了，说实话直接吃还是比较苦的，如果能蘸个酱油就好了 回家路上 宝宝去之前还挺安静的，回来快到家的时候大哭，后来发现是安全座椅坐久了，胀气排不掉肚子不舒服。小月龄宝宝带出门还是不太轻松，下次出远门还是等他再大一点。","link":"/life/life-baby-halfmoon-bay/"},{"title":"在美国生日当天薅羊毛","text":"在生日当天免费吃喝 正好今年生日放产假在家，能够白天出门好好地转一圈，把能薅的羊毛都薅一遍。两个礼拜前查了下攻略，把一些大家提到的主要的免费礼品都领了。 Krispy Creme: 三个Original Glazed Doughnuts McDonald’s: 以为可以随便选一个单品，店员告诉我只能四选一，我选了cheeseburger，其他的大概有鸡块和sandwich。 Buffalo Wild Wings: 六个鸡翅 Crumbl: 任选一块饼干 Panera Bread: 任选一种Bakery Starbucks: 任意一杯饮品，根据网友分享的配方点了一杯，APP上显示这杯要$11.30, 这波赚了。 Mian Bao House: Fantuan上可以团购一个8寸的水果蛋糕，价格是$4.99。但感觉不是生日也可以团，只要买了团购券到店扫一扫就可以了。","link":"/life/life-birthday-rewards/"},{"title":"九月龄打卡","text":"大运动发展迅猛的阶段","link":"/life/life-baby9month/"},{"title":"Blackhawk Museum","text":"位于Danville，CA的一个当地博物馆 地址： 3700 Blackhawk Plaza Cir, Danville, CA 94506 周六整个bay area都在下雨。从880转680, 途经Pleasanton，Dublin，San Ramon，一路往北开大概距Fremont40分钟车程达到Danville。走之前还去逛了下Newark新开的Costco，感觉大家都想去图个新鲜，从停车场到商场里面到处都是人。不过到也确实有不少新鲜事物，试吃也不少。 入口惊现LV 鱼子酱试吃 人太多了，逛到一半就“弃车”而逃，出发去Blackhawk Museum 路过San Ramon，街道秋景还是很不错的 入口 博物馆成人是$20/人，进去之后第一个展馆就是汽车展 入口一左一右一辆是咱们国产的红旗轿车，另外一辆是劳斯莱斯 接着是一排跑车，法拉利，兰博基尼，奔驰 好多古董车，但是不太认识 中国馆 2024龙年出生的宝宝象征意义很好， Lucas就是龙宝宝～ 自然馆，都是动物模型 旧西部","link":"/life/life-blackhawk-museum/"},{"title":"California Coastal Trail","text":"Half moon bay一条小众但是景色绝美的trail 地址：1001 Miramontes Point Rd, Half Moon Bay, CA 94019 停车有两个选择： Google map坐标（37.43054372076992, -122.43739338466308） 经过第一个停车场继续往里面开，进入Ritz-Carlton酒店，和门口保安说要去coastal parking，他会告诉你往里走右手边有专门去海边游客的停车场，具体坐标（37.434698444926994, -122.43964539474199） Trail位于整片海边高尔夫球场里","link":"/life/life-california-coastal-trail/"},{"title":"California&#39;s Great America","text":"Plenty of rides, play areas and water play, toddler‑friendly, recommend.","link":"/life/life-california-great-america/"},{"title":"Catalina Island","text":"2023圣诞假期trip vi","link":"/life/life-catalina-island/"},{"title":"Centerville Library Petting Zoo Event","text":"Kids event hosted by Centerville Library. Many libraries located at East Bay will host kids-friendly events/activities every weekend. This weekend at Centerville Library, it was petting zoo day. More events can be found at this website.","link":"/life/life-centerville-library-petting-zoo/"},{"title":"Christmas In the Park","text":"San Jose Downtown圣诞秀 地址： 194 South Market Street Drive Thru:, 799 Phelan Ave, San Jose, CA 95113 地址有点复杂，直接搜Christmas In The Park就可以了。 停车建议停在旁边的Convention Center Public Garage，停了大概1.5个小时也才$7, 不要以为很贵，park旁边的露天停车场都是$25/hr起。","link":"/life/life-christmas-in-the-park/"},{"title":"California Academy of Sciences","text":"California Academy of Sciences Experience. Address: 55 Music Concourse Dr, San FranciscoParking: Music Concourse Underground Garage, 55 Hagiwara Tea Garden Dr, San Francisco","link":"/life/life-california-academy-of-sciences/"},{"title":"Chinese New Year in Chinatown","text":"在唐人街体验中国新年，体验却是… 从未自驾去过旧金山的唐人街，主要原因是旧金山市区的道路复杂，狭窄曲折的街道让我本能地抗拒在市中心开车。更何况，市区停车一向是个大难题，路边停车全凭运气，停车场的收费又高得离谱。以前没有孩子的时候，还能勉强搭乘 BART 去旧金山，但有了娃之后，出行的考量变得更多，安全自然成了首要因素。旧金山的地铁“传奇”早有耳闻，几次乘坐的体验也让我望而却步——车厢里总能遇到形形色色的怪人，空气中弥漫着让人不适的气味，似乎是多年积累的垃圾、体味，叶子味、甚至是排泄物混杂出的独特气息。说实话，我无法接受带着孩子在这样的环境下出行。 这次自驾前往，结果发现其实也没那么麻烦。在网上做了一番攻略，找到唐人街旁有一个口碑不错的地下停车场，位置极佳，几乎没有步行距离，地址是 555 Jackson St, San Francisco, CA 94124。停车费每小时 $9.25，上限 $28 一天，支持手机扫码支付。综合地理位置和便利性，这个价格还算合理，可以接受。 今年是我在海外度过的第七个春节。对“过年”的期待，也从最初的憧憬，渐渐变成了无所谓的平淡。刚来美国读书时，还能和同校的朋友们一起聚餐、热闹一番，那时的年味，是一群异乡人短暂的欢聚，在万家灯火之外点亮属于自己的一盏灯。可工作之后，社交圈缩小，群体归属感逐渐模糊，社恐的性格更让我远离了聚会。平时的同事，在生活中几乎零交集。于是，过年成了给自己点一顿比平时更丰盛的外卖，和父母视频通话久一点，给平时不怎么联系的亲友发条问候，或是在朋友圈里刷着别人热热闹闹的春节，隔着屏幕体验“云过年”。其实，我挺喜欢这种旁观的感觉，就像我时常幻想，住在纽约一座高层公寓里，俯瞰街道上熙熙攘攘的人群，川流不息的车流，夜色下灯火通明的城市。这种氛围让我感到温暖和舒适，仿佛置身其中，却又游离其外。不知道心理学上是否有专门的名词来形容这种状态。 再后来，成家了，过年不再是一个人的事。只是，过去两三年的春节怎么过的，似乎已经记不清了。或许只是口头上重视了一下，自己下厨做了一顿丰盛的年夜饭，第二天生活依旧。渐渐地，我与“过年”好像在一点点脱离。 今年春节正好赶上休假，想着无论如何也要找回一些年的味道。在国外，最有年味的地方莫过于唐人街。前几天刷到小红书，说旧金山唐人街的花市“年味浓到装不下镜头”，还有舞龙舞狮，照片里的热闹场面让我想起北方赶大集的氛围，正是我心中对“过大年”的想象。于是满心期待地驱车前往，想感受一丝节日的余温。 到了之后，转了几条街，除了道路两旁的新春装饰提醒着我这是在过年，其他的庆祝活动并不多。可能因为是工作日，人流也远没有想象中多。出发前甚至还做了心理准备，以为人会很多，特意打算一路背着娃。最终，努力寻找的年味，也只是零星地散落在餐馆里贴着的春联、偶尔飘来的熟悉方言、以及行人脸上洋溢的笑容里。 不过，这次倒是有充足的时间仔细观察唐人街的生活，发现与自己想象中的华人社区有不少不同。老一代移民有着固定的社交圈，他们保持着家乡的生活习惯，说着各自的方言。街道上随处可见的同乡会招牌，让我意识到，即便都是华人，也依然划分着不同的小群体。有人在公共场合抽烟，有人开车习惯性地猛按喇叭，街道两旁是古老的建筑，潮湿昏暗的地下室，陈旧的招牌与斑驳的牌匾，低质量的路面和卫生状况，以及那些售卖旧古董的小店……这一切，与旧金山现代化的都市形象形成了鲜明对比。 唐人街，就像是一座自成一体的小城，让我想起香港的九龙城寨，甚至电影《功夫》里包租婆守着的那座城寨。里面的人自给自足，过着与外界略显割裂的生活。今天路过的一幕令我印象深刻——街道一侧，是一座年代久远的公寓楼，楼顶还挂着“华商总会”的牌子，而对面，则是摩天大楼林立的希尔顿酒店。 当然，我并不是想刻意渲染落差感或贬低唐人街的环境。每个移民群体都有独特的文化印记，正是这些差异，构成了美国这片土地的多元与包容。这座“城中之城”，承载着一代代华人的奋斗与生活，也许正是这种与周围世界的对比，才让它显得如此独特。","link":"/life/life-chinatown-chinese-new-year/"},{"title":"2024 CLC Tournament TikTok vs Meta","text":"TikTok vs Meta (2-3)","link":"/life/life-clc-tournament/"},{"title":"Christmas Eve","text":"Christmas Eve去了Westfield Valley Fair + Santana Row闲逛 Santana Row旁边有停车场，还挺好停车的。去的时候才四点多，天还没黑，估计天黑了这条街的装饰会更好看。看网上视频这里还会有人造的雪。","link":"/life/life-christmas-eve/"},{"title":"Baby Photo Collage","text":"Made an interesting photo collage for Lucas.","link":"/life/life-collage-lucas/"},{"title":"Christmas Lightshow","text":"东湾Newark圣诞灯展 圣诞节将至，最近被社交软件上湾区灯盏刷屏。看到家附近的Newark有个非常热门的灯盏，今天打算去看看。 这次去的并不是公共区域的灯盏， 而是屋主用自己的房子装饰圣诞节彩灯，在湾区非常有名。通过了解屋主之前还参加过 the great christmas light fight节目。现场看到如此大规模的装饰也是十分震撼，非常用心的制作。BTW, 今年是最后一次他们家举办灯展了。有兴趣的朋友可以趁着年底之前来看看，每晚5点以后开始，大风大雨天不开。 地址： 6716 Fountaine Ave, Newark, CA 94560 在Youtube搜到了他们之前上节目的视频 慕名而来的人太多了，刚拐进入口就看到巨大的充气装饰和投影灯 旁边人家其实也不错，很小很精致，但旁边确实过于声势浩大 外观 车库门口 前院 之前参加过的节目 &amp; 告诉大家今年是最后一次举办了 树上N个监控 更多装饰 烟雾特效 树上的灯也很有特色 他家邻居的装饰","link":"/life/life-christmas-lightshow/"},{"title":"Coyote Point Recreation Area","text":"San Mateo临湾公园 地址：1701 Coyote Point Dr, San Mateo, CA 94401门票：$6 湾区最美的公园之一，不算特别大，半天能逛个遍，非常适合带小朋友来玩，里面有一个挺大的playground：Magic Mountain Playground。走在靠湾的trail上可以近距离看到低空飞行即将降落到旧金山机场的飞机。","link":"/life/life-coyote-point-recreation-area/"},{"title":"Crippsmas Place","text":"Fremont著名圣诞灯展街区 地址：35971 Wellington Pl, Fremont, CA 94536","link":"/life/life-crippsmas-place/"},{"title":"Deer Hollow Farm Trailhead","text":"假期复工后的第一个周末 周末来到了位于Cupertino的一个农场徒步，在社交媒体上刷到还有小动物可以看。Trail路线比较丰富，距离也比较长。我们只走了最平坦的路线，到达有小动物的农场就往回走了。二月份当属湾区一年之中最“绿”的时候，再加上今天天气特别好，吸引了许多人来，一路上大大小小的停车场基本都停满了车。想要距离Trail入口最近就要一直往里面开，停在最里面的停车场，坐标（37.332609382945535, -122.08738656543414）","link":"/life/life-deer-hollow-farm-trailhead/"},{"title":"唐探1900","text":"春节档期间在北美上映，昨天看了之后感觉拍的还是很用心的 因为我本身就住在旧金山地区，在国外能看到中国电影把旧金山唐人作为取景地感觉还是很亲切的。据说陈思诚为了真实还原1900年的唐人街，用时七个月在山东德州的300亩土地上，从无到有，搭建出了一座旧唐人街。十分佩服。从电影所呈现出来的画面来看，美术道具团队确实对于细节的把控煞费苦心，与我今时今日所看到的现代唐人街街景重合度十分高。就单从这方面，就得给整个电影制作团队一个赞👍。 稍微普及一下电影的时代背景： 国内方面： 此时中国仍由清政府统治，光绪帝在位（1875-1908），但实际政权掌握在慈禧太后手中。清政府政治腐败，国力衰弱。列强入侵，1895年甲午战争战败后，《马关条约》使中国进一步沦为半殖民地。在民间反洋教、反帝情绪高涨的背景下，义和团运动（1900）爆发，并发展为“扶清灭洋”的全国性反帝斗争。同年，八国联军侵华，北京陷落，慈禧太后与光绪帝逃至西安。总体而言，1900年的中国正处于内忧外患之中，既有义和团等民间反抗运动，又有列强加深侵略，而清政府在内外交困下逐渐走向灭亡的边缘。 美国方面：美国正处于第二次工业革命（约1870-1914年）中，铁路、电力、钢铁、石油等行业迅速发展，资本主义经济繁荣。19世纪中期至1900年左右，加州淘金热吸引大量华工赴美，随后1860年代美国修建横贯大陆铁路，由于美国本土劳工短缺，铁路公司最初依靠爱尔兰移民，但因劳动力供应不足、工作艰苦、工资要求高，最终决定大量招募华工。由于华工工资较低且工作勤奋，白人工人对其怀有敌意，旧金山逐渐出现反华暴力事件。1882年，美国政府通过《排华法案》（Chinese Exclusion Act），禁止华人移民，使旧金山的华人社区受到极大冲击。随着排华法案的实施，华工被排斥在美国主流社会之外，他们集中在旧金山的唐人街，形成自给自足的华人社区，并逐渐成为世界上最著名的华人聚集区之一。 电影中有几个让我印象深刻的人/事 郑士良 对于这个名字不是很熟悉，但在电影中戏份也不少，应该是参与清末相关起义的领袖之一。查了查相关资料，郑士良（1863年—1901年），广东惠阳人，清朝末年的革命烈士，曾参与由孙中山发起的初期革命运动。1900年6月，义和团运动爆发，八国联军攻打北京。郑士良受孙中山委托，于10月8日募集志士六百馀人，在惠州起义。 1900留美证 由于1882年的排华法案，要求所有华人移民必须随身携带政府颁发的居留证，否则可能被逮捕或驱逐。 电影中刘昊然拜了周润发为义夫，没多久管家就把一纸留美证给了刘昊然。查了下发现，1892年，《吉尔里法案》规定，美国政府要求所有在美合法居住的华人必须向美国移民局登记，申请居留证（Certificate of Residence），以证明其在美身份。当时所需的材料比较简单，包括：个人身份信息，至少一名白人证人作担保，证明该华人于1882年排华法案生效前已居住在美国，等。其他一些渠道类似今天的一些政策比如：商人、学者和外交等，根据1893年的修改法规，中国商人、教师、学生和外交官可以申请进入美国，并获得合法居留身份。美国公民的直系亲属：如果华人已归化为美国公民（尽管非常困难），其直系亲属可以申请居留权。 电影当中应该走的就是亲属移民 福尔摩斯 虽然是虚构的人物，但是出现在了电影中，查了下时间线，确实福尔摩斯案件的时间线集中在1875－1907年间。 1900年左右加州的主要政党 电影中最后新的市长是民主党的人，查了下资料，1900左右，加州主要由共和党控制。南北战争后（1865年），加州与北方的共和党保持一致，成为共和党主导的州。共和党与南太平洋铁路公司（Southern Pacific Railroad）关系密切，该公司在加州政坛有极大影响力。由于在铁路公司影响下，共和党在州政府和全国选举中占据优势。 最后，电影中周润发在快结束说的一句话记忆尤深：师夷长技，再撕不迟 参考 https://www.sohu.com/a/853480696_122152176 https://zh.wikipedia.org/zh-hans/%E9%84%AD%E5%A3%AB%E8%89%AF https://zh.wikipedia.org/wiki/%E6%83%A0%E5%B7%9E%E8%B5%B7%E7%BE%A9 https://zh.wikipedia.org/zh-hans/%E6%AD%87%E6%B4%9B%E5%85%8B%C2%B7%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF","link":"/life/life-detective-chinatown-1900/"},{"title":"华人教会组织的复活节活动","text":"有很多给小朋友准备的活动：捡蛋，涂脸装饰，手工，表演，美食等。 地址：35479 Dumbarton Ct, Newark, CA 94560","link":"/life/life-easter-activity/"},{"title":"Fourth of July Show","text":"独立日烟花秀 地点：Milpitas Sports Center Fremont每年都不让放烟花，只能去最近的Milpitas看。前年在Foster City看过一次，那次是开车进去，一是停车位难找，二是出来的时候堵的一动不动。这次特地选了一个远一点的停车场，然后走路过去。体验拉满，完全没有堵车的烦恼。 停车点：1199 Jacklin Rd, Milpitas, CA 95035","link":"/life/life-fourth-of-july-show/"},{"title":"霸王餐体验","text":"最近运气好抽中了某火锅店微信群的霸王餐大奖, A5和牛，海鲜拼盘限点一份，其他随便吃。老板大气的","link":"/life/life-free-hotpot/"},{"title":"Filoli House &amp; Garden","text":"位于湾区Woodside的一个庄园。 庄园里面包含了大面积的花园，果园，自然景观和一座豪华的主屋。Filoli为口号首字母缩写——“Fight for a just cause, Love your fellow man, Live a good life”。这里也是2023年习主席和拜登，中美两国元首会晤的地方。","link":"/life/life-filoli-house-garden/"},{"title":"Enchant San Jose","text":"San Jose圣诞灯展 地址： 1123 Coleman Ave, San Jose, CA 95110 整个PayPal Park Stadium被布置了绚丽的圣诞灯展，停车一定不能停在PayPal Park的停车场，不仅大排长队，而且还要额外花钱，可以选择停在就近的Plaza，走过去也就五分钟。","link":"/life/life-enchant-san-jose/"},{"title":"Great Wolf Lodge","text":"大狼屋室内水上乐园 地址：2500 Daniels St, Manteca, CA 95337， 距离湾区在不堵车情况下一个小时车程 建议有时间周中去，避开周末和假期的高峰，住宿也便宜。这次是周二去的，人不算多，但也不少，很多老美家庭都是买了day pass，在停车场大包小包地往里面运，在里面真的可以玩上一整天。周中去的话各种水上项目都不需要排队，池子里人也不密集，体验很好。与其说是水上乐园，更像一个all inclusive的度假酒店，住宿，餐饮，娱乐全都在一起，非常适合带小孩一起。Lodge旁边步行距离就是Costco，还能顺便去解决一顿饭。","link":"/life/life-great-wolf-lodge/"},{"title":"Mustard Fields at Half Moon Bay","text":"湾区赏花季节 Wild Mustard Super Bloom： 路边停车，路边就是一大片油菜花花海。Cowell-Purisima Coastal Trailhead，停车场比较小，停车看运气，也可以选择附近路边停车，trail沿途的花没有前一个地点的多。","link":"/life/life-flower-bloom/"},{"title":"Happy Hollow Park Zoo","text":"遛娃 园区不大，分为Zoo和Park两个区。虽然名字里带Zoo，但这个Zoo小的可怜，动物也很少。动物区走一圈10分钟就能看完，主要都是带孩子去Park玩的。家里的娃身高还没到30inches，一个ride都坐不了😂，再大一点来就好玩了。","link":"/life/life-happy-hollow-zoo-park/"},{"title":"Fremont Art Festival","text":"Annual art event since 1983. Hosted on the first weekend of August at Fremont Downtown area. For anyone looking to easily locate booths and find the best parking spots, I’ve added some helpful annotations on the map.","link":"/life/life-fremont-art-festival/"},{"title":"Juror Summons 陪审团传票","text":"最近在邮箱里发现了一封陪审团传票，一开始以为是无关紧要的东西，昨天仔细读了下上面的信息，可给我吓了一跳 首先先科普一下什么是陪审团传票（Juror Summons），一般是法院通知符合条件的美国公民，需要按照上面的时间，地点到法院作为候选陪审员参加庭审。为什么是候选呢？因为你收到并且去了也只是进入了陪审员候选池，法庭还会组织一轮筛选（voir dire）来最终确定一个12人的陪审团名单。 上面也说了，这种jury service要求至少是美国公民参加，那我又不是公民，为什么也能收到这个传票呢？我觉得这就是不合理的地方了。根据网上能查到的信息，这个是一个随机抽样的过程，样本来源是车管所登记持有驾照的人。也就是说只要你有驾照，理论上就有可能被选中。看到网上还有旅游来的人也收到了传票，真的就无语。 真的就这种机制细细一想真的是匪夷所思，美国政府难道没有本国公民的个人详细信息？非要浪费社会资源，和其他不相关人员的时间和精力来处理这种毫无意义的事情。传票的背面仔细一看真的让人吓得一身冷汗。意思就是法院知道你有可能不符合陪审员条件，但你必须在出庭之前登记个人信息回复，否则我们要对你进行罚款，或者监禁，或者两者都有。我的天，看到这儿真的快把我气死了。有一种美国霸权主义骑在我等普通牛马身上蹂躏的感觉。你明知道我有可能不符合条件，还要威胁一下我，让我主动上交个人信息，还知道我会乖乖照做，真的本来就是牛马了，现在又卑微了一个等级。 我的传票让我在06/02到场，可是我直到前两天（06/22）才注意到这封信件。按照上面的威胁，我不是要被罚款就是要去蹲监狱了。于是乎我立马登陆了信上面提供的网址，输入了号码进行登记。登记过程会让你检查自己是否符合条件，如果不符合条件在最后点提交的时候应该就会提示你不用去了。由于我登记迟了，我点完提交之后上面一行红字提示我错过了06/02的庭审，让我重新预约或者联系法院。我就直接写了一份邮件给法院，说明了一下我收到邮件的时候已经错过了庭审，并且我不符合作为juror的条件。第二天早上我就收到了回复，表示没事了。 我个人觉得这样的制度从根本上来说是完全可以有优化空间的，中间有太多不合理的环节。如果最终陪审团是由公民所组成，一开始就在所有公民组成的候选池随机抽取就行了，所谓的扩大候选池，保持样本代表社区广泛，人口结构多元化的说辞，如果以最终结果为导向看的话，都是假大空的废话。美国这只慵懒的老虎，真要它在这些陈年老掉牙的规章制度面前挪一挪屁股，那可真的是一件极为困难的事情。就像如今的美国总统选举选民投票制度一样，依然停留在上世纪，每隔四年给世界做一次秀。","link":"/life/life-juror-summons/"},{"title":"Lake Chabot Regional Park","text":"位于Castro Valley的一个环湖公园 公园里有停车位，但是需要$5，大部分车都停在了公园入口处的街趴，车位还是挺充足的。","link":"/life/life-lake-chabot-regional-park/"},{"title":"Holiday Trip - LA","text":"圣诞旅行之LA Day0: 第一次带娃坐飞机出门，真的和打仗一样，从家-&gt;机场-&gt;飞机-&gt;机场-&gt;租车-&gt;airbnb每个过程有了娃之后都变得无比艰难，到了airbnb已经到了娃睡觉的点，所以什么都没干。这天最惬意的时刻当属娃睡了之后点了外卖在露天吃外卖，真的无比舒畅。 Day1: 迪士尼，一日两园。不过第二个园几乎没怎么逛。 Day2: 由于前一天累废了，第二天主打一个休息。早晨去了附近的playground给娃放电，下午只去了newport beach转了转，拍了娃的人生照片。晚上去了附近的商场South Coast Plaza, 做坐了旋转木马。 Day3: 早晨小公园放电，中午去了Santa Monica海滩。 Day4: 早晨小公园放电，中午去了三里屯吃铁锅炖，然后又是特种兵似的归家之旅。 Day1 Day2 Day 3 Day 4","link":"/life/life-la-trip/"},{"title":"宝宝脐带脱落","text":"Cord finally falls 12 Days⏳✨and 9 hours,12 minutes 终于可以放心大胆地换尿布了，接着还能洗澡","link":"/life/life-lucas-cord/"},{"title":"Marina Park","text":"春天，到处都是生机 14001 Monarch Bay Dr, San Leandro, CA 94577 公园有两个停车场，还有两边街趴可以停。人流量比较大，停到车需要靠耐心和运气。","link":"/life/life-marina-park/"},{"title":"Lemos Farm","text":"Pumpkin patch at Lemos Farm.","link":"/life/life-lemos-farm/"},{"title":"Lucas First Week","text":"04/18/2024，10:48pm，8磅，欢迎Lucas来到我们家","link":"/life/life-lucas-first-week/"},{"title":"Maximizing Productivity","text":"Productivity is not just about getting more done; it’s about maximizing your gain with minimal effort and time. The key is to focus on tasks that yield the highest value while reducing unnecessary work. Life is short, and how we allocate our time determines the impact we create. From my own experience, i listed several practical principles. Estimating ROI: Is It Worth Your Time? Before committing time to any activity, it’s crucial to estimate its return on investment (ROI). Whether it’s learning a new skill, taking on a side project, or even resting, ask yourself: What value will this bring to my life? If the outcome justifies the effort, it’s worth doing. This mindset helps filter distractions and focus on high-impact tasks. If you’re considering learning a new language, think about how it will benefit you. Will it help in your career, travel, or personal growth? If yes, dedicate time to it. If not, it may not be the best use of your time. Keep Writing: Share and Preserve Knowledge Writing is one of the best ways to solidify knowledge and increase exposure. Whether through blogging, journaling, or sharing insights with others, consistent writing enables self-improvement and leaves a valuable record of thoughts. Over time, this creates a personal archive that not only benefits yourself but also helps others learn from your experiences. A software engineer who blogs about programming tips will not only reinforce their own understanding but also build a reputation in the industry, attracting career opportunities. Don’t Let Your Past Be Just the Past Every past experience, whether good or bad, is a potential learning opportunity. Instead of moving on without reflection, extract lessons, refine your skills, and build upon past knowledge. A productive life is one where experiences compound over time, leading to greater expertise and wisdom. If you once attempted to start a side business but it failed, instead of viewing it as a loss, analyze what went wrong—was it marketing, product fit, or time management? Use that knowledge to refine your approach and increase your chances of success in future ventures. Self-Reflection: Adjust and Improve Regular self-reflection is key to personal growth. Take time to assess what’s working and what’s not. What habits have helped you? What needs to change? Honest self-assessment helps course-correct before small inefficiencies turn into major obstacles. Keeping a weekly journal where you write about what went well and what didn’t can help identify patterns in productivity and personal growth. Optimizing Time: The Cost of Delay A powerful question to ask yourself is: If I don’t do this now, will I spend more time on it later? Often, procrastination leads to greater inefficiencies. Addressing tasks promptly can prevent future stress and unnecessary time consumption. Prioritization is essential—focus on what matters most and eliminate tasks that do not align with your goals. If you have an important email to send, writing it now prevents miscommunications, delays, or forgotten details later. Acting on small but significant tasks early saves time in the long run. One great life tip I learned from my partner is that we clean baby bottles during our fragmented time instead of doing it all at once. This makes things easier and less tiring, allowing us to manage household tasks more efficiently without feeling overwhelmed. Rest Is Important: Use Time Efficiently Contrary to the hustle mentality, rest is not wasted time—it’s a strategic investment in long-term productivity. Efficient time use doesn’t mean working endlessly but balancing effort with recovery. Proper rest boosts mental clarity, creativity, and motivation, making work more effective when you return to it. I used to work late into the night, pushing myself to learn new things or produce blog content. However, I often found that my mind didn’t function well at those hours, leading to inefficiency and frustration. Once I prioritized rest and worked when my energy levels were higher, I became far more productive and produced better results in less time.","link":"/life/life-maximize-productivity/"},{"title":"Newark Day","text":"Newark Day is a four-day festival to celebrate the birth of Newark City, California. It is held every year in September at Newark Community Park.","link":"/life/life-newark-day/"},{"title":"新的乒乓球拍","text":"更换了我用了17年(2008 - 2025)的乒乓球拍 关于我的老球拍，还是读小学的时候在杭州暑假练球的时候买的，依稀记得当时底板花了1000左右，在当时还算是一块不错的板。这块板陪伴着我赢下大大小小的比赛。 但随着时代的进步，球板的设计和材料也跟着一步步更新迭代，去年刚拾起乒乓球这项爱好的时候才听说现在都是碳素的板了。直到最近我才决定买我人生第一块炭素板。我自己只会打球，不太懂拍子的参数，就选了一块现在比较流行的底板-蝴蝶Viscaria。希望努力适应新板，涨一波球技。","link":"/life/life-new-ping-pong-paddle/"},{"title":"满月记录","text":"04/18/2024 - 05/18/2024 在家DIY满月照，其实只要依靠一些道具和修图软件，出片效果也挺好的。","link":"/life/life-one-month-baby/"},{"title":"Niles Community Park","text":"抓住秋天的尾巴 地址： 37671 3rd St, Fremont, CA 94536 公园面积不大，适合平常早晨或者傍晚出来溜达。这次来也是因为在小红书刷到这边的秋景不错。到那儿一看，果真秋意满满～ 入口，前方就是一片水杉 红绿交错的水杉，适合出片 雨季才来了一会儿路就被淹了 近看水杉，浮萍 步道 远景","link":"/life/life-niles-community-park/"},{"title":"Holiday Trip - Monterey","text":"圣诞旅行之Monterey 这次带着八个月大的宝宝第一次出门，时间安排上格外谨慎，大部分在车上的时间都是凑着宝宝睡觉的时间段，这样到了目的地就可以充分放电玩耍，车上也不会哼哼唧唧。 Day1: 上午十点从湾区出发去Monterey Bay Aquarium, 大约一个半小时车程，我们到的时候宝宝也正好醒了。水族馆附近没有很好的停车位，大部分都是街趴，我们大概转了10分钟左右停到了一个4小时的街趴（Foam St）。下午三点出水族馆, 开车前往10分钟车程的度假酒店check in（Hyatt Regency Monterey Hotel and Spa on Del Monte Golf Course）。接下来就是伺候娃+探索酒店内部设施。 Day2: 上午在酒店的泳池带娃玩了半个小时+娃上午一个半小时nap。中午checkout之后就去旁边的Old Fisherman’s Wharf找了个地儿（Grotto Fish Market）吃了中饭。在码头附近闲逛了一会儿就往回开了。 总结：带娃出门经验值+1 水族馆所在的步行街 水族馆内部 步行街 酒店前台 烤棉花糖 第二天早上吃早饭，因为酒店断电所以给所有用餐的客人免单 清晨，酒店户外景色 Old Fisherman’s Wharf 中饭 码头散步 溜冰场","link":"/life/life-monterey-trip/"},{"title":"Oakland Zoo","text":"湾区为数不多的几个动物园之一 比较奇特的一个动物园，google map上显示开门时间是10am - 2pm，买票按时间段买，每个时间段还卡入场人数。整个动物园不是很大，动物种类也不是很多，带娃大概两个时间左右就能逛个遍。唯一的亮点就是能免费坐缆车（gondola）从底下的园区上到山上另外一个园区，上面有一些其他的动物（狼，豹，熊等）。还有一个sky ride能坐缆车俯瞰一圈整个动物园，需要额外$5/人。这次去没看到太多动物，都躲了起来或者远远地呆着，倒是里面的children playground让娃玩的挺开心。","link":"/life/life-oakland-zoo/"},{"title":"Palo Alto Junior Museum","text":"周末遛娃 室内是科技馆，室外是一个小动物园。","link":"/life/life-palo-alto-junior-museum/"},{"title":"Pick Mulberries","text":"最近在小红书刷到Fremont有免费果园可以摘Mulberry 地址：Quarry Lakes Regional Recreation Area Park里面有个湖中间的小岛叫做Rare Fruit Grove，地图上可以看到。进到果园门口有三颗桑树，看起来已经有人来摘了好几波了。树的底部能被人够到的地方基本都只剩下一些还没成熟，成色为绿色的mulberry，往上看能看到有很多已经完全成熟（紫色）的果子。想着也不能白来呀，于是在每棵树下仔细徘徊了好久，摘了一些半熟的。 很有意思的是，在树下找到了一根十分称手的树枝，顶部被劈开了一小段（类似于鱼叉的形状），可以对准果子的茎部分，然后那么一扭，就掉下来了。应该是某位前人留下来的杰作，理所应当，我们把它夹在了树枝岔开最显眼的地方，希望下一批摘果子的人也能用上，哈哈哈。","link":"/life/life-pick-mulberry/"},{"title":"Pacific Bus Museum","text":"Pacific bus museum open house. Address: 37974 Shinn St, Fremont, CA 94536 More information about open house: https://pacbus.org/annual-pbm-open-house/","link":"/life/life-pacific-bus-museum/"},{"title":"🤔Random💡","text":"What’s in my brain? 123// Disclaimer:// Opinions below are personal and in-progress.// Not legal/financial/medical/professional advice. 09-08-2025最近一件出乎意料好用的电子产品：骨传导耳机。优点1: 不容易掉落，误触耳机不会像airpod那样停止播放。优点2: 带几个小时都不会有耳朵不舒服的情况。优点3: 声音开得很大也能保持对外界的感知。 08-30-2025今天开车在高速上路过一些广告牌，看了几个发现有一些广告牌做得十分失败。本质原因在于不够直接。原本高速上开车车速就比较快，很难有好几秒时间盯着一个广告牌看，更别说一个字一个字看过去。我想优秀的广告牌内容应该在第一秒就能让用户知道你们的产品是什么，能帮助解决用户什么问题。那些密密麻麻挤了一大堆文字内容的广告真的就是在浪费大家的时间，浪费投广告的钱。 比如让我印象比较深的是Turo的广告牌，上面写了“Skip the rental counter”。 08-27-2025写一遍改三遍，很多人（包括我自己）把90%的精力都放在了前者，而忽视了后者的重要性。 08-26-2025今天去法院处理两个月前的罚单，结局不错，最终把罚金退给了我。但我还是觉得这套体制还是被玩复杂了。美国的三权分立导致警察只能执法而不能定罪，定罪必须要交给法院。但像一些违章之类的罚单，没有太大的必要走那么多流程，我算了一下，整个流程我一共收到了四份不同的notice，有来自警局的，有来自法院的。这中间有些步骤还需要我额外寄材料给法院，这得浪费多少纸呀。出庭也是一个比较麻烦的事情，还需要请假，每个人在里面正在轮到你也就几分钟的时间，但前前后后加起来可能要预留两到三个小时的时间来做这件事。 08-24-2025周末遛娃的时候会听播客，但总感觉只能听一些比较轻松的，分享为主的内容。如果AR眼镜技术成熟了，是不是以后可以直接放一个youtube来学习专业知识。 08-22-2025小心掉入“经验”陷阱，主要是因为经验有两个局限性。时效性：过去的经验很难apply到现在和未来，因为很多东西都在变。另外一种不恰当的比喻是：人永远无法预测未来。局部性：之所以会有经验这一说，是因为人们对于目前已知的，观察到的所形成的总结，它并不能反映一件事物整体的规律，亦或者根本不存在这种所谓的规律。你套用的公式本身就是错的，那必然无法得到一个你预期的解。 08-21-2025今天清理了一下网站的广告信息，只留下一个广告位。感觉之前广告太多以至于像个流氓网站，而且adSense居然把广告插在正文里，严重影响到阅读的体验。 最近在思考如何把工作学到的知识真正变成对你有利的，成为你自身的一部分这样一个话题。我觉得阶段性总结成体系很重要，还有就是要留下点痕迹，将来可以反复体会和回忆。 今天对改简历这件事有了全新的认识。简简单单一张纸，检验了你是否真的认识了解自己，检验了你是不是一个优秀的seller，把自己最突出的方面用最简练的形式推销给别人，从而打动别人。我觉得“会写简历”是一种很值得培养的能力/技能，不仅仅是为了找工作，更像是人在每个人生阶段对自己的总结和全面认识。或许我会让我的娃在很小的年纪就开始维护一份属于自己的简历。 08-20-2025珍惜无论是在生活还是工作中收到的一些批评/建议/反馈，这些都是效率极高的能帮助你快速提升的途径。 AI时代如何破局：长期主义（坚持/习惯） + 做时间的朋友（复利） + uniqueness（稀缺能力） 08-19-2025没有时间大部分时候都是一个借口，代表了你对这件事情的不重视。虽然我现在更忙了，但是我打心底里觉得运动和睡眠都是很重要的事情，所以我会每天下午抽时间去运动一小时到一个半小时，晚上就算再忙，也会尽量提早睡觉。 智能手表所有的功能里面按照有用程度划分：监测睡眠-&gt;99%，其他功能-&gt;1% 高效的3小时 &gt; 假装勤奋的6小时 08-18-2025世界上很多事情的本质就是很直接，很简单的。但“人”总有能力把事情过度复杂化，人们这么做无非就是想要在复杂性上体现出自己的价值。比如创造一些毫无意义的工作/事情，在流程上做很多无意义的堆砌等。人类社会并不是在寻求一个全局最优解，而是要保证身处其中的每一个个体都能有他存在的理由，从而不至于扰乱社会规律。时刻告诫自己，做事能简单尽量简单：说话尽量简单有力，写文章尽量简单易懂，写代码尽量简单易读。 08-17-2025平常会思考很多东西，看很多东西，听很多东西。 第一次尝试把平常零碎的思考写下来，最近非常喜欢的一句话：it’s not hard, it’s just new to you. 大部分时候我们所抗拒或者害怕的东西其实并没有想象那么困难。一旦熟悉了或者掌握了规律，后面会越来越顺畅。如何突破大脑强加给我们的这一思维呢？我的经验是：干就完了。","link":"/life/life-random-thinking/"},{"title":"大无语追尾事件","text":"虽然事情过去了三周，想来还是一整个大无语。 事情是这样的，周六早上去买菜，先去了一趟印度超市，然后顺路上880高速去大华买条鱼炖鱼汤。上了高速就一直待在最右车道，想着没多久就要下高速了。临近19号口的时候发现最右边是出口，所以打了一个左转方向，并且确认了左后方没有车，盲区也检查了，就往左变了过去。过了大概3s吧，听到一声喇叭，不确定具体方位，但很微弱（可能是高速上太吵，窗都关着的原因），我还以为是我左边超过我的车打的喇叭，还没等我多想，啪一下就被人从后面撞上。下面的图反映了当时的情形。 于是乎就停在了高速旁边的shoulder，先是打了保险公司，真无语，agent不上班就算了，客服也打不通，Statefram真的垃圾，后面再吐槽。然后又打了911。在等警察来的时候和对方车主(A)，交换了一些基本信息，我问他你从哪儿冒出来的，我都没看见你，这人支支吾吾也没透露啥有用信息。大概过了十分钟，还没等警察来现场，出现了本案一关键人物，一个不知道从哪儿冒出来的女的(B)。这人不知道什么时候把车停在了我前方大约50米的距离，我发誓我停车的时候前面绝对没车。等她走过来靠近我们的时候我才发现她，这女的过来就走向那撞我那男的，两人还说着话，我以为是A喊来的朋友，然后这个B从始至终在警察来之前没和我有过任何对话。 就这样，没过一会儿警察来了，问了我们一些基本信息，还问我们有没有交换驾照，保险这些信息。这个时候，这个B开始表演了，居然来了一句“我是目击者”。我当场懵住了，然后质问你俩刚才还说话呢，我以为你俩是朋友，这个B糊弄着说“哦，我们不认识”。我当时懵了，居然说出了“OK”这种窝囊的话。于是对话就此结束，各自离开了现场。 我心想着我正常变道，你追尾的我，我肯定能让你的保险陪我。周一上班迫不及待分别联系了我和A的保险公司，说明了情况。下午接到了我的（Statefarm）保险打给我的电话，说那个目击者B打电话高速他们是我变道不合理，越了白实线，导致的追尾。责任方变成了我，这样一来不仅我的车损不能理赔，我的保费还得涨。 事已至此，其实很容易看出来： B和A是认识的。 B是A叫来的冒充目击者。 试问哪个目击者在车祸发生10分钟后才到的现场，就算她真的目睹了发生的过程，开了老远突然正义感爆棚，立马下高速又南上高速，又下高速又北上高速，最后停在了我前方，这种事情又有那个人会信呢？ 这种事情也是第一次遇到，算是一次宝贵的经验吧。真让我涨了见识，一个车祸居然还能玩出这种花样。 出门在外，防人之心不可无。我曾经也想做个人畜无害的家伙，可是现实一次又一次打我的脸。","link":"/life/life-rear-ended/"},{"title":"One Week in Seattle","text":"来西雅图出差一个礼拜，也是第一次来到西雅图。记录下这座城市带给我的印象。 这次出差大部分时间都待在西雅图东边的城市Bellevue，号称“东雅图”。Bellevue给我留下最深印象的地方是，繁华的Downtonw居然没有看到一个流浪汉，至少在我待的这一周之内，凡是我步行在Downtown的时候，我完全没有见到过。以至于我问同事，Bellevue治安如何，他们告诉我半夜10点下班在附近走都很安全。这大大颠覆了我对美国市中心治安的认知。在美国，但凡是报得上名字的大城市，基本都是流浪汉扎堆，像是洛杉矶，旧金山，芝加哥，纽约等等。但是，虽然Bellevue治安不错，隔壁的西雅图Downtown还是差了那么一点。你说，这会不会和比尔盖茨住这附近有关呢😂？比尔盖茨住的Medina开车到Bellevue也就几分钟。 Bellevue城市不大，但人均很富裕。这也得益于科技公司在这里扎堆，比如漫步在Bellevue市中心，你能看到：亚马逊，微软，Meta，SalesForce，Unity等。听同事说，微软在西雅图地区有100多栋楼。这次来的时间也还行，赶上了西雅图地区由雨转晴的过渡季节，刚来的前两天有雨，后面基本就是大半天都是晴天，趁着天气放晴，赶紧抓拍了一些城市街景。西塔图地区常年雨水充沛，植被非常茂密，自然资源十分丰富。从地形上来看有点和旧金山湾区类似，西雅图和Bellevue之间隔了一个华盛顿湖，西雅图的西边是诺大的太平洋内湾。周围又被群山围绕，远处南边还有一个雪山Mount Rainier。 安排了周日回去的行程，这样周六就有一天宝贵的时间来浅浅体验一下真实西雅图的生活。一天时间太短，只能去到一些游客们来了都会打卡的景点。所以，选择了Space Needle和Pike Street。很有意思的两个地方，下面的照片更能表达我对这些地点的感觉。 总体而言西雅图还是一个比较有特色的城市，人民也很nice，而且没有州税，对于喜欢户外的人，这里好些不错的去处。但是这一年到头，大部分时间的阴雨天气确实也会劝退一大部分人，至少我不太喜欢。","link":"/life/life-one-week-in-seattle/"},{"title":"RV Show Newark","text":"房车展览 周末早上从Costco回来路上看到一大片房车停车路边展览。之前有看到过一个视频介绍房车展，对于房车内部的装饰十分感兴趣。下午等娃睡醒了就一起来参观。 美国的RV show还专门有一个官网，可以看到接下来展出的城市。https://www.rvshowusa.com/event/newpark-mall-adventure-van-rv-sale/","link":"/life/life-rv-show-newark/"},{"title":"MacOS模拟器玩复古小霸王游戏","text":"回味童年乐趣 MacOS上有一款十分强大的游戏模拟器OpenEmu，几乎涵盖了早期的一些掌上游戏机和红白机。一些小时候耳熟能详的游戏都能在上面玩。下载安装非常方便。 https://openemu.org/ 安装完之后进去的界面。想要玩小霸王FC游戏就选择Nintendo(NES)。 关于游戏下载，这里提供一个网站。如果需要搜索可以在这个网站的右上方搜索框搜游戏名字或者直接Google 游戏名+NES+Download。游戏下载下来是一个.zip的压缩包。直接把压缩包拖到上图的空白区域就可以了，十分方便。 https://www.emulatorgames.net/roms/nintendo/ 进入游戏可以设置键盘和手柄的按键。可以区分多人，但目前只尝试了两位玩家。键盘玩绝对没问题，又拿了家里的PS4手柄，居然也可以识别。有兴趣的朋友可以再试试其他的外设输入。","link":"/life/life-retro-game/"},{"title":"Safari West","text":"北湾野生动物园 地址： 3115 Porter Creek Rd, Santa Rosa, CA 95404 非常建议提早订票，我们订到了最晚下午2pm的那一个tour，12月的天晚上四点多就天黑了，再加上越往北越冷，记得多带一件厚衣服。 Tour是2小时坐车+1小时步行参观园区。一辆车可以做大概8个人左右，顶上有一排座位可以看到比较不错的风景，一般会让车上所有人都有机会上去坐一段路。建议在Tour快结束的时候坐上去，可以近距离看到长颈鹿。","link":"/life/life-safari-west/"},{"title":"Rapeseed at Fremont","text":"湾区三月赏花 位于Fremont的Antelope Dr路旁，基本开到这个路上就能看到旁边斜坡上大片油菜花。虽然路边不能停车，但是还是有很多人停在那儿。我们也就停了10分钟左右拍了几组照片就走了，适合快速打个卡。","link":"/life/life-rapeseed-at-fremont/"},{"title":"San Francisco Zoo","text":"SF Zoo","link":"/uncategorized/life-san-francisco-zoo/"},{"title":"Santa Cruz 半日游","text":"来湾区之后第二次来Santa Cruz溜达 第一站： UCSC最北部的UCSC Upper Campus Natural Reserve第二站： Santa Cruz Wharf 从东湾开往Santa Cruz一路弯弯曲曲的山路开着不太舒服，导致一直不是很想去SC。这次周末想着周边确实没有哪里可去，于是想到了去探索下SC还没去过的地方。周四周五的时候大致做了些攻略，看到UCSC北部有片挺不错的原始树林，适合hiking和骑行。开车不远，大概15分钟车程，穿过downtown，到达Santa Cruz Wharf，这里适合欣赏海景，吹海风，栈道一路走下去还有很多餐厅，冰淇淋店，纪念品店。适合惬意地边走边逛。 Reserve入口 Reserve面积特别大，回来还走错了路。里面主要的植被就是redwood，一路走下来感受就是确实还是很大程度保留了原始特征，很少有人为开发的痕迹 中途无意路过一个打卡点（The Painted Barrels），一开始还不知道，看到一群骑行的人在这里似乎是在搞某种骑友活动？ 不知不觉走回停车场一看手机居然走了7000步 虽然是11月了，但SC还是出奇暖和，记得以前差不多时间来但印象中很冷。居然还有这么多人下海。对面的游乐场去年来过，体验还算OK，不算刺激但是也够开心玩一天。气人的是今天有些项目居然开了，去年来的时候还是close的状态 Wharf可以开车上去，车位还算多，但是人也多！ 到的时候太饿了，就近选了Woodies Café吃个饭，靠窗景色太美了 没想到Wharf下面还是Sea Lion聚集地 天气好+温度适宜=优哉的下午 日落 戏剧的事儿发生在上车准备走的时候，发现水瓶不见了。一顿大脑思索回忆之后，想起来刚才看海狮拍照太专注了，顺手把瓶子放在了地上，走的时候忘记拿起来了。于是慌忙回去，好在远远就看到瓶子还在那儿，我也是把自己都逗笑了。 夕阳无限好～","link":"/life/life-santacruz/"},{"title":"Sealions at Fisherman&#39;s Wharf","text":"Watching sealions at Pier 39 at Fisherman’s Wharf.","link":"/life/life-sealion-fisherman-wharf/"},{"title":"Sausalito &amp; Tiburon半日游","text":"旧金山附近的海滨小镇 黎明和张曼玉主演的爱情电影“一见钟情（Sausalito）”和小镇（Sausalito）同名，同时也是电影取景地。 电影海报 现实","link":"/life/life-sausalito-tiburon/"},{"title":"San Francisco Chinatown","text":"来湾区这么久第一次来Chinatown逛 自己开车的话据说可以停在555 Jackson St的停车场，不过还是Bart来的方便。坐绿线在Montgomery Station下车，步行12分钟就到了。 在Chinatown主打的就是一个吃喝，随意逛。","link":"/life/life-sf-chinatown/"},{"title":"一个睡眠好的宝宝能在任何地方睡着","text":"给我一张床，我就能睡着 47天的宝宝，养成了规律每天下午固定时间睡觉。下午推出去散步，随便找了个树荫，铺上了野餐布。看到他有了困意，立马裹上包巾，开始哄睡。没想到居然直接能在野餐布上睡着。","link":"/life/life-sleep-in-park/"},{"title":"春天具像化","text":"鸟鸣，微风，花, 树，行人，太阳，风筝","link":"/life/life-spring-is-here/"},{"title":"解锁超级奶爸","text":"带宝宝爬山(50天) Coyote Hills Regional Park, 8000 Patterson Ranch Rd, Fremont, CA 94555","link":"/life/life-super-dad/"},{"title":"打工人保持清醒之选茶袋","text":"咱也不懂茶，直接问ChatGPT。","link":"/life/life-tea/"},{"title":"Shinn Historical Park","text":"追溯到1856年，James Shinn 和 Lucy Shinn建立的农场和苗圃。目前主要依靠大量志愿者来管理和维护。","link":"/life/life-shinn-historical-park/"},{"title":"Team Building 06-28","text":"三番团建 这次团建选在了金门公园附近。旁边有个租segway的地方，地址：3243 Balboa St, San Francisco, CA 94121 整个tour两个小时，大概把整个金门公园都绕了一遍，然后又从海边一路骑到lands end，再返回到租车的地方。从他们家官网找到的路线图。","link":"/life/life-team-building/"},{"title":"Table Tennis Practice","text":"📌PIN Recordings of daily practice. 09-18-2025Participants@Zhang @Yu @Ji @Chu 09-09-2025Participants@Zhang @Xie @Zhang @Yang @Yu @Chu 09-05-2025Participants@Zhang @Xiao @Chu 08-29-2025Participants@Zhang @Guang @Xiao @Chu 08-21-2025Participants@Zhang @Guang @Xiao @Lyu @Chu 08-20-2025Participants@Zhang @Xiang @Zhang @Guang @Chu 08-15-2025Participants@Zhang @Xiao @Zhang @Xu @Chu 08-14-2025Participants@Zhang @Xiao @Xie @Yu @Lyu @Chu 08-13-2025Participants@Zhang @Xiao @Xie @Lyu @Chu 08-12-2025Participants@Zhang @Xiao @Yu @Chu 08-08-2025Participants@Zhang @Xu @Ji @Xiang @Shen @Lyu @Chu 08-07-2025Participants@Zhang @Xie @Yu @Chu 08-04-2025Participants@Zhang @Xiao @Chu 08-03-2025Participants@Tian @Yu @Chen @Xiao @Chu 07-31-2025Participants@Lyu @Zhang @Chu 07-30-2025Participants@Lyu @Yu @Xiao @Xie @Xu @Zhang @Chu 07-24-2025Participants@Lyu @Yu @Xiao @Chu 07-23-2025Participants@Lyu @Xie @Zhang @Xiao @Chu","link":"/life/life-table-tennis-practice/"},{"title":"2025 TikTok Open House","text":"This year, my family is joining me at the open house event.","link":"/life/life-tiktok-open-house-2025/"},{"title":"2025 TikTok Table Tennis Tournament","text":"I was lucky to win the champion this year. By the way, i also won the champion last year(2024)😄. This is the group picture of Final players last year. The prize i got last year is a SONY headphone(as you could see, everyone was holding their prizes). This year, the prize is an Apple Watch. Honestly, i really enjoyed the game. Thank every players for the wonderful games.","link":"/life/life-tiktok-table-tennis-tournament/"},{"title":"Traffic Court Trial Experience","text":"Today, I went to a court trial for my traffic ticket. 背景六月份的时候在一个红绿灯口因为没有右转停三秒（当时正好黄灯变红灯），被监控拍到，然后就寄了一张罚单给我，将近500刀。一般来说收到罚单有几种处理方式： 认罪（guilty），直接交钱，但DMV和保险都会有记录，会影响保费。 认罪（guilty）+ 上traffic school，拿到了certificate之后不会产生记录。 交钱 + 要求court trial，在court上会和法官交流一下，说一下理由什么。 以书面写信的方式contest 我选择的是第三种，因为觉得当时的情况比较模糊，属于不是红灯硬闯的那种，感觉可以为自己争辩一下。而且网上大部分的网友分享的case都是有一个不错的结局的，有罚款减半或者直接dismiss的。选择第三种方式的话最简单的方式就是去寄给你的notice上写的法院地址，去前台交钱+告诉cashier你要求庭审，你就会拿到一张有庭审时间的notice。 环境由于自己是第一次上法院，提早半小时到了，但已经有很多人在等了。个人感觉不需要这么早，我那个庭审的room也是正好在notice上写的时间点才开放。进去之后分左中右三排座位，被告都坐在左边和中间，警察（交警）统一坐在右边。里面大致有这么几类人： 两个类似助手一样的人，负责点名，维护秩序流程，paper work等。 一位西班牙语翻译，坐在被告席旁边，提供给有需要的人。 法官（最后出场） 结局开始庭审了法官会依次报名，到了你就去被告席站着。我之前准备的一套说辞一点也没用上，法官宣读我的case最终被dismiss了，因为给我开罚单的officer没有到场。我就表示了感谢就到房间外等了。过一会儿助手A就会出来把一张纸给你，上面是庭审的结果，包括返还的罚金。 总结一下： 遇到这种交通罚单还是尽量要求庭审，大概率给你开罚单的人是不会来的，省了好几百刀，也不用额外花时间上traffic school。为什么说大概率呢？因为在我前面的6个人的case全都被豁免了。 来体验一趟法院也是为了给自己提个醒，开车要注意安全。毕竟人对于付出成本比较大的事情会记得更加深刻，如果我只是交了钱+上课，可能永远学不到这个lesson。","link":"/life/life-traffic-court-trial-experience/"},{"title":"TikTok Open House Event","text":"2024 TikTok Open House","link":"/life/life-tiktok-open-house/"},{"title":"Tummy Time","text":"Tummy time合集 大概从第三周就开始练习抬头了，进步非常明显。靠自己就已经能把头抬得很高了。宝宝现在好像越来越懒了😂，总是趴着侧在一边一动不动，有一次甚至还睡着了。","link":"/life/life-tummytime/"},{"title":"Vargas Plateau Regional Park","text":"2023感恩节，俯瞰东湾 地址： 2536 Morrison Canyon Rd, Fremont, CA 94539","link":"/life/life-vargas-park/"},{"title":"Trip - Phoenix","text":"八月龄娃七天六夜深度游凤凰城 Day 0:上午11:50的航班，飞行时间一个半小时。由于和凤凰城有一个小时的时差，抵达时已经是下午两点半左右。从机场搭乘Sky Train前往租车中心的路上，透过车窗俯瞰整座城市，高楼屈指可数，显得格外平坦。拿车过程中遇到了一些小插曲。抵达Airbnb后发现车有点小问题，只得联系客服，随后又开回机场换车。一番折腾后，终于顺利换好车。趁着娃睡觉前，赶忙去了一趟超市，补充了适合大人和孩子的食材。 Day 1:上午带娃去Steele Indian School Park溜达。中午吃了一家美式烤肉，Little Miss BBQ，点了一根巨型牛肋排，下午则去了Musical Instrument Museum，欣赏世界各地丰富的乐器展品。 Day 2: 上午附近小公园Encanto Park溜达，下午McCormick-Stillman Railroad Park坐了小火车和参观了火车模型馆，接着去了Old Town Scottsdale，沿着小镇的主街道游览了一遍 Day 3: 上午Desert Botanical Garden欣赏了沙漠特有的植被，中午去吃了一家墨西哥餐厅Mariscos Playa Hermosa，下午在附近著名的地标Hole in the Rock徒步，登上山顶打卡 Day 4: 上午在附近小公园Granada Park散了个步，中午去吃了一家中餐自助，名字很有意思number 1 buffet，味道中规中矩，吃完就去了Wildlife World Zoo, Aquarium &amp; Safari Park，不知道是不是周中的原因，人少之又少，而且感觉内部设施维护的不是很好，基本上所有花钱要坐的ride都没有人排队。 Day 5: 由于前一天太累的，于是只去了附近的Children’s Museum of Phoenix逛了一下，简直是大孩子的天堂。我家娃太小，很多都玩不了。中午终于吃上了第一家在凤凰城的中餐，Old town taste（老城滋味）。味道中规中矩。 Day 6: 早上七点半的飞机谁懂啊，娃还早上四点就醒了，一直不睡。还好一路比较顺利，到了登机口时间还很充裕。回到湾区居然才早上8:00 补充几点： Phoenix物价并没有很感人，感觉和湾区没有差很多，油确实便宜，大概$3一加仑。 吐槽下Phoenix路上的左转道，很多都不带左转箭头灯，只能等对面直行走完，然而直行车巨多。偶尔有几个带箭头的左转绿灯，基本也就5秒左右，排在后面根本来不及过去。 气候太干燥，属于Sonoran Desert的一部分，这几天待得我嘴唇干，手背干，鼻孔也干。娃的皮肤也肉眼可见干燥。 中餐特别少（可能是相对于湾区），中国人也不多。 整个Phoenix并不大，我们所有去的地方离我们airbnb都能控制在30分钟车程。 Phoenix其实挺适合带孩子来玩的，冬天白天温度适宜，能去的地方也不少，而且都比较kids friendly，没有那么多硬核的项目。","link":"/life/life-trip-phoenix/"},{"title":"USS Hornet Aircraft Carrier","text":"Served during World War 2. The USS Hornet (CV‑12) is now permanently berthed as a museum ship in Alameda, California, and is open to the public as the USS Hornet Sea, Air &amp; Space Museum. It is widely known for its historic role in recovering the Apollo 11 and 12 Moon missions. References https://en.wikipedia.org/wiki/USS_Hornet_Sea%2C_Air_%26_Space_Museum?utm_source=chatgpt.com","link":"/life/life-uss-hornet/"},{"title":"Waygu All You Can Eat Experience","text":"First time trying Waygu AYCE. The restaurant we went to: Mikiya Wagyu Shabu House | Santa Clara. Address: 3590 Homestead Rd, Santa Clara, CA 95051 To my surprise, they offer milk tea and freshly squeezed orange juice.","link":"/life/life-waygu-all-you-can-eat-experience/"},{"title":"Venardos Circus","text":"05/8 - 05/18在Newark巡演的马戏团 - Venardos Circus 马戏团的官网：https://venardoscircus.com/tour/ 前几天路过Costco的时候就看到他们已经在搭场地了，还张贴了海报。正好这周末有场次，想来尝尝鲜。非常值得一去的马戏团表演，$28的票，足足表演了一个半小时，每个节目都很精彩。感觉表演者们挺不容易的，每天需要高强度表演两场，还都是危险性比较高的项目。围着马戏团大帐篷周围停着许多房车，应该是这个团的表演者和工作人员的临时居所。接下来到十一月份，他们都会在不同州进行表演。 一个小插曲，早上买票的时候填错了邮箱导致收不到票，给马戏团官方邮箱发了邮件立马得到回复，把票重新发了我一遍，效率十分高👍","link":"/life/life-venardos-circus/"},{"title":"家有小猫","text":"记录下家里小猫一岁的成长历史 Name： 噜妹Race： 美国中毛DOB： 09/01/2022Color： 黑加白Gender： 女 在shelter选了她，这是她的shelter时期的名片（真的好小只） 第一天带回家用纸箱子装着带回来，到家后躲在衣柜里不敢出来 渐渐熟悉了新家，喜欢趴在腿上 吃饭和喝水的家伙必须安排 小小一只～ 各种可爱的睡姿，看来有家的感觉了 她可太喜欢去院子了，想方设法出去， 家里的纱窗已经破的不行了。之前院子里的草还卡在鼻子里，去医院给拔出来的 慢慢占领了床，像个小大人似的 写代码的时候捣乱 因为闹肚子带她去医院，在医院可听话了，趴着一动不动 新玩具爱不释手 越长大越好看～","link":"/life/lumei/"},{"title":"BFS Template","text":"A generic template. 12345678910111213141516171819202122232425262728293031323334struct Coord { int x; int y;};std::queue&lt;Coord&gt; q; // q contains locations we will visit.q.push({i,j}); // Add a starting point to the queue.visited[i][j] = 1; // Mark as visited.std::vector&lt;int&gt; ds{0, 1, 0, -1, 0}; // In a 2D matrix, this is helpful for iterating four adjacent directions.while (!q.empty()) { int size = q.size(); while (size--) { // Iterating all the data in current level. Coord coords = q.front(); int x = coords.x; int y = coords.y; q.pop(); // Remove current node. for (int i = 0; i &lt; 4; i++) { // Start looking for neighbors int nx = x + ds[i]; int ny = y + ds[i+1]; // Skip out-of-bound data and visited data. if (nx &lt; 0 || nx &gt;= m || ny &lt; 0 || ny &gt;= n) continue; if (visited[nx][ny] == 1) continue; // Add new data to the queue and mark as visited q.push({nx,ny}); visited[nx][ny] = 1; } }}","link":"/interview/misc-bfs/"},{"title":"Vasona Lake County Park","text":"位于Los Gatos的一个环湖公园 地址：333 Blossom Hill Rd, Los Gatos, CA 95032入园要付$6，公园里面还有小火车可以坐。 今天尝试了用吃灰已久的单反拍了一些照片, 用起来确实不像手机拍照那样方便。很多设置需要仔细调节才能达到一个比较好的画质，画面经常有过曝的情况。但整体拍出来的感觉是有比手机拍出来的效果要好的，后面会多用单反拍一些照发blog，相信拍照水平会慢慢提升。","link":"/life/life-vasona-lake-county-park/"},{"title":"机场安检与胶卷","text":"在很多美国机场的安检处，都能看到这样的标语 意思是说安检的x光对于ISO800以下的胶卷没有影响，但对于800以上的，就不好说了。想要理解这句话，首先我们要从胶卷的基本原理讲起。 胶卷是什么？ 胶卷是一种覆盖了感光材料（乳剂 emulsion）的塑料薄片，这些感光材料主要是卤化银颗粒（AgBr、AgCl 等），它们对光线非常敏感。 拍照时发生了什么？ 当你按下快门、打开快门帘时，镜头会把光线投射到胶卷上，光线照射到的区域： 感光颗粒会吸收光子，形成“潜影”（看不见的图像）； 之后你拿去显影，这些曝光过的颗粒在化学反应中变成黑色金属银，形成可见的影像； 曝光越多，越黑；曝光越少，越亮；这就是所谓的“底片”。 ISO值本质上就是胶卷对光的“敏感程度”。 ISO高（如1600）：里面的感光颗粒更大、数量更多 → 更容易被X光激发； ISO低（如100）：颗粒更小、密度低 → 不太容易被激发； 胶卷相机通常配不同ISO值的胶卷进行拍摄来适应不同的环境光亮度 常见的胶卷 ISO 值 ISO 值 特点 使用场景 100 清晰、颗粒少，但感光低 户外、阳光充足 200 稍微感光强一点，画质仍很好 室外或明亮室内 400 通用型，适合多数情况 室内、阴天、街拍 800 更适合暗光拍摄，但颗粒更明显 夜景、室内无闪光灯 1600 / 3200 高感光，颗粒重、对比强 演出、新闻、低光环境 X射线也是电磁波，它的原理跟可见光差不多，只不过能量更高，波长更短。这些高能量的射线也会作用在卤化银颗粒上，就像强光一样，在胶卷上留下“假影”。轻微的影响会使得整体画面出现轻度“雾化”——底片灰度提高、对比度下降。严重的情况下会出现条纹、斑点、噪点状污染，尤其在高感光度胶卷上更明显。这些影响是无法通过后期修复的，因为胶卷已经被“假曝光”了。 总结起来，“X光对ISO800以下胶卷无影响”是一种经验性、概率性判断，在一次安检中通常是成立的。但它并非绝对保险，胶卷越高感度、安检次数越多（X光剂量积累）、使用的安检设备越强，对影像质量影响的风险也就越大。","link":"/life/life-xray-film/"},{"title":"Binary Search Insertion With Duplicate Elements","text":"Left-most and right-most insertion with binary search. IntroductionPreviously, I posted an article that introduces 3 different binary search templates: https://chuzcjoe.github.io/2024/05/22/misc-how-to-write-bug-free-binary-search/ Writing binary search code can be tricky, and without careful attention, it’s easy to end up in an infinite loop. Binary search for insertion is even more challenging, particularly when deciding how to adjust the left and right pointers under certain conditions. Fortunately, with the templates I’ve provided, you only need to make slight adjustments to adapt them for insertion purposes. We will reuse the first provided template and make adjustment based on it. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;int binaryInsertMostLeft(std::vector&lt;int&gt;&amp; arr, int target) { int i = 0; int j = arr.size() - 1; while (i &lt;= j) { int mid = (i + j) / 2; if (arr[mid] &gt;= target) j = mid - 1; else i = mid + 1; } return i;}int binaryInsertMostRight(std::vector&lt;int&gt;&amp; arr, int target) { int i = 0; int j = arr.size() - 1; while (i &lt;= j) { int mid = (i + j) / 2; if (arr[mid] &gt; target) j = mid - 1; else i = mid + 1; } return i;}int main() { std::vector&lt;int&gt; nums{1, 1, 2, 5, 5, 8, 10}; std::cout &lt;&lt; &quot;insert to the most left position\\n&quot;; int left = binaryInsertMostLeft(nums, 0); std::cout &lt;&lt; &quot;0 is inserted at index: &quot; &lt;&lt; left &lt;&lt; '\\n'; left = binaryInsertMostLeft(nums, 1); std::cout &lt;&lt; &quot;1 is inserted at index: &quot; &lt;&lt; left &lt;&lt; '\\n'; left = binaryInsertMostLeft(nums, 2); std::cout &lt;&lt; &quot;2 is inserted at index: &quot; &lt;&lt; left &lt;&lt; '\\n'; left = binaryInsertMostLeft(nums, 3); std::cout &lt;&lt; &quot;3 is inserted at index: &quot; &lt;&lt; left &lt;&lt; '\\n'; left = binaryInsertMostLeft(nums, 9); std::cout &lt;&lt; &quot;9 is inserted at index: &quot; &lt;&lt; left &lt;&lt; '\\n'; left = binaryInsertMostLeft(nums, 11); std::cout &lt;&lt; &quot;11 is inserted at index: &quot; &lt;&lt; left &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;insert to the most right position\\n&quot;; int right = binaryInsertMostRight(nums, 0); std::cout &lt;&lt; &quot;0 is inserted at index: &quot; &lt;&lt; right &lt;&lt; '\\n'; right = binaryInsertMostRight(nums, 1); std::cout &lt;&lt; &quot;1 is inserted at index: &quot; &lt;&lt; right &lt;&lt; '\\n'; right = binaryInsertMostRight(nums, 2); std::cout &lt;&lt; &quot;2 is inserted at index: &quot; &lt;&lt; right &lt;&lt; '\\n'; right = binaryInsertMostRight(nums, 3); std::cout &lt;&lt; &quot;3 is inserted at index: &quot; &lt;&lt; right &lt;&lt; '\\n'; right = binaryInsertMostRight(nums, 5); std::cout &lt;&lt; &quot;5 is inserted at index: &quot; &lt;&lt; right &lt;&lt; '\\n'; right = binaryInsertMostRight(nums, 9); std::cout &lt;&lt; &quot;9 is inserted at index: &quot; &lt;&lt; right &lt;&lt; '\\n'; right = binaryInsertMostRight(nums, 11); std::cout &lt;&lt; &quot;11 is inserted at index: &quot; &lt;&lt; right &lt;&lt; '\\n'; return 0;} 123456789101112131415insert to the most left position0 is inserted at index: 01 is inserted at index: 02 is inserted at index: 23 is inserted at index: 39 is inserted at index: 611 is inserted at index: 7insert to the most right position0 is inserted at index: 01 is inserted at index: 22 is inserted at index: 33 is inserted at index: 35 is inserted at index: 59 is inserted at index: 611 is inserted at index: 7 We tested the implementation across various cases, and all results were correct. VisualizationOnly demonstrate left-most insertion. Right-most insertion is the same. Scenario1The inserted number x: a &lt; x &lt; b Scenario2The inserted number x: a == x &lt; b Scenario3The inserted number x: a &lt; x == b Scenario4The inserted number x: a == x == b","link":"/interview/misc-binary-insert/"},{"title":"Summary of Special Member Functions In C++","text":"One example to demonstrate the usage of all C++ special member functions. This is still a pretty popular topic that you will be given during coding interview. Default Constructor: ClassName() = default; Destructor: ~ClassName() = default; Copy Constructor: ClassName(const ClassName&amp;) = default; Copy Assignment Operator: ClassName&amp; operator=(const ClassName&amp;) = default; Move Constructor: ClassName(ClassName&amp;&amp;) = default; Move Assignment Operator: ClassName&amp; operator=(ClassName&amp;&amp;) = default; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;iostream&gt;class Shape {public: Shape(size_t size = 0) : size_(size), data_(size ? new int[size] : nullptr) { std::cout &lt;&lt; &quot;Shape constructed with size &quot; &lt;&lt; size_ &lt;&lt; &quot;\\n&quot;; if (data_) { for (size_t i = 0; i &lt; size_; ++i) { data_[i] = 0; // Initialize data } } } virtual ~Shape() { delete[] data_; std::cout &lt;&lt; &quot;Shape destructed\\n&quot;; } Shape(const Shape&amp; other) : size_(other.size_), data_(other.size_ ? new int[other.size_] : nullptr) { if (data_) { for (size_t i = 0; i &lt; size_; ++i) { data_[i] = other.data_[i]; } } std::cout &lt;&lt; &quot;Shape copy-constructed\\n&quot;; } Shape(Shape&amp;&amp; other) noexcept : size_(other.size_), data_(other.data_) { other.size_ = 0; other.data_ = nullptr; std::cout &lt;&lt; &quot;Shape move-constructed\\n&quot;; } Shape&amp; operator=(const Shape&amp; other) { if (this != &amp;other) { delete[] data_; size_ = other.size_; data_ = other.size_ ? new int[other.size_] : nullptr; if (data_) { for (size_t i = 0; i &lt; size_; ++i) { data_[i] = other.data_[i]; } } } std::cout &lt;&lt; &quot;Shape copy-assigned\\n&quot;; return *this; } Shape&amp; operator=(Shape&amp;&amp; other) noexcept { if (this != &amp;other) { delete[] data_; size_ = other.size_; data_ = other.data_; other.size_ = 0; other.data_ = nullptr; } std::cout &lt;&lt; &quot;Shape move-assigned\\n&quot;; return *this; } virtual void describe() const = 0;protected: size_t size_; int* data_;};class Rectangle : public Shape {public: Rectangle(size_t width = 0, size_t height = 0) : Shape(width * height), _width(width), _height(height) { std::cout &lt;&lt; &quot;Rectangle constructed with width &quot; &lt;&lt; _width &lt;&lt; &quot; and height &quot; &lt;&lt; _height &lt;&lt; &quot;\\n&quot;; } Rectangle(const Rectangle&amp; other) : Shape(other), _width(other._width), _height(other._height) { std::cout &lt;&lt; &quot;Rectangle copy-constructed\\n&quot;; } Rectangle(Rectangle&amp;&amp; other) noexcept : Shape(std::move(other)), _width(other._width), _height(other._height) { other._width = 0; other._height = 0; std::cout &lt;&lt; &quot;Rectangle move-constructed\\n&quot;; } Rectangle&amp; operator=(const Rectangle&amp; other) { if (this != &amp;other) { Shape::operator=(other); _width = other._width; _height = other._height; } std::cout &lt;&lt; &quot;Rectangle copy-assigned\\n&quot;; return *this; } Rectangle&amp; operator=(Rectangle&amp;&amp; other) noexcept { if (this != &amp;other) { Shape::operator=(std::move(other)); _width = other._width; _height = other._height; other._width = 0; other._height = 0; } std::cout &lt;&lt; &quot;Rectangle move-assigned\\n&quot;; return *this; } ~Rectangle() override { std::cout &lt;&lt; &quot;Rectangle destructed\\n&quot;; } void describe() const override { std::cout &lt;&lt; &quot;Rectangle with width &quot; &lt;&lt; _width &lt;&lt; &quot; and height &quot; &lt;&lt; _height &lt;&lt; &quot;\\n&quot;; }private: size_t _width; size_t _height;};int main() { std::cout &lt;&lt; &quot;Creating rect1\\n&quot;; Rectangle rect1(3, 2); // Outputs: Shape constructed, Rectangle constructed std::cout &lt;&lt; &quot;\\nCopy constructing rect2 from rect1\\n&quot;; Rectangle rect2(rect1); // Outputs: Shape copy-constructed, Rectangle copy-constructed std::cout &lt;&lt; &quot;\\nMove constructing rect3 from rect1\\n&quot;; Rectangle rect3(std::move(rect1)); // Outputs: Shape move-constructed, Rectangle move-constructed std::cout &lt;&lt; &quot;\\nCopy assigning rect2 to rect3\\n&quot;; rect2 = rect3; // Outputs: Shape copy-assigned, Rectangle copy-assigned std::cout &lt;&lt; &quot;\\nMove assigning rect3 to rect2\\n&quot;; rect3 = std::move(rect2); // Outputs: Shape move-assigned, Rectangle move-assigned std::cout &lt;&lt; &quot;\\nDescribing rect3\\n&quot;; rect3.describe(); // Outputs: Rectangle with width 3 and height 2 std::cout &lt;&lt; &quot;\\nEnd of main, destroying objects\\n&quot;; // Outputs: Rectangle destructed, Shape destructed for each object return 0;} 123456789101112131415161718192021222324252627282930Creating rect1Shape constructed with size 6Rectangle constructed with width 3 and height 2Copy constructing rect2 from rect1Shape copy-constructedRectangle copy-constructedMove constructing rect3 from rect1Shape move-constructedRectangle move-constructedCopy assigning rect2 to rect3Shape copy-assignedRectangle copy-assignedMove assigning rect3 to rect2Shape move-assignedRectangle move-assignedDescribing rect3Rectangle with width 3 and height 2End of main, destroying objectsRectangle destructedShape destructedRectangle destructedShape destructedRectangle destructedShape destructed","link":"/cpp/misc-cpp-special-member-functions/"},{"title":"Cache Algorithms and Implementations","text":"Introduce some common CPU cache algorithms and their implementations. 1. LRU (Least Recent Used)1.1 How it works 1.2 ImplementationThe key is to have a linked list that simulate a cache storage and a hashtable to keep track of the data in the cache. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;class LRUCache {private: struct Node { int key; int value; Node(int k, int v) : key(k), value(v) {} }; int capacity; std::list&lt;Node&gt; cacheList; // Doubly linked list to store cache items std::unordered_map&lt;int, std::list&lt;Node&gt;::iterator&gt; cacheMap; // Hash map to store key-node pairs void moveToFront(int key) { auto nodeIt = cacheMap[key]; cacheList.splice(cacheList.begin(), cacheList, nodeIt); }public: LRUCache(int cap) : capacity(cap) {} int get(int key) { if (cacheMap.find(key) == cacheMap.end()) { return -1; // Key not found } moveToFront(key); return cacheList.begin()-&gt;value; } void put(int key, int value) { if (cacheMap.find(key) != cacheMap.end()) { auto nodeIt = cacheMap[key]; nodeIt-&gt;value = value; moveToFront(key); return; } if (cacheMap.size() &gt;= capacity) { int keyToRemove = cacheList.back().key; cacheList.pop_back(); cacheMap.erase(keyToRemove); } cacheList.emplace_front(key, value); cacheMap[key] = cacheList.begin(); } void display() const { for (const auto&amp; node : cacheList) { std::cout &lt;&lt; node.key &lt;&lt; &quot;: &quot; &lt;&lt; node.value &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; }};int main() { LRUCache cache(3); cache.put(1, 1); cache.put(2, 2); cache.put(3, 3); std::cout &lt;&lt; &quot;Initial cache:&quot; &lt;&lt; std::endl; cache.display(); std::cout &lt;&lt; &quot;Get 1: &quot; &lt;&lt; cache.get(1) &lt;&lt; std::endl; cache.display(); cache.put(4, 4); std::cout &lt;&lt; &quot;Cache after adding 4:&quot; &lt;&lt; std::endl; cache.display(); std::cout &lt;&lt; &quot;Get 2: &quot; &lt;&lt; cache.get(2) &lt;&lt; std::endl; cache.display(); cache.put(5, 5); std::cout &lt;&lt; &quot;Cache after adding 5:&quot; &lt;&lt; std::endl; cache.display(); return 0;} 12345678910Initial cache:3: 3 2: 2 1: 1 Get 1: 11: 1 3: 3 2: 2 Cache after adding 4:4: 4 1: 1 3: 3 Get 2: -14: 4 1: 1 3: 3 Cache after adding 5:5: 5 4: 4 1: 1 2. LFU (Least Frequently Used)2.1 How it works 2.2 Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class LFUCache {private: // Node structure to store key, value, and frequency struct Node { int key; int value; int freq; Node(int k, int v, int f) : key(k), value(v), freq(f) {} }; int capacity; int minFreq; std::unordered_map&lt;int, std::list&lt;Node&gt;::iterator&gt; keyNodeMap; // Maps key to node std::unordered_map&lt;int, std::list&lt;Node&gt;&gt; freqListMap; // Maps frequency to list of nodespublic: LFUCache(int cap) : capacity(cap), minFreq(0) {} int get(int key) { if (keyNodeMap.find(key) == keyNodeMap.end()) { return -1; // Key not found } auto nodeIt = keyNodeMap[key]; int value = nodeIt-&gt;value; int freq = nodeIt-&gt;freq; // Remove the node from the current frequency list freqListMap[freq].erase(nodeIt); if (freqListMap[freq].empty()) { freqListMap.erase(freq); if (minFreq == freq) { minFreq++; } } // Insert the node into the next frequency list freq++; freqListMap[freq].emplace_front(key, value, freq); keyNodeMap[key] = freqListMap[freq].begin(); return value; } void put(int key, int value) { if (capacity == 0) return; if (keyNodeMap.find(key) != keyNodeMap.end()) { // Key already exists, update the value and frequency auto nodeIt = keyNodeMap[key]; nodeIt-&gt;value = value; get(key); // Update frequency return; } if (keyNodeMap.size() &gt;= capacity) { // Evict the least frequently used node auto nodeToEvict = freqListMap[minFreq].back(); keyNodeMap.erase(nodeToEvict.key); freqListMap[minFreq].pop_back(); if (freqListMap[minFreq].empty()) { freqListMap.erase(minFreq); } } // Insert the new node minFreq = 1; freqListMap[minFreq].emplace_front(key, value, minFreq); keyNodeMap[key] = freqListMap[minFreq].begin(); }};int main() { LFUCache cache(2); cache.put(1, 1); cache.put(2, 2); std::cout &lt;&lt; &quot;Get 1: &quot; &lt;&lt; cache.get(1) &lt;&lt; std::endl; // returns 1 cache.put(3, 3); // evicts key 2 std::cout &lt;&lt; &quot;Get 2: &quot; &lt;&lt; cache.get(2) &lt;&lt; std::endl; // returns -1 (not found) std::cout &lt;&lt; &quot;Get 3: &quot; &lt;&lt; cache.get(3) &lt;&lt; std::endl; // returns 3 cache.put(4, 4); // evicts key 1 std::cout &lt;&lt; &quot;Get 1: &quot; &lt;&lt; cache.get(1) &lt;&lt; std::endl; // returns -1 (not found) std::cout &lt;&lt; &quot;Get 3: &quot; &lt;&lt; cache.get(3) &lt;&lt; std::endl; // returns 3 std::cout &lt;&lt; &quot;Get 4: &quot; &lt;&lt; cache.get(4) &lt;&lt; std::endl; // returns 4 return 0;} 123456Get 1: 1Get 2: -1Get 3: 3Get 1: -1Get 3: 3Get 4: 4 3. FIFO (First In First Out)3.1 How it works 3.2 Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;class FIFOCache {private: int capacity; std::queue&lt;int&gt; cacheQueue; // Queue to store keys in the order they were added std::unordered_map&lt;int, int&gt; cacheMap; // Hash map to store key-value pairspublic: FIFOCache(int cap) : capacity(cap) {} int get(int key) { if (cacheMap.find(key) == cacheMap.end()) { return -1; // Key not found } return cacheMap[key]; } void put(int key, int value) { if (cacheMap.size() &gt;= capacity) { int keyToRemove = cacheQueue.front(); cacheQueue.pop(); cacheMap.erase(keyToRemove); } cacheQueue.push(key); cacheMap[key] = value; } void display() const { std::queue&lt;int&gt; tempQueue = cacheQueue; while (!tempQueue.empty()) { int key = tempQueue.front(); tempQueue.pop(); std::cout &lt;&lt; key &lt;&lt; &quot;: &quot; &lt;&lt; cacheMap.at(key) &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; std::endl; }};int main() { FIFOCache cache(3); cache.put(1, 1); cache.put(2, 2); cache.put(3, 3); std::cout &lt;&lt; &quot;Initial cache:&quot; &lt;&lt; std::endl; cache.display(); std::cout &lt;&lt; &quot;Get 1: &quot; &lt;&lt; cache.get(1) &lt;&lt; std::endl; cache.display(); cache.put(4, 4); std::cout &lt;&lt; &quot;Cache after adding 4:&quot; &lt;&lt; std::endl; cache.display(); std::cout &lt;&lt; &quot;Get 2: &quot; &lt;&lt; cache.get(2) &lt;&lt; std::endl; cache.display(); cache.put(5, 5); std::cout &lt;&lt; &quot;Cache after adding 5:&quot; &lt;&lt; std::endl; cache.display(); return 0;} 12345678910Initial cache:1: 1 2: 2 3: 3 Get 1: 11: 1 2: 2 3: 3 Cache after adding 4:2: 2 3: 3 4: 4 Get 2: 22: 2 3: 3 4: 4 Cache after adding 5:3: 3 4: 4 5: 5 References https://zxi.mytechroad.com/blog/hashtable/leetcode-460-lfu-cache/#google_vignette","link":"/interview/misc-cache-algorithms/"},{"title":"Effective Modern C++","text":"By Scott Meyers.","link":"/resource/misc-effective-modern-cpp/"},{"title":"Cross Compile libjpeg for Android","text":"Host machine: MacOSTarget device: Android armv8a 1. Cross compile libjpeg1.1 Step 1Download source code. 1git clone https://github.com/libjpeg-turbo/libjpeg-turbo.git 1.2 Download Android NDKContains toolchains for cross compilation. https://developer.android.com/ndk/downloads 1.3 Create a bash script for buildCreate a build.sh at the root directory of the project. 1234567891011121314151617181920212223242526#!/bin/bash# Set these variables to suit your needsNDK_PATH=&quot;/Users/zongchengchu/Library/Android/sdk/ndk/25.1.8937393&quot; # Full path to the NDK directoryTOOLCHAIN=&quot;clang&quot; # &quot;gcc&quot; or &quot;clang&quot;. Use &quot;gcc&quot; with NDK r14b and earlier, and &quot;clang&quot; with NDK r17c and laterANDROID_VERSION=&quot;21&quot; # Minimum version of Android to support. &quot;21&quot; or later is required for a 64-bit buildBUILD_DIR=&quot;build&quot; # Directory where the build will take placeSOURCE_DIR=&quot;..&quot; # Directory containing the source codeADDITIONAL_CMAKE_FLAGS=&quot;&quot; # Additional CMake flags if any#rm -rf ${BUILD_DIR}# Navigate to the build directorymkdir -p ${BUILD_DIR}cd ${BUILD_DIR}# Run CMake to configure the buildcmake -G&quot;Unix Makefiles&quot; \\ -DANDROID_ABI=arm64-v8a \\ -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\ -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\ -DCMAKE_ASM_FLAGS=&quot;--target=aarch64-linux-android${ANDROID_VERSION}&quot; \\ -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\ ${ADDITIONAL_CMAKE_FLAGS} ..# Run make to build the projectmake 1.4 BuildRun the following command for build. 12chmod +x build.sh./build.sh You should see the generated files at ./build folder. 2. A simple demo that can run on Android devicescode: https://github.com/chuzcjoe/libjpeg_for_android 2.1 Project structure12345678910111213.├── CMakeLists.txt├── build.sh├── imgs│ └── input.jpg├── include│ ├── jconfig.h│ ├── jmorecfg.h│ ├── jpeglib.h│ └── turbojpeg.h├── lib│ └── libturbojpeg.a└── main.cpp You can get all the needed header files from step 1.4. The static library is located at build folder. 2.2 CMakeLists.txt1234567891011121314151617181920212223242526cmake_minimum_required(VERSION 3.10)# Set Android specific variablesset(ANDROID_ABI arm64-v8a)set(ANDROID_PLATFORM android-21)set(ANDROID_TOOLCHAIN clang)set(CMAKE_TOOLCHAIN_FILE /Users/zongchengchu/Library/Android/sdk/ndk/25.1.8937393/build/cmake/android.toolchain.cmake)# Set CMake ASM flagsset(CMAKE_ASM_FLAGS &quot;--target=aarch64-linux-android21&quot;)project(MyTurboJPEGProject)# Set the path to the TurboJPEG include directory and libraryset(TURBOJPEG_INCLUDE_DIR &quot;${CMAKE_CURRENT_SOURCE_DIR}/include&quot;)set(TURBOJPEG_LIBRARY &quot;${CMAKE_CURRENT_SOURCE_DIR}/lib/libturbojpeg.a&quot;)# Include the TurboJPEG headersinclude_directories(${TURBOJPEG_INCLUDE_DIR})# Add your executableadd_executable(MyTurboJPEGProject main.cpp)# Link against the TurboJPEG librarytarget_link_libraries(MyTurboJPEGProject ${TURBOJPEG_LIBRARY}) 2.3 Build script123456789101112131415161718192021222324252627282930313233343536#!/bin/bash# Define variablesbuild_dir=&quot;build&quot;device_dir=&quot;/data/local/tmp/jpeg_demo&quot;img_dir=&quot;imgs&quot;# Clean and create build directoryrm -rf &quot;${build_dir}&quot;mkdir -p &quot;${build_dir}&quot;cd &quot;${build_dir}&quot; || exit# Run cmake and makecmake ..make# Go back to the root directorycd ..# Prepare the device directoryadb shell &quot;rm -rf ${device_dir}&quot;adb shell &quot;mkdir -p ${device_dir}&quot;# Push the executable to the deviceadb push &quot;${build_dir}/MyTurboJPEGProject&quot; &quot;${device_dir}&quot;# Push all images to the device directoryadb push &quot;${img_dir}/.&quot; &quot;${device_dir}/&quot;# Change the permissions of the executable to make it executableadb shell &quot;chmod +x ${device_dir}/MyTurboJPEGProject&quot;# Run the executable on the deviceadb shell &quot;cd ${device_dir} &amp;&amp; ./MyTurboJPEGProject input.jpg save.jpg&quot;adb pull &quot;${device_dir}/save.jpg&quot; &quot;./&quot; 2.4 Run on devices1./build.sh Running the script will enable you to cross-compile the program, and it will automatically transfer the necessary executable and image files to the device directory. After execution, the output image will be saved and retrieved from the device. The C++ program simply adds brightness to the input image.","link":"/misc/misc-cross-compile-libjpeg-for-android-armv8a/"},{"title":"Factory Method vs Abstract Factory","text":"Both belong to creational design pattern. 1. IntroductionFactory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created. Abstract Factory is a creational design pattern that lets you produce families of related objects without specifying their concrete classes. Here is a greate analogy to understand the difference: Imagine you are running a factory that produces paintings. Factory Method: “One Artist, One Painting Style” You have different artists (subclasses), and each artist specializes in one type of painting (product). The base class provides a method createPainting(), and each artist (subclass) decides what kind of painting they create. Example: A Landscape Artist creates landscape paintings. A Portrait Artist creates portrait paintings. If you add a Modern Artist, they create modern paintings.Key Idea: The factory method lets subclasses decide which single product to create. Abstract Factory: “A Complete Art Studio” Now, instead of just one type of painting, you need to provide a full art experience—paintings, frames, and brushes. You create a factory for each style of art, and each factory produces a family of related products. Example: A Landscape Art Studio produces: Landscape Paintings Wooden Frames Oil Brushes A Modern Art Studio produces: Abstract Paintings Metal Frames Acrylic Brushes Key Idea: The abstract factory ensures that related products are created together. 2. ExamplesFactory method. factory_method.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;// Factory method// productclass VideoDecoder {public: virtual void decode(const std::string&amp; file_name) = 0; virtual ~VideoDecoder()= default;};// concrete product1class H264Decoder : public VideoDecoder{public: virtual void decode(const std::string&amp; file_name) override { std::cout &lt;&lt; &quot;H264Decoder decode: &quot; &lt;&lt; file_name + '\\n'; }};// concrete product2class VP9Decoder : public VideoDecoder{public: virtual void decode(const std::string&amp; file_name) override { std::cout &lt;&lt; &quot;VP9Decoder decode: &quot; &lt;&lt; file_name + '\\n'; }};// creatorclass DecoderFactory {public: virtual std::unique_ptr&lt;VideoDecoder&gt; createDecoder() = 0; virtual ~DecoderFactory() = default;};// concrete creatorclass H264DecoderFactory : public DecoderFactory {public: virtual std::unique_ptr&lt;VideoDecoder&gt; createDecoder() override { return std::make_unique&lt;H264Decoder&gt;(); }};// concrete creatorclass VP9DecoderFactory : public DecoderFactory {public: virtual std::unique_ptr&lt;VideoDecoder&gt; createDecoder() override { return std::make_unique&lt;VP9Decoder&gt;(); }};void playVideo(DecoderFactory* factory, const std::string&amp; file) { auto decoder = factory-&gt;createDecoder(); decoder-&gt;decode(file);}int main() { // client code H264DecoderFactory h264; VP9DecoderFactory vp9; playVideo(&amp;h264, &quot;video1.mp4&quot;); playVideo(&amp;h264, &quot;video2.mp4&quot;); playVideo(&amp;vp9, &quot;video3.mp4&quot;); playVideo(&amp;vp9, &quot;video4.mp4&quot;);} Abstract factory. abstract_factory.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;memory&gt;// Abstract Product A: Buttonclass Button {public: virtual void render() = 0; virtual ~Button() = default;};// Abstract Product B: Checkboxclass Checkbox {public: virtual void render() = 0; virtual ~Checkbox() = default;};// Concrete Products for Windowsclass WindowsButton : public Button {public: void render() override { std::cout &lt;&lt; &quot;Rendering Windows-style Button\\n&quot;; }};class WindowsCheckbox : public Checkbox {public: void render() override { std::cout &lt;&lt; &quot;Rendering Windows-style Checkbox\\n&quot;; }};// Concrete Products for Macclass MacButton : public Button {public: void render() override { std::cout &lt;&lt; &quot;Rendering Mac-style Button\\n&quot;; }};class MacCheckbox : public Checkbox {public: void render() override { std::cout &lt;&lt; &quot;Rendering Mac-style Checkbox\\n&quot;; }};// Abstract Factory Interfaceclass UIFactory {public: virtual std::unique_ptr&lt;Button&gt; createButton() = 0; virtual std::unique_ptr&lt;Checkbox&gt; createCheckbox() = 0; virtual ~UIFactory() = default;};// Concrete Factory for Windowsclass WindowsUIFactory : public UIFactory {public: std::unique_ptr&lt;Button&gt; createButton() override { return std::make_unique&lt;WindowsButton&gt;(); } std::unique_ptr&lt;Checkbox&gt; createCheckbox() override { return std::make_unique&lt;WindowsCheckbox&gt;(); }};// Concrete Factory for Macclass MacUIFactory : public UIFactory {public: std::unique_ptr&lt;Button&gt; createButton() override { return std::make_unique&lt;MacButton&gt;(); } std::unique_ptr&lt;Checkbox&gt; createCheckbox() override { return std::make_unique&lt;MacCheckbox&gt;(); }};// Client Codevoid buildUI(UIFactory&amp; factory) { auto button = factory.createButton(); auto checkbox = factory.createCheckbox(); button-&gt;render(); checkbox-&gt;render();}int main() { WindowsUIFactory windowsFactory; MacUIFactory macFactory; std::cout &lt;&lt; &quot;Windows UI:\\n&quot;; buildUI(windowsFactory); std::cout &lt;&lt; &quot;\\nMac UI:\\n&quot;; buildUI(macFactory); return 0;}","link":"/misc/misc-factory-design/"},{"title":"Display Correct Aspect Ratio of Camera Preview in Android","text":"In this post, we’ll dive into the key concepts and techniques for adjusting the size of a SurfaceView to match the camera preview’s aspect ratio and ensure a distortion-free display. 1. Orientation(s)Before we get into the details, it’s important to first understand how orientation works in Android and how it affects camera previews. 1.1 Display OrientationDisplay orientation describes the current rotation of the device screen. To obtain the orientation, we could use WindowManager. 12WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);int rotation = windowManager.getDefaultDisplay().getRotation(); 1.2 Camera Sensor OrientationCamera sensor orientation refers to the angle between the physical orientation of the camera sensor and the device’s natural (unrotated) display orientation. This value is a fixed property of the camera hardware, and you can retrieve it like this: 123CameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);int sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION); On most smartphones, the sensor orientation is 90 degrees. The image below illustrates what this actually means. Since the sensor is rotated 90 degrees relative to the screen, any image it captures will also be rotated accordingly. When previewing with something like a SurfaceView, the Camera2 API compensates for this rotation automatically to ensure the image looks correct to the user. However, it does this by swapping the width and height of the preview buffer, which can lead to visual distortions—especially when the SurfaceView's aspect ratio doesn’t match the camera preview’s. This automatic scaling often results in vertically stretched or squashed images, as shown below: 2. Root Cause of DistortionLet’s assume the image we capture from the image sensor is 1920x1080. The root cause of this problem is that the image size mismatches the SurfaceView size (1080x2308). In Android, a SurfaceView is a special kind of View that provides a dedicated drawing surface embedded inside the view hierarchy. However, it’s a bit unique compared to regular views because it has a separate Surface that is managed independently by the window manager. By default, The Surface matches the size of the SurfaceView after layout is complete. However, Surface can also have its own size. If the Surface buffer size is larger or smaller than the SurfaceView, scaling or clipping may occur. Let’s rephrase the root cause in the context of SurfaceView and its associated Surface. By default, Surface has the same size as SurfaceView. And if we set SurfaceView to match the parent, then SurfaceView is determiend by its parent. For example: 1234567891011&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.example.camera.SurfaceView android:id=&quot;@+id/surfaceView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/FrameLayout&gt; Camera stream outputs images with size of 1920x1080 and renders to Surface‘s buffer. Since the buffer size is 1080x2308, the image will be resized at this stage. The buffer is then drawed on the View for display. 3. SolutionThere are several ways to address this issue. In this post, I’ll present a simple and effective approach: center-crop. The core idea is to properly adjust the Surface buffer size and the View dimensions. Setting the correct Surface buffer size ensures the received image isn’t resized or distorted. Configuring the appropriate View size ensures the image is displayed with the correct aspect ratio. In order to display the original image with correct aspect ratio 1080/1920=0.5625, we fix Surface buffer size to be the same as image size. We also adjsut the View dimension to achieve the same aspect ratio. Here, we have two choices: either keep the short side or the long side. Keeping the short side will make the View smaller and leaving black space vertically. Keeping the long side will still fill up the entire screen but the preview is cropped at two sides. We need a customized SurfaceView class. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * A SurfaceView that can be adjusted to a specified aspect ratio and * handles proper scaling to fit the aspect ratio while filling the screen. */public class CustomSurfaceView extends SurfaceView { private static final String TAG = CustomSurfaceView.class.getSimpleName(); private float aspectRatio = 0f; public CustomSurfaceView(Context context) { super(context, null); } public CustomSurfaceView(Context context, AttributeSet attrs) { super(context, attrs, 0); } public CustomSurfaceView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } /** * Sets the aspect ratio for this view. The size of the view will be * measured based on the ratio calculated from the parameters. * * @param width Camera resolution horizontal size * @param height Camera resolution vertical size */ public void setAspectRatio(int width, int height) { if (width &lt;= 0 || height &lt;= 0) { throw new IllegalArgumentException(&quot;Size cannot be negative&quot;); } aspectRatio = (float) width / height; getHolder().setFixedSize(width, height); // Fix Surface buffer size requestLayout(); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int width = MeasureSpec.getSize(widthMeasureSpec); int height = MeasureSpec.getSize(heightMeasureSpec); if (aspectRatio == 0f) { setMeasuredDimension(width, height); } else { float actualRatio = (width &gt; height) ? aspectRatio : (1f / aspectRatio); int newWidth; int newHeight; if (width &lt; height * actualRatio) { newHeight = height; newWidth = Math.round(height * actualRatio); } else { newWidth = width; newHeight = Math.round(width / actualRatio); } Log.d(TAG, &quot;Measured dimensions set: &quot; + newWidth + &quot; x &quot; + newHeight); setMeasuredDimension(newWidth, newHeight); } }}","link":"/misc/misc-display-correct-aspect-ratio-camera-preview/"},{"title":"Learning Resources (Updating)","text":"A Continuously Evolving Collection of Exceptional Learning Resources. Practice Leetcode by category zhihu link: https://zhuanlan.zhihu.com/p/349940945 EfficientML by Song Han (MIT) course website: https://hanlab.mit.edu/courses/2023-fall-65940 youtube: https://www.youtube.com/watch?v=rCFvPEQTxKI&amp;list=PL80kAHvQbh-pT4lCkDT53zT8DKmhE0idB OpenGL tutorial link: https://learnopengl.com/Introduction github: https://github.com/JoeyDeVries/LearnOpenGL Android Camera2 (Kotlin) github: https://github.com/android/camera-samples/tree/main Introduction to computer graphics (UCSB) video: https://www.bilibili.com/video/BV1X7411F744?p=1&amp;vd_source=03ff35a8eedf311643a5f6b9e899ba48 website: https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html C++ design pattern book: https://gameprogrammingpatterns.com/contents.html video: https://www.youtube.com/watch?v=ILgiCy6IXLw&amp;list=PLvv0ScY6vfd9wBflF0f6ynlDQuaeKYzyc Programming and Intro Data Structureshttps://eecs280.org/ HDR tutorial(in Chinese)https://juejin.cn/post/7205908717886865469 Fourier Analysishttps://www.youtube.com/playlist?list=PLMrJAkhIeNNT_Xh3Oy0Y4LTj0Oxo8GqsC Effective C++https://www.bugs.frozent.pl/Effective%20Modern%20C++%20(%20PDFDrive.com%20).pdf OpenGLEShttps://github.com/githubhaohao/NDK_OpenGLES_3_0 OpenGL based Camera2https://github.com/githubhaohao/OpenGLCamera2 FFmpeg on Androidhttps://github.com/githubhaohao/LearnFFmpeg","link":"/misc/misc-great-resources/"},{"title":"Add Page View Count to Hexo Icarus Theme","text":"In the latest updates to Hexo Icarus theme, the page view count is not showing by default. To add page view count at the footer section, we need to modify the code a little bit. Modify /node_modules/hexo-theme-icarus/layout/common/footer.jsx 1234567891011121314151617181920showVisitorCounter,visitorCounterTitle,showPageViewCounter, // addedpageViewCounterTitle // added{showVisitorCounter ? &lt;br /&gt; : null}{showVisitorCounter ? &lt;span id=&quot;busuanzi_container_site_uv&quot; dangerouslySetInnerHTML={{ __html: visitorCounterTitle }}&gt;&lt;/span&gt; : null}// added {showPageViewCounter ? &lt;br /&gt; : null}{showPageViewCounter ? &lt;span id=&quot;busuanzi_container_site_pv&quot; dangerouslySetInnerHTML={{ __html: pageViewCounterTitle }}&gt;&lt;/span&gt; : null}showVisitorCounter: plugins &amp;&amp; plugins.busuanzi === true, visitorCounterTitle: _p('plugin.visitor_count', '&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;0&lt;/span&gt;'),// addedshowPageViewCounter: plugins &amp;&amp; plugins.busuanzi === true, pageViewCounterTitle: _p('plugin.visit', '&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;0&lt;/span&gt;') Modify node_modules/hexo-theme-icarus/languages/en.yml 12345plugin: backtotop: 'Back to top' visit_count: '%s&amp;nbsp;visits' visitor_count: 'uv %s' visit: 'pv %s'","link":"/misc/misc-hexo-icarus-add-page-view/"},{"title":"Cross Compile FFmpeg","text":"Cross compile FFmpeg on MacOS for Android 1. Prepare FFmpeg and Android NDKFFmpeg 12345678// 1. Download FFMpeg (4.2.2 for this tutotial)https://ffmpeg.org/releases/// 2. unziptar -jxvf ffmpeg-4.2.2.tar.bz2// 3. configure./configure --disable-x86asm Android NDK 1https://developer.android.google.cn/ndk/downloads 2. BuildIn the unzipped folder ffmpeg-4.2.2, create a new shell script build_android.sh. build_android.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/sh# NDK path, android studio has downloaded sdk, inside the sdk folder, there are multiple ndk versions. I am using 26.1.10909125 here.NDK=~/Library/Android/sdk/ndk/26.1.10909125# Target OSARCH=aarch64CPU=arm64-v8a# Android APIAPI=21# Output path: /android/arm64-v8aOUTPUT=$(pwd)/android/$CPU# NDK toolchain pathTOOLCHAIN=$NDK/toolchains/llvm/prebuilt/darwin-x86_64SYSROOT_L=$TOOLCHAIN/sysroot/usr/lib/aarch64-linux-androidGCC_L=$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/lib/gcc/aarch64-linux-android/4.9.xbuild_arm64() { echo &quot;\\033[32m Compiling FFmpeg for $CPU \\033[0m&quot; ./configure \\ --target-os=android \\ --prefix=$OUTPUT \\ --arch=$ARCH \\ --sysroot=$TOOLCHAIN/sysroot \\ --enable-neon \\ --enable-hwaccels \\ --enable-gpl \\ --disable-postproc \\ --disable-debug \\ --enable-small \\ --enable-jni \\ --enable-mediacodec \\ --enable-decoder=h264_mediacodec \\ --enable-static \\ --enable-shared \\ --disable-doc \\ --enable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-avdevice \\ --disable-doc \\ --disable-symver \\ --enable-cross-compile \\ --cross-prefix=$TOOLCHAIN/bin/aarch64-linux-android- \\ --cc=$TOOLCHAIN/bin/aarch64-linux-android$API-clang \\ --cxx=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++ \\ --extra-cflags=&quot;-fpic -I$OUTPUT/include&quot; \\ --extra-ldflags=&quot;-lc -ldl -lm -lz -llog -lgcc -L$OUTPUT/lib&quot; make clean all make -j8 make install echo &quot;\\033[32m The Compilation of FFmpeg for $CPU is completed \\033[0m&quot;}build_arm64 To build 12chmod +x build_android.sh./build_android.sh After successful build, we will have needed libs and headers under android/arm64-v8a 3. Test FFmpeg on AndroidBuild a simple demo in Android studio to test if FFmpeg works. We place the ffmpeg headers under cpp/include and all the libraries under jniLibs/arm64-v8a. Java client code MainActivity.java12345678910public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_main); ((TextView)findViewById(R.id.text_view)).setText(FFmpegPlay.getFFmpegVersion()); }} FFmpegplay.java1234567891011public class FFmpegPlay { static { System.loadLibrary(&quot;ffmpegtest&quot;); } public static String getFFmpegVersion() { return nativeGetFFmpegVersion(); } private static native String nativeGetFFmpegVersion();} Native code ffmpegtest.cpp12345678910111213141516171819202122232425262728293031323334353637#include &lt;jni.h&gt;#include &lt;cstring&gt;#include &quot;util/log.h&quot;extern &quot;C&quot; {#include &lt;libavcodec/version.h&gt;#include &lt;libavcodec/avcodec.h&gt;#include &lt;libavformat/version.h&gt;#include &lt;libavutil/version.h&gt;#include &lt;libavfilter/version.h&gt;#include &lt;libswresample/version.h&gt;#include &lt;libswscale/version.h&gt;}extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_example_ffmpegtest_FFmpegPlay_nativeGetFFmpegVersion(JNIEnv *env, jclass clazz) { char strBuffer[1024 * 4] = {0}; strcat(strBuffer, &quot;libavcodec : &quot;); strcat(strBuffer, AV_STRINGIFY(LIBAVCODEC_VERSION)); strcat(strBuffer, &quot;\\nlibavformat : &quot;); strcat(strBuffer, AV_STRINGIFY(LIBAVFORMAT_VERSION)); strcat(strBuffer, &quot;\\nlibavutil : &quot;); strcat(strBuffer, AV_STRINGIFY(LIBAVUTIL_VERSION)); strcat(strBuffer, &quot;\\nlibavfilter : &quot;); strcat(strBuffer, AV_STRINGIFY(LIBAVFILTER_VERSION)); strcat(strBuffer, &quot;\\nlibswresample : &quot;); strcat(strBuffer, AV_STRINGIFY(LIBSWRESAMPLE_VERSION)); strcat(strBuffer, &quot;\\nlibswscale : &quot;); strcat(strBuffer, AV_STRINGIFY(LIBSWSCALE_VERSION)); strcat(strBuffer, &quot;\\navcodec_configure : \\n&quot;); strcat(strBuffer, avcodec_configuration()); strcat(strBuffer, &quot;\\navcodec_license : &quot;); strcat(strBuffer, avcodec_license()); LOGCATE(&quot;GetFFmpegVersion\\n%s&quot;, strBuffer); return env-&gt;NewStringUTF(strBuffer);} CMakeLists.txt12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=gnu++11&quot;)set(jnilibs ${CMAKE_SOURCE_DIR}/../jniLibs)set(libname ffmpegtest)include_directories( ${CMAKE_SOURCE_DIR}/include ${CMAKE_SOURCE_DIR}/util)link_directories( ${jnilibs}/${ANDROID_ABI})file(GLOB src-files ${CMAKE_SOURCE_DIR}/*.cpp)add_library( ${libname} SHARED ${src-files})set(third-party-libs avformat avcodec avfilter swresample swscale avutil)set(native-libs android mediandk EGL GLESv3 OpenSLES log m z)target_link_libraries( ${libname} ${log-lib} ${third-party-libs} ${native-libs}) Result","link":"/misc/misc-ffmpeg-start/"},{"title":"Hexo Inline Code Style","text":"Modify the default Hexo inline code style. Hexo uses highlighted red text for inline code style which is pretty ugly from my perspective. We could modify the default style and replace it with more concise and professional code style. If you are using Icarus Theme, you can go to node_modules/hexo-theme-icarus/include/style/article.styl, and apply the changes. 123456789code padding: 0 background: transparent overflow-wrap: break-word &amp;:not(pre &gt; code) background-color: #f0f0f0 color: #333333 padding: 3px 4px border-radius: 5px","link":"/misc/misc-hexo-inline-code-style/"},{"title":"How to Write Bug Free Binary Search","text":"Introduce common templates to avoid infinite loops. Template 112345678910111213int i = 0;int j = nums.size() - 1;while (i &lt;= j) { int mid = (i + j) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) i = mid + 1; else j = mid - 1;}return -1; // not found Template 2123456789101112131415161718int i = 0;int j = nums.size();while (i &lt; j) { int mid = (i + j) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) i = mid + 1; else j = mid;}// post-processif (i != nums.size() &amp;&amp; nums[i] == target) return i;return -1; Template 312345678910111213141516171819int i = 0;int j = nums.size() - 1;while (i + 1 &lt; j) { int mid = (i + j) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) i = mid; else j = mid;}if (nums[i] == target) return i;if (nums[j] == target) return j;return -1; Visualization OverflowTo deal with the overflow issue, we need to compute $mid$ using: 1int mid = i + (j - i) / 2;","link":"/interview/misc-how-to-write-bug-free-binary-search/"},{"title":"Hands On OpenCL","text":"An open source two-day lecture course for teaching and learning OpenCL Tutorial website: https://handsonopencl.github.io/","link":"/resource/misc-learn-opencl/"},{"title":"Learn OpenGL 1","text":"Setting up OpenGL in Ubuntu (GLFW, GLAD) github source code: linklearning materials: learnopengl.com IntroductionThis tutorial shows how to setup a basic opengl project on ubuntu 22.04. Other platforms such as Mac and Windows are not covered. There should be plenty of resources online that you can refer to. GLFW and GLADGLFW is a library, written in C, specifically targeted at OpenGL. GLFW gives us the bare necessities required for rendering goodies to the screen. It allows us to create an OpenGL context, define window parameters, and handle user input, which is plenty enough for our purposes. Install GLFW: 1sudo apt-get install libglfw3-dev GLAD is a tool used for generating a loader for OpenGL function pointers. It simplifies the process of setting up OpenGL in a program by automatically generating the code necessary to load OpenGL functions at runtime. GLAD has a .c file and a .h file. You can directly put these two files under your project. To access glad files, refer to my github project. Create a window123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &quot;include/glad.h&quot;#include &lt;GLFW/glfw3.h&gt;int main() { std::cout &lt;&lt; &quot;OpenGL\\n&quot;; GLFWwindow* window; if (!glfwInit()) return -1; window = glfwCreateWindow(640, 500, &quot;window&quot;, nullptr, nullptr); glfwMakeContextCurrent(window); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &lt;&lt; &quot;Couldn't load opengl\\n&quot;; glfwTerminate(); return -1; } glClearColor(0.25f, 0.5f, 0.75f, 1.0f); while (!glfwWindowShouldClose(window)) { glfwPollEvents(); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window); } glfwTerminate();} run build.sh, if everything is correct. You should see a blue window. References https://learnopengl.com/Getting-started/Creating-a-window https://www.youtube.com/watch?v=LxEFn-cGdE0","link":"/CGV/misc-learn-opengl-1/"},{"title":"Learn OpenGL 2","text":"Create window, handle user inputs Github source code: linklearning materials: learnopengl Create window Callback function Handle user inputs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;vector&gt;#include &quot;include/glad.h&quot;#include &lt;GLFW/glfw3.h&gt;std::vector&lt;float&gt; randomColor() { std::vector&lt;float&gt; color = {0, 0, 0}; color[0] = float(std::rand()) / RAND_MAX; color[1] = float(std::rand()) / RAND_MAX; color[2] = float(std::rand()) / RAND_MAX; return color;}void framebuffer_size_callback(GLFWwindow* window, int width, int height) { // The first two parameters of glViewport set the location of the lower left corner of the window // The third and fourth parameter set the width and height of the rendering window in pixels printf(&quot;window changed!, width: %d, height: %d\\n&quot;, width, height); glViewport(0, 0, 800, 600);}void handleInput(GLFWwindow* window) { if (glfwGetKey(window, GLFW_KEY_F1) == GLFW_PRESS) { std::cout &lt;&lt; &quot;F1 pressed!\\n&quot;; glfwSetWindowShouldClose(window, true); } else if (glfwGetKey(window, GLFW_KEY_F2) == GLFW_PRESS) { // rendering std::cout &lt;&lt; &quot;F2 pressed!\\n&quot;; std::vector&lt;float&gt; color = randomColor(); std::cout &lt;&lt; color[0] &lt;&lt; &quot; &quot; &lt;&lt; color[1] &lt;&lt; &quot; &quot; &lt;&lt; color[2] &lt;&lt; std::endl; glClearColor(color[0], color[1], color[2], 1.0f); glClear(GL_COLOR_BUFFER_BIT); }}int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // Create a window object GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL); if (window == NULL) { std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // Initialize GLAD before we call any OpenGL functions // glad: load all OpenGL function pointers if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1; } while(!glfwWindowShouldClose(window)) { // User input handleInput(window); glfwSwapBuffers(window); glfwPollEvents(); } // glfw: terminate, clearing all previously allocated GLFW resources. glfwTerminate(); return 0;} F1 closes the window. F2 changes the color of the window. References https://learnopengl.com/Getting-started/Hello-Window","link":"/CGV/misc-learn-opengl-2/"},{"title":"JNI In Multi-threading","text":"Use JNI in the context of multi-threading. 1. IntroductionUsing JNI (Java Native Interface) in a multithreaded environment requires careful handling to ensure thread safety, proper lifecycle management of the JVM, and the native resources. JNI can be used in the context of Java multithreading, native multithreading or both. In each case, we need to carefully handle some key factors such as thread safety, JNI attchment and error handling. Here is a high-level diagram illustrating the operation of JVM multithreading, highlighting the interaction between Java threads and native threads. Key Differences Between JNIEnv* and JavaVM*: JNIEnv* is thread-local and provides thread-specific access to JNI functions. JavaVM* is global to the JVM and allows operations across threads, such as attaching/detaching threads. 2. Java MultithreadingWhen using JNI in the context of Java multithreading, here are some key considerations. JNIEnv* env per thread process(JNIEnv* env, jobject thiz) Each Java thread calling into native code automatically gets its own JNIEnv*. You don’t need to attach the thread to the JVM manually. This pointer is thread-local and should not be shared between threads. Avoid storing JNIEnv* in global variables or static storage. Thread-Safety Ensure the native code is thread-safe, especially if multiple Java threads interact with shared native resources. Use synchronization mechanisms like std::mutex to protect shared data. Global References Use NewGlobalRef to create references for objects that need to be accessed by multiple threads or persist across JNI calls. Always delete global references with DeleteGlobalRef when they are no longer needed. Local References JNI local references are valid only in the thread and scope where they are created. They must not be used across threads. Use DeleteLocalRef to avoid memory leaks. JNIActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class JNIActivity extends AppCompatActivity { static { System.loadLibrary(&quot;jnimultithreading&quot;); } // Native methods private native void nativeInit(); private native void nativeProcessData(int threadId); private native void nativeCleanup(); // Method to be called from native code private void onProgressUpdate(int threadId, int progress) { runOnUiThread(() -&gt; { statusText.setText(&quot;Thread &quot; + threadId + &quot;: &quot; + progress + &quot;%&quot;); }); } private static final int NUM_THREADS = 4; private boolean isProcessing = false; private TextView statusText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_jniactivity); // Initialize native resources nativeInit(); statusText = findViewById(R.id.status_text); Button btnStartThreads = findViewById(R.id.btn_start_threads); btnStartThreads.setOnClickListener(v -&gt; startProcessing()); } private void startProcessing() { if (isProcessing) return; isProcessing = true; statusText.setText(&quot;Processing started...&quot;); // Create and start multiple Java threads Thread[] threads = new Thread[NUM_THREADS]; for (int i = 0; i &lt; NUM_THREADS; i++) { final int threadId = i; threads[i] = new Thread(() -&gt; { nativeProcessData(threadId); }); threads[i].start(); } // Start a monitoring thread to wait for all threads to complete new Thread(() -&gt; { try { for (Thread thread : threads) { thread.join(); } runOnUiThread(() -&gt; { statusText.setText(&quot;Processing completed!&quot;); isProcessing = false; }); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } @Override protected void onDestroy() { super.onDestroy(); // Cleanup native resources nativeCleanup(); }} jnimultithreading.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#include &lt;unistd.h&gt;#include &lt;mutex&gt;#define LOG_TAG &quot;JNIMultiThreading&quot;#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)// Mutex for thread synchronizationstd::mutex g_mutex;// Global referencesjclass g_activity_class = nullptr; // Global reference to the Activity classjmethodID g_progress_method = nullptr; // Method ID (not a global reference)extern &quot;C&quot; {JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env; if (vm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } // Find the Activity class jclass localClass = env-&gt;FindClass(&quot;com/example/jnimultithreading/JNIActivity&quot;); if (localClass == nullptr) { return JNI_ERR; } // Create global reference to the class g_activity_class = (jclass)env-&gt;NewGlobalRef(localClass); env-&gt;DeleteLocalRef(localClass); // Delete the local reference // Cache the method ID g_progress_method = env-&gt;GetMethodID(g_activity_class, &quot;onProgressUpdate&quot;, &quot;(II)V&quot;); return JNI_VERSION_1_6;}JNIEXPORT void JNICALLJava_com_example_jnimultithreading_JNIActivity_nativeProcessData(JNIEnv *env, jobject thiz, jint thread_id) { // Simulate work with progress updates for (int i = 0; i &lt;= 100; i += 20) { { std::lock_guard&lt;std::mutex&gt; lock(g_mutex); LOGI(&quot;Thread %d progress: %d%%&quot;, thread_id, i); env-&gt;CallVoidMethod(thiz, g_progress_method, thread_id, i); } usleep(500000); // Sleep for 500ms }}JNIEXPORT void JNICALLJava_com_example_jnimultithreading_JNIActivity_nativeInit(JNIEnv *env, jobject thiz) { LOGI(&quot;Native resources initialized&quot;);}JNIEXPORT void JNICALLJava_com_example_jnimultithreading_JNIActivity_nativeCleanup(JNIEnv *env, jobject thiz) { if (g_activity_class != nullptr) { env-&gt;DeleteGlobalRef(g_activity_class); g_activity_class = nullptr; } g_progress_method = nullptr; // Just set to null, no need to delete LOGI(&quot;Native resources cleaned up&quot;);}JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved) { JNIEnv* env; if (vm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6) != JNI_OK) { return; } // Clean up global references if (g_activity_class != nullptr) { env-&gt;DeleteGlobalRef(g_activity_class); g_activity_class = nullptr; }}} 3. Native MultithreadingIf multithreading happens in native code (rather than in Java), there are notable differences in how threads are managed, synchronized, and interact with the Java Virtual Machine (JVM). The most significant difference is: Thread Lifecycle - Created and managed outside of the JVM, typically using threading APIs like std::thread (C++), POSIX threads, or platform-specific APIs. - Do not have an automatic relationship with the JVM; they must explicitly attach to the JVM using AttachCurrentThread if they need to interact with Java objects. - After their work is done, they must detach using DetachCurrentThread to avoid memory leaks. JavaVM*To attach/detach a native thread from JVM, we need the JavaVM* pointer. The JavaVM* pointer in the JNI represents the JVM instance running the Java code. Unlike the JNIEnv*, which is thread-local and specific to a single thread, the JavaVM* is global and shared across all threads in the JVM. It provides a way for native code to interact with the JVM at a higher level, enabling operations that span multiple threads. As we mentioned in the diagram in section 1, for threads created in native code: The JavaVM* is commonly used for attaching and detaching native threads to/from the JVM, ensuring they can use JNI functions. Native threads must attach themselves to the JVM using the JavaVM* before accessing JNI. DemoTo illustrate how JNI operates in the presence of native threads, we will create a more complex example. MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.example.jnimultinativethread;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.util.Log;import android.widget.Button;import android.widget.TextView;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity { private TextView outputText; private StringBuilder logBuilder = new StringBuilder(); private NativeWorker nativeWorker; private final Handler mainHandler = new Handler(Looper.getMainLooper()); private final ThreadProgressCallback callback = value -&gt; { Thread currentThread = Thread.currentThread(); long nativeThreadId = nativeWorker.getNativeThreadId(); Log.i(&quot;MainActivity&quot;, &quot;JC, Callback running on thread: &quot; + nativeThreadId); // Process on native thread logBuilder.append(&quot;Java received: &quot;).append(value).append(&quot;\\n&quot;); int result = nativeWorker.processValue(value); logBuilder.append(&quot;Native processed and returned: &quot;).append(result).append(&quot;\\n&quot;); // Test the thread-registered method int threadResult = nativeWorker.threadRegisteredMethod(value); logBuilder.append(&quot;Thread-registered method returned: &quot;).append(threadResult).append(&quot;\\n&quot;); // Only use UI thread for updating TextView final String output = logBuilder.toString(); mainHandler.post(() -&gt; outputText.setText(output)); }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); outputText = findViewById(R.id.outputText); Button startButton = findViewById(R.id.startButton); nativeWorker = new NativeWorker(callback); startButton.setOnClickListener(v -&gt; { logBuilder.setLength(0); outputText.setText(&quot;&quot;); logBuilder.append(&quot;Starting async work...\\n&quot;); outputText.setText(logBuilder.toString()); nativeWorker.startAsyncWork(); }); }} native-lib.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;android/log.h&gt;#define LOG_TAG &quot;NativeLib&quot;#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)// Global reference to Java VM and callbackstatic JavaVM* g_vm = nullptr;static jobject g_callback_object = nullptr;static jmethodID g_callback_method = nullptr;static jclass g_native_worker_class = nullptr;// New method that will be registered from the native threadjint threadRegisteredMethod(JNIEnv* env, jobject thiz, jint value) { LOGI(&quot;JC, threadRegisteredMethod called on thread: %ld&quot;, std::this_thread::get_id()); return value * 3;}// Worker thread function that will call back to Javavoid nativeThread(int initialValue) { JNIEnv* env; bool needsDetach = false; // Attach thread to JVM if needed int getEnvResult = g_vm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6); if (getEnvResult == JNI_EDETACHED) { if (g_vm-&gt;AttachCurrentThread(&amp;env, nullptr) == JNI_OK) { needsDetach = true; } else { LOGI(&quot;Failed to attach thread to JVM&quot;); return; } } LOGI(&quot;JC, Native thread started with ID: %ld&quot;, std::this_thread::get_id()); // Register the new native method using the cached class reference if (g_native_worker_class != nullptr) { JNINativeMethod threadMethod[] = { {&quot;threadRegisteredMethod&quot;, &quot;(I)I&quot;, reinterpret_cast&lt;void*&gt;(threadRegisteredMethod)} }; if (env-&gt;RegisterNatives(g_native_worker_class, threadMethod, 1) &lt; 0) { LOGI(&quot;Failed to register thread method&quot;); } else { LOGI(&quot;Successfully registered thread method&quot;); } } // Simulate some work std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Call back to Java with the value env-&gt;CallVoidMethod(g_callback_object, g_callback_method, initialValue); // Detach thread if we attached it if (needsDetach) { g_vm-&gt;DetachCurrentThread(); }}void startAsyncWork(JNIEnv* env, jobject thiz) { // Get the callback field from NativeWorker jfieldID callbackField = env-&gt;GetFieldID(env-&gt;GetObjectClass(thiz), &quot;callback&quot;, &quot;Lcom/example/jnimultinativethread/ThreadProgressCallback;&quot;); // Get callback object and method jobject localCallback = env-&gt;GetObjectField(thiz, callbackField); jclass callbackClass = env-&gt;GetObjectClass(localCallback); // Create global reference to callback object if (g_callback_object != nullptr) { env-&gt;DeleteGlobalRef(g_callback_object); } g_callback_object = env-&gt;NewGlobalRef(localCallback); // Get callback method ID g_callback_method = env-&gt;GetMethodID(callbackClass, &quot;onNativeCallback&quot;, &quot;(I)V&quot;); // Start native thread with initial value std::thread worker(nativeThread, 42); worker.detach();}jint processValue(JNIEnv* env, jobject thiz, jint value) { LOGI(&quot;JC, processValue called on thread: %ld&quot;, std::this_thread::get_id()); return value * 2;}// Native method mapping table for initial registrationstatic JNINativeMethod methods[] = { {&quot;startAsyncWork&quot;, &quot;()V&quot;, reinterpret_cast&lt;void*&gt;(startAsyncWork)}, {&quot;processValue&quot;, &quot;(I)I&quot;, reinterpret_cast&lt;void*&gt;(processValue)}};extern &quot;C&quot; JNIEXPORT jint JNICALLJNI_OnLoad(JavaVM* vm, void* reserved) { g_vm = vm; JNIEnv* env; if (vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } // Find and cache the NativeWorker class jclass localClass = env-&gt;FindClass(&quot;com/example/jnimultinativethread/NativeWorker&quot;); if (localClass == nullptr) { return JNI_ERR; } g_native_worker_class = (jclass)env-&gt;NewGlobalRef(localClass); // Register initial native methods if (env-&gt;RegisterNatives(g_native_worker_class, methods, sizeof(methods)/sizeof(methods[0])) &lt; 0) { return JNI_ERR; } return JNI_VERSION_1_6;}extern &quot;C&quot; JNIEXPORT jlong JNICALLJava_com_example_jnimultinativethread_NativeWorker_getNativeThreadId(JNIEnv* env, jobject thiz) { return (jlong)pthread_self();}extern &quot;C&quot; JNIEXPORT void JNICALLJNI_OnUnload(JavaVM* vm, void* reserved) { JNIEnv* env; if (vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) { return; } // Clean up global references if (g_callback_object != nullptr) { env-&gt;DeleteGlobalRef(g_callback_object); g_callback_object = nullptr; } if (g_native_worker_class != nullptr) { env-&gt;DeleteGlobalRef(g_native_worker_class); g_native_worker_class = nullptr; }} It is worth noting that Thread.getId() in Java and std::this_thread::get_id() in C++ use different numbering systems for thread IDs. To make them match and be more comparable, we return pthread_self() from the native code and let Java obtained the native thread id. The log information confirms the accuracy of our illustration above. 1234JC, Native thread started with ID: 493381438640JC, Callback running on thread: 493381438640JC, processValue called on thread: 493381438640JC, threadRegisteredMethod called on thread: 493381438640","link":"/misc/misc-jni-multi-threading/"},{"title":"Fixed Point Computation","text":"Introducing fixed point for efficiency, predictability and low cost, which are essential in many real-time and embedded DSP applications. Table of Contents 1. Fundamentals 2. Arithmetic 3. Precision 4. Overflow 5. Compare to Floating Point 6. Demo 1. FundamentalsFixed-point representation is a way to represent real numbers (i.e., numbers with fractions/decimals) using integers, by fixing the position of the binary point (similar to the decimal point, but in binary). Representation Fixed point numbers are typically represented as Qm.n where: $m$ is the number of integer bits $n$ is the number of fractional bits. For example, Q1.15 means 1 integer bit(signed bit), 15 fractional bits. Other common formats include Q1.31, Q8.8, Q16.16 etc. Conversion Assume the fixed point format is Qm.n, to convert a real number(R) to a fixed point(F):$$\\begin{equation}F = R \\times 2^{n}\\end{equation}$$ to convert a fixed point(F) to a real number(R):$$\\begin{equation}R = \\frac{F}{2^{n}}\\end{equation}$$ To demonstrate this, let’s use format Q1.3 (1 bit for sign bit, 3 bits for fractional part) as an example. Let’s try 0101: Sign bit is 0 -&gt; it’s positive Binary 0101 = decimal 5 Convert to real number:$$\\begin{equation}\\frac{5}{2^{3}} = 0.625\\end{equation}$$ So, 0101 in Q1.3 = 0.625 What if it is negative? Let’s try binary 1101. The MSB is 1, so it is a negative. Take the two’s complement to find the magnitude and add 1: 1101 -&gt; 0010 -&gt; 0011. Convert 0011 to decimal: 3. Add the sign back: -3 Convert to real number:$$\\begin{equation}\\frac{-3}{2^{3}} = -0.375\\end{equation}$$ Two’s Complement Since we used two’s complement above, it is worth mentioning about what it is and why it is useful. It is a special representation of signed integers that can make addition, subtraction, and other arithmetic to work correctly for both positive and negative numbers. For Q1.2, all the possible values from min to max. Binary Signed Int Real Value (= int / 4) 100 −4 −1.00 101 −3 −0.75 110 −2 −0.50 111 −1 −0.25 000 0 0.00 001 1 0.25 010 2 0.50 011 3 0.75 Each step = $\\frac{1}{2^2} = 0.25$ Range(minimum &amp; maximum) From the table above, we can easily find the pattern that, for a Qm.n format fixed point. Therefore, for minimum (invert and add 1):$$\\begin{equation}\\frac{2^{m+n-1}}{2^{n}} = -2^{m-1}\\end{equation}$$ For maximum:$$\\begin{equation}\\frac{2^{m+n-1} - 1}{2^{n}} = 2^{m-1} - 2^{-n}\\end{equation}$$ 2. ArithmeticBefore we dive into the fixed point arithmetic, let’s assume that we are using format: Q4.4. For Q4.4, its representation range is: $$\\begin{equation}min = -2^{m-1} = -\\frac{2^7}{2^4} = -8 \\\\max = 2^{m-1} - 2^{-n} = 2^3 - 2^{-4} = 7.9375\\end{equation}$$ Recap: the conversion between fixed point and its floating point value$$\\begin{equation}result_{fix} = result_{real} \\times 2^{n}\\end{equation}$$ Addition$$\\begin{equation}a_{real} = \\frac{a_{fix}}{2^n} \\\\b_{real} = \\frac{b_{fix}}{2^n} \\\\a + b = \\frac{a_{fix}+b_{fix}}{2^n}\\end{equation}$$ If we want to add 2.5 and 1.25. $$\\begin{equation}a_{fix} = 2.5 \\times 2^{4} = 40 \\\\b_{fix} = 1.25 \\times 2^{4} = 20 \\\\\\\\result_{fix} = a_{fix} + b_{fix} = 60 \\\\result_{real} = \\frac{60}{2^{4}} = 3.75, \\text{which equals to } 2.5 + 1.25 = 3.75\\end{equation}$$ Subtraction Similar to addition$$\\begin{equation}a_{real} = \\frac{a_{fix}}{2^n} \\\\b_{real} = \\frac{b_{fix}}{2^n} \\\\a - b = \\frac{a_{fix}-b_{fix}}{2^n}\\end{equation}$$ $$\\begin{equation}a_{fix} = 2.5 \\times 2^{4} = 40 \\\\b_{fix} = 1.25 \\times 2^{4} = 20 \\\\\\\\result_{fix} = a_{fix} - b_{fix} = 20 \\\\result_{real} = \\frac{20}{2^{4}} = 1.25, \\text{which equals to } 2.5 - 1.25 = 1.25\\end{equation}$$ Multiplication Integer multiplication will cause overflow, for example, $6 \\times 5 = 30$, 30 exceeds the maximum value Q4.4 can represent. Therefore, for multiplication, we need to scale down the value. The rule is:$$\\begin{equation}result_{fix} = \\frac{a_{fix} \\times b_{fix}}{2^n}\\end{equation}$$ Example: $2.5 \\times 1.5$ $$\\begin{equation}a_{fix} = 2.5 \\times 2^{4} = 40 \\\\b_{fix} = 1.5 \\times 2^{4} = 24 \\\\\\\\result_{fix} = a_{fix} \\times b_{fix} = 960 \\\\result_{scaled} = \\frac{960}{2^4} = 60 \\\\result_{real} = \\frac{60}{2^4} = 3.75\\end{equation}$$ Devision To divide without losing precision, upscale numerator before division:$$\\begin{equation}result_{fix} = \\frac{a_{fix} \\times 2^{n}}{b_{fix}}\\end{equation}$$ Example: $2.5 \\div 1.25$ $$\\begin{equation}a_{fix} = 2.5 \\times 2^{4} = 40 \\\\b_{fix} = 1.25 \\times 2^{4} = 20 \\\\\\\\a_{fix-upscaled} = 40 \\times 2^{4} = 640 \\\\result_{fix} = \\frac{640}{20} = 32 \\\\result_{real} = \\frac{32}{2^4} = 2\\end{equation}$$ 3. PrecisionQm.n We use the term “resolution” to represent the smallest step(or precision step) of a fixed point format.$$\\begin{equation}\\text{resolution} = \\frac{1}{2^n}\\end{equation}$$ For example: Q1.7 has resolution of $\\frac{1}{2^7} = 0.0078125$ Q4.4 has resolution of $\\frac{1}{2^4} = 0.0.0625$ More fractional bits mean better precision, but smaller range(suppose we have fixed total bits). Truncation error Example: convert 0.1 to Q4.4 fixed point$$\\begin{equation}result_{fix} = 0.1 \\times 2^{4} = 1.6 \\\\\\text{Truncation discards fractional bits without rounding: } result_{trunc} = floor(1.6) = 1 \\\\result_{real} = \\frac{1}{2^4} = 0.0625 \\neq 0.1\\end{equation}$$ Rounding error Same example: convert 0.1 to Q4.4 fixed point$$\\begin{equation}result_{fix} = 0.1 \\times 2^{4} = 1.6 \\\\\\text{Rounding to nearest is better, but still introduces error: } result_{round} = round(1.6) = 2 \\\\result_{real} = \\frac{2}{2^4} = 0.125 \\neq 0.1\\end{equation}$$ Compare the two results above:$$\\begin{equation}\\text{rounding_error} = |0.125 - 0.1| = 0.025 \\\\\\text{truncation_error} = |0.0625 - 0.1| = 0.0375\\end{equation}$$ Rounding to the nearest can be a better strategy to reduce precision loss. There is one trick which is to add a rounding offset before scaling.$$\\begin{equation}result_{fix} = ((a_{fix} \\times b_{fix}) + (1 \\ll (n - 1))) \\gg n\\end{equation}$$ For example, in fixed point multiplication, $0.5 \\times 0.3 = 0.15$ Without rounding:$$\\begin{equation}a_{fix} = 0.5 \\times 2^4 = 8 \\\\b_{fix} = 0.3 \\times 2^4 = round(4.8) = 5 \\\\result_{fix} = (8 \\times 5) \\gg 4 = 2 \\text{truncated}\\\\result_{real} = \\frac{2}{2^4} = 0.125 \\\\\\text{error: } 0.125 - 0.15 = -0.025\\end{equation}$$ With rounding:$$\\begin{equation}a_{fix} = 0.5 \\times 2^4 = 8 \\\\b_{fix} = 0.3 \\times 2^4 = round(4.8) = 5 \\\\result_{fix-rounding} = ((a_{fix} \\times b_{fix}) + (1 \\ll (n - 1))) \\gg n = (8 \\times 5 + (1 \\ll 3)) \\gg 4 = (40 + 8) \\gg 4 = 3 \\\\result_{real} = \\frac{3}{2^4} = 0.1875 \\\\\\text{error: } |0.1875 - 0.15| = 0.0375\\end{equation}$$ At first glance, +0.0375 seems worse than −0.025, because it’s a larger absolute error. So why do we still say that rounding is better? The reason rounding is preferred is not always because it produces the smallest possible error for each operation — but because it produces statistically unbiased results on average across many operations. Truncation always drops the fractional part, rounding down toward zero. This introduces a consistent negative bias. Over many computations: You might repeatedly lose small bits of precision The result accumulates a consistent downward error This is called systematic error Rounding to nearest: Sometimes you round up Sometimes you round down On average, the errors cancel out This leads to a smaller total error over time and more accurate aggregate results. 4. OverflowIn fixed-point systems, overflow occurs when the result of an operation exceeds the representable range of the format (e.g., Q4.4 can represent only from −8.0 to +7.9375). Let’s use fixed point multiplication as an example. If we are calculating $3.5(a) \\times 1.5(b)$, the fixed point representations for $a$ and $b$ are:$$\\begin{equation}a_{fix} = 3.5 * 2^4 = 56 \\\\b_{fix} = 1.5 * 2^4 = 24\\end{equation}$$ Then, the multiplication result is:$$\\begin{equation}56 * 24 = 1344\\end{equation}$$ Since $1344$ exceeds the maximum(127) of 8-bit signed integer, if we still use int8 data type to catch the result, we will get: 1344 in binary: 0000 0101 0100 0000 (16-bit) The lower 8 bits are 01000000, which equals 64 in decimal. The final result(after we convert it to the floating point representation) will be:$$\\begin{equation}result_{real} = \\frac{64}{2^4} = 4 \\neq (3.5 * 1.5 = 5.25)\\end{equation}$$ The most common techniques we use to handle arithmetic overflow is to use wider intermediate types. We use 16-bit for 8-bit math. Let’s redo the math for the multiplication above. $$\\begin{equation}a_{fix} = 3.5 * 2^4 = 56 \\\\b_{fix} = 1.5 * 2^4 = 24 \\\\a_{fix} * b_{fix} = 1344 \\text{ (use 16-bit to hold the result)} \\\\result_{fix} = (1344 + 2^{3}) / 2^{4} = 84 \\text{ (add rounding offset)} \\\\result_{real} = \\frac{84}{2^4} = 5.25 = 3.5 * 1.5\\end{equation}$$ ClampingSometimes, even if we use wider intermediate types, after we scale the result down to the smaller range, it is still out of the range. This is when we need clamping to ensure the final result is within the range. For multiplication $7.5 \\times 1.5$ using Q4.4 format: $$\\begin{equation}a_{fix} = 7.5 * 2^4 = 120 \\\\b_{fix} = 1.5 * 2^4 = 24 \\\\a_{fix} * b_{fix} = 2880 \\text{ (use 16-bit to hold the result)} \\\\result_{fix} = (2880 + 2^{3}) / 2^{4} = 180 \\text{ (add rounding offset)} \\\\\\end{equation}$$ The valid range for Q4.4 is: $-128$ to $127$. Obviously, $180$ exceeds $127$. We need to clamp to maximum Q4.4 value:$$\\begin{equation}result_{fix} = min(180, 127) = 127 \\\\result_{real} = \\frac{127}{2^4} = 7.9375 \\neq (7.5 * 1.5 = 11.25) \\text{ precision loss}\\end{equation}$$ The code example below demonstrates the Q4.4 multiplication process. 1234567int8_t fixed_mul_q4_4(int8_t a, int8_t b) { int16_t temp = (int16_t)a * (int16_t)b; // intermediate is wider temp = (temp + 8) &gt;&gt; 4; // rounding if (temp &gt; 127) temp = 127; // clmap/saturation if (temp &lt; -128) temp = -128; return (int8_t)temp;} 5. Compare to Floating PointWe have beeing talking so much about the basics of fixed point computation, but so far, we haven’t touched the most important part, which is why we prefer fixed point arithmetic over floating point, especially in embedded systems, DSP, mobile devices, or hardware where performance, power, and cost matter. You might wonder about an alternative approach: why not simply use FP16 instead of FP32 for floating-point operations? This would allow us to match the bit width of typical fixed point implementations (16 bits) while retaining floating-point capabilities. But are they really the same? To answer this question, we need to understand how fixed point and floating point work differently at a low level perspective. Floating pointIEEE 754 Half-Precision $$(-1)^{sign} \\times (1 + mantissa) \\times 2^{exponent-15}$$ Floating point arithmetic(addition) by steps from low level perspective Step Description 1. Unpack Extract sign, exponent, mantissa 2. Align exponents Shift smaller mantissa to match the larger exponent 3. Add mantissas Perform integer addition of aligned mantissas 4. Normalize Shift result to maintain 1.xxx format, adjust exponent accordingly 5. Round Round result to fit in mantissa bits 6. Repack Combine sign, new exponent, and rounded mantissa into 16-bit float format Fixed point As we discussed in section 2, fixed point arithmetics are just simple integer operations as long as both numbers are in the same format (Qm.n). Compared to floating point, there is no extra alignment, rounding, normalizing, and handling special cases. Less CPU cycles needed for fixed point operations. Hardware differences: Fixed point can be implemented on tiny MCUs without an FPU, using only arithmetic logic unit(ALU) — less silicon, less power, less cost. Floating point requires dedicated hardware(FPU) or software emulation — more cycles, more power, larger chip. 6. Demo Converting a Gaussian blur implementation from floating point to fixed point Floating Point Gaussian Blur (1D) 12345678910void gaussianBlurFloat(const float* input, float* output, int size) { const float kernel[5] = { 0.0625, 0.25, 0.375, 0.25, 0.0625 }; for (int i = 2; i &lt; size - 2; ++i) { output[i] = 0.0f; for (int j = -2; j &lt;= 2; ++j) { output[i] += input[i + j] * kernel[j + 2]; } }} Choose a Fixed Point FormatAssume: Input &amp; output are in int16_t using Q8.8 format (8 integer bits, 8 fractional bits). We’ll convert kernel coefficients to Q1.15 format (pure fractional, for more precision). Multiply Q8.8 × Q1.15 → result is Q9.23 → shift by 15 bits to get back to Q8.8. Convert Kernel to Fixed Point 12345678// Multiply each float coefficient by 2^15 = 32768const int16_t kernel[5] = { 0.0625 * 32768, // ≈ 2048 0.25 * 32768, // ≈ 8192 0.375 * 32768, // ≈ 12288 0.25 * 32768, // ≈ 8192 0.0625 * 32768 // ≈ 2048}; Implementation Details 1234567891011121314151617181920void gaussianBlurFixed(const int16_t* input, int16_t* output, int size) { const int16_t kernel[5] = { 2048, 8192, 12288, 8192, 2048 }; // Q1.15 for (int i = 2; i &lt; size - 2; ++i) { int32_t acc = 0; for (int j = -2; j &lt;= 2; ++j) { int32_t sample = (int32_t)input[i + j]; // Q8.8 int32_t k = (int32_t)kernel[j + 2]; // Q1.15 acc += (sample * k); // Q8.8 × Q1.15 = Q9.23 } // Round and shift to bring Q9.23 → Q8.8 acc = (acc + (1 &lt;&lt; 14)) &gt;&gt; 15; // Optional: clip to int16_t range if (acc &gt; 32767) acc = 32767; if (acc &lt; -32768) acc = -32768; output[i] = (int16_t)acc; }}","link":"/misc/misc-fixed-point/"},{"title":"JNI Registers Native Methods","text":"Register native C++ methods for Java to access them. 1. IntroductionIn Android applications, interacting with native C++ code through the Java Native Interface (JNI) is common, as many powerful and efficient libraries—especially those for image processing, rendering, and video/audio processing—are implemented in C++. JNI allows Java code to call and be called by native code. In Java, we can declare a native method that is implemented in C++ code. 1234567891011121314151617181920public class JNIActivity extends AppCompatActivity { // Load the native library when the class is loaded static { System.loadLibrary(&quot;jnidemo&quot;); } // Declare a native method that is implemented in the C++ code public native String getMessageFromJNI(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_jni); // Call the native method and display the result TextView tvMessage = findViewById(R.id.tv_message); tvMessage.setText(getMessageFromJNI()); }} Accordingly, we can add a C++ module and implement the native method defined in Java. 123456extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_example_jnidemo_JNIActivity_getMessageFromJNI(JNIEnv *env, jobject thiz) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());} In JNI, the naming convention Java_&lt;package&gt;_&lt;class&gt;_&lt;methodName&gt; is required to link Java methods with their corresponding native C++ implementations. This naming scheme helps JNI locate the correct C++ function when the native method is called from Java. JNI’s naming convention also helps avoid function name collisions across packages or classes. For instance, if you have a similar method in a different class or package, the convention makes sure each native method has a unique name based on its Java class and package. The JVM automatically links the native methods to their implementations by name when you call the System.loadLibrary() method to load your shared library. 2. JNI_OnLoadWhen to use JNI_OnLoad? JNI_OnLoad is a special function in JNI that is automatically called when a native shared library is loaded into the JVM through System.loadLibrary in Java. JNI_OnLoad is typically used if: You want to customize the registration process or register multiple methods at once (e.g., for complex scenarios or performance optimization). You don’t want to follow the JNI naming convention and prefer more control over method registration (e.g., for flexibility or to avoid long, cumbersome method names). You have initialization code to run when the library is loaded. We are going to discuss more about the second scenario, where we aim to establish custom naming conventions for our native methods. We still keep the same method name in Java. 1public native String getMessageFromJNI(); However, in native C++ code, we have a new customized name for the corresponding java method. 1234jstring sendMessage(JNIEnv *env, jobject thiz) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());} If we try to use getMessageFromJNI() anywhere in Java code, we will get a No implementation error message. The way to link them is to register native methods dynamically using RegisterNatives in JNI_OnLoad. This function lets you map Java native methods to any C++ function, bypassing the strict naming convention. 1234567891011121314151617181920212223242526jstring sendMessage(JNIEnv *env, jobject thiz) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());}JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env; if (vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } jclass cls = env-&gt;FindClass(&quot;com/example/jnidemo/JNIActivity&quot;); if (cls == nullptr) { return JNI_ERR; // Class not found } const JNINativeMethod methods[] = { {&quot;getMessageFromJNI&quot;, &quot;()Ljava/lang/String;&quot;, reinterpret_cast&lt;void*&gt;(sendMessage)} }; if (env-&gt;RegisterNatives(cls, methods, sizeof(methods) / sizeof(methods[0])) &lt; 0) { return JNI_ERR; // Failed to register methods } return JNI_VERSION_1_6;} JNI Version Check: The JNI_OnLoad function checks that the JNI version is compatible (e.g., JNI_VERSION_1_6). Find Java Class: FindClass locates the Java class JNIActivity in which the native methods are declared. Define Native Methods: The JNINativeMethod struct associates Java method names with the corresponding C++ functions. Each entry contains: Java method name (as a string) Method signature (in JNI format) Pointer to the native function Register Native Methods: RegisterNatives links the Java method names to the C++ implementations.","link":"/misc/misc-jni-register-native/"},{"title":"Learn OpenGL 4","text":"Shader Github source code: linklearning materials: learnopengl IntroductionShaders are written in GLSL (OpenGL Shader Language). Shader programs reside on GPUs. The basic syntax looks like this: 123456789101112131415#version version_numberin type variable_name;in type variable_name;out type variable_name; uniform type uniform_name; void main(){ // process input(s) and do some weird graphics stuff ... // output processed stuff to output variable out_variable_name = weird_stuff_we_processed;} GLSL supported data type: int, float, double, uint and bool. It also supports its unique data type vectors and matrices. For vectors, similar to what we have in OpenCL. It has multiple variants. You can use .x, .y, .z and .w to access their first, second, third and fourth component respectively. vecn: the default vector of n floats. bvecn: a vector of n booleans. ivecn: a vector of n integers. uvecn: a vector of n unsigned integers. dvecn: a vector of n double components. ins and outsin and out keywords define the inputs and outputs of a shader program. In the below example, vertex shader receives inputs from vertex data and outputs ourColor to the next stage which is fragment shader. In fragment shader, it declares ourColor as input. This name has to be exactly the same as defined in vertex shader, otherwise, it will not work. vertex shader 12345678#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;out vec3 ourColor;void main() { gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0); ourColor = aColor;} fragment shader 1234567#version 330 coreout vec4 FragColor;in vec3 ourColor;uniform vec3 customColor;void main() { FragColor = vec4(customColor, 1.0f);} As you probably noticed that in vertex shader, we have layout (location = 0) and layout (location = 1). What do they mean? Let’s take a look at our host program. This should be pretty self-explanatory. When we pass vertex data to vertex shader, we not only pass vertex data but also color information. So, we have two vertex attributes right now and we need to setup vertex attribute pointers for these two to let OpenGL know how to read the data. 12345678910111213float vertices[] = { // positions // colors 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // bottom left 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // top };// position attributeglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// color attributeglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));glEnableVertexAttribArray(1); uniform variablesUniform is another way to pass data from CPU to GPU. Uniform variables are global, meaning they can be accessed from other shader programs. A simple example below shows we have a uniform variable ourColor defined in the vertex shader. It determines the color of output pixels. In our host program, we explicitly set ourColor to be a changing value subject to time. 123456789#version 330 coreout vec4 FragColor; uniform vec4 ourColor; // we set this variable in the OpenGL code.void main(){ FragColor = ourColor;} 12345float timeValue = glfwGetTime();float greenValue = (sin(timeValue) / 2.0f) + 0.5f;int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);glUseProgram(shaderProgram);glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); Abstract ShaderIn the previous tutorial, if we want to have two shader programs, we need to repeat everything twice which is not efficient. That’s why it is necessary to have a Shader class to handle this, 1234567891011121314151617181920212223242526272829303132333435363738// Shader objectunsigned int vertexShader;unsigned int fragmentShader[2];vertexShader = glCreateShader(GL_VERTEX_SHADER);fragmentShader[0] = glCreateShader(GL_FRAGMENT_SHADER);fragmentShader[1] = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(vertexShader, 1, &amp;vertexShaderSource, nullptr);glCompileShader(vertexShader);// first fragment shaderglShaderSource(fragmentShader[0], 1, &amp;fragmentShaderSource1, nullptr);glCompileShader(fragmentShader[0]);// second fragment shaderglShaderSource(fragmentShader[1], 1, &amp;fragmentShaderSource2, nullptr);glCompileShader(fragmentShader[1]);// create two Shader programsunsigned int shaderProgram[2];shaderProgram[0] = glCreateProgram();shaderProgram[1] = glCreateProgram();// attach shaders to the first programglAttachShader(shaderProgram[0], vertexShader);glAttachShader(shaderProgram[0], fragmentShader[0]);glLinkProgram(shaderProgram[0]);// attach shaders to the second programglAttachShader(shaderProgram[1], vertexShader);glAttachShader(shaderProgram[1], fragmentShader[1]);glLinkProgram(shaderProgram[1]);// delete shader objs after linkingglDeleteShader(vertexShader);glDeleteShader(fragmentShader[0]);glDeleteShader(fragmentShader[1]); Our strategy is to have Shader.h and Shader.cpp for keeping everything related to shader program. We also have two standalone shader.vs and shader.fs files for writing shaders. For more details, check my code Shader.h 123456789101112131415161718192021222324252627#ifndef SHADER_H#define SHADER_H#include &quot;include/glad.h&quot;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;class Shader {private: unsigned int m_id;public: Shader(const char* vertexPath, const char* fragmentPath); // use shader program void activate(); void updateColor(const char* name, std::vector&lt;float&gt;&amp; color); // check compile error void checkCompileErrors(unsigned int shader, std::string type);};#endif Here is the final result. References https://learnopengl.com/Getting-started/Shaders","link":"/CGV/misc-learn-opengl-4/"},{"title":"Learn OpenGL 5","text":"Texture Github source code: linklearning materials: learnopengl IntroductionA texture is a 2D image (or 1D or 3D) used to attach to an object. In order to map a texture to a triangle, we need to tell each vertex of the triangle a texture coordinate. By doing this, the fragment shader knows how to sample the texture and perform the interpolation. Texture coordinates range from [0, 1]. It differs from the default OpenGL normalized devices coordinates. Create textureTextures can be loaded from external files such as .png, .jpeg, etc. Then they can be further transformed into OpenGL readable texture buffers. There is an easy-to-use image library that can support popular image formats stb_image. It is a header-only file and can be easily added to our project. 123456#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot;int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);stbi_image_free(data); Similar to what we have done for VBO and EBO, we also need to create texture buffer, bind texture buffer, set texture parameters and copy data to texture buffers. generate texture buffer bind texture buffer set parameters copy data to texture buffer generate mipmap (a collection of texture images) generate texture buffer 12unsigned int texture;glGenTextures(1, &amp;texture); bind texture 1glBindTexture(GL_TEXTURE_2D, texture); set parametersGL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T are used for texture wrapping. To handle coordinates outside the range of [0, 1], OpenGL offers several options. GL_REPEAT GL_MIRRORED_REPEAT GL_CLAMP_TO_EDGE GL_CLAMP_TO_BORDER GL_TEXTURE_MIN_FILTER and GL_TEXTURE_MAG_FILTER are used for texture filtering. Most common interpolation methods are GL_NEAREST and GL_LINEAR. If you are familiar with image processing, they should be easy for you. GL_TEXTURE_MIN_FILTER is used when scaling down while GL_TEXTURE_MAG_FILTER for scaling up. 1234glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); copy data to texture buffers 1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); generate mipmapmipmap are precomputed, optimized collection of textures used to improve the rendering quality and performance of textured surfaces, especially when those surfaces are viewed from a distance or at different levels of detail. Objects at far distance can be rendered with small resolution textures, which can reduce memory. An example of mipmaps looks like this: Just like texture filtering, interpolation can be performed between two mipmap levels to avoid obvious artifacts. GL_NEAREST_MIPMAP_NEAREST: takes the nearest mipmap to match the pixel size and uses nearest neighbor interpolation for texture sampling. GL_LINEAR_MIPMAP_NEAREST: takes the nearest mipmap level and samples that level using linear interpolation. GL_NEAREST_MIPMAP_LINEAR: linearly interpolates between the two mipmaps that most closely match the size of a pixel and samples the interpolated level via nearest neighbor interpolation. GL_LINEAR_MIPMAP_LINEAR: linearly interpolates between the two closest mipmaps and samples the interpolated level via linear interpolation. NOTE: mipmap only works for downscaling. Texture magnification doesn’t use mipmaps. 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); To generate mipmaps is easy. 1glGenerateMipmap(GL_TEXTURE_2D); Apply textures1234567float vertices[] = { // positions // colors // texture coords 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // top right 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // top left }; Since the vertex attributes are changed, we also need to update our vertex attribute pointer. 123456789// position attributeglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// color attributeglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));glEnableVertexAttribArray(1);// texture attributeglVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));glEnableVertexAttribArray(2); Shadersvertex shader passes texture coordinates to fragment shader. 12345678910111213#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexture;out vec3 ourColor;out vec2 TexCoord;void main() { gl_Position = vec4(aPos, 1.0); ourColor = aColor; TexCoord = aTexture;} fragment shader reads texture coordinates from vertex shader and performs operations. Fragment shader is able to access the texture objects using uniform sampler2D. In our host program, we can later assign different textures to it. texture is a built-in function to sampling texture from coordinates. 12345678910111213#version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;uniform sampler2D texture1; // GL_TEXTURE0uniform sampler2D texture2; // GL_TEXTURE1uniform float alpha;void main() { vec2 newTexCoord = vec2(1.0f - TexCoord.x, TexCoord.y); FragColor = mix(texture(texture1, TexCoord), texture(texture2, newTexCoord), alpha);} Texture unitsTexture units allow us to use multiple textures in our shaders by assigning texture units to different samplers we previous defined. The default texture unit is 0 and is activated by default. OpenGL should have a at least a minimum of 16 texture units for you to use. To activate others: 1234glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2); To enable texture units in the shader program, we need to set their values in our host program. 1234// activate shader program before we can setup uniformsshader.activate();glUniform1i(glGetUniformLocation(shader.getID(), &quot;texture1&quot;), 0);glUniform1i(glGetUniformLocation(shader.getID(), &quot;texture2&quot;), 1); DemoThe demo mixes two textures, and the up and down keys will change the transparency of the cat image. Checkout the source code on my github. References https://learnopengl.com/Getting-started/Textures","link":"/CGV/misc-learn-opengl-5/"},{"title":"Learn OpenGL 3","text":"Draw a triangle. VBO: Vertex Buffer Object VAO: Vertex Array Object EBO: Element Buffer Object Shader Github source code: linklearning materials: learnopengl Graphic PipelineThe graphic pipeline is eseentially a process of transforming 3D coordinates to 2D pixels. This process can be further divided into two parts: 3D coordinates to 2D coordinates on screen and 2D coordinates to colored pixels. The figure below shows complete steps to convert vertex data to rendered pixels. Each step requires the output of the previous step as its input. All these steps are highly specialized and can be executed in parallel. Modern GPUs have many process cores (threads), which could process data quickly. To achieve parallelisim, each processing core runs small program. These small programs are called shaders. Vertex shader: transform 3D coordinates into different 3D coordinates. Geometry shader: form a primitive and has the ability to generate other shapes by emitting new vertices to form new (or other) primitive(s). Shape assembly: form one or more primitives and assembles all the point(s) in the primitive shape given. Rasterization: maps the resulting primitive(s) to the corresponding pixels on the final screen, resulting in fragments for the fragment shader to use. Fragment shader: calculate the final color of a pixel and this is usually the stage where all the advanced OpenGL effects occur. Test and blending: checks the corresponding depth (and stencil) value of the fragment and uses those to check if the resulting fragment is in front or behind other objects and should be discarded accordingly In modern OpenGL, we need to implement our own vertex shader and fragment shader (no defualt on GPUs). CoordinateIn OpenGL, a position contains (x, y, z) information. OpenGL only processes 3D coordinates within the range from [-1, 1], which are called normalized device coordinates. Anything else will be invisible on the screen. VBOVertex buffer object is used to store a large number of vertices in GPU memory. The purpose of VBO is that we can send large batches of data all at once to GPU, without having to send one vertex at a time. 1234unsigned int VBO;glGenBuffers(1, &amp;VBO); // create object behind the scene and return a reference IDglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); VAOVertex array object can be bound to one/multiple VBOs. After the binding of VAO, any subsequent vertex attribute calls from that point on will be stored inside the VAO. Whenever we want to draw something, we just bind the VAO, which makes the switching between different vertex data and configuration much easier. 123456789unsigned int VAO;glGenVertexArrays(1, &amp;VAO); glBindVertexArray(VAO);// after this point, the newly created VBO will be bound to VAOglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); EBOElement buffer object stores indices that OpenGL uses to decide what vertices to draw. By doing that, we can address the problem where we have multiple triangles that have overlap vertexes. Let’s take a look at one example. 12345678910float vertices[] = { // first triangle 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, 0.5f, 0.0f, // top left // second triangle 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left}; However, duplicate vertexes are not necessary. We can further simplify it as: 12345678910float vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left };unsigned int indices[] = { // note that we start from 0! 0, 1, 3, // first triangle 1, 2, 3 // second triangle}; Similar to VBO, EBO can be used as follows: 123456789101112131415161718unsigned int EBO;glGenBuffers(1, &amp;EBO);glBindVertexArray(VAO);// after this point, VBO and EBO will be bound to VAOglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// vertex attributesglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// to drawglBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); Put everything togetherThe program draws two triangles side by side. One is green and another is blue. F1 controls the draw mode. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;iostream&gt;#include &lt;vector&gt;#include &quot;include/glad.h&quot;#include &lt;GLFW/glfw3.h&gt;GLenum line_type = GL_LINE;const char *vertexShaderSource = &quot;#version 330 core\\n&quot; &quot;layout (location = 0) in vec3 aPos;\\n&quot; &quot;void main()\\n&quot; &quot;{\\n&quot; &quot; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot; &quot;}\\0&quot;;const char *fragmentShaderSource = &quot;#version 330 core\\n&quot; &quot;out vec4 FragColor;\\n&quot; &quot;void main()\\n&quot; &quot;{\\n&quot; &quot; FragColor = vec4(0.1f, 0.5f, 0.2f, 1.0f);\\n&quot; &quot;}\\n\\0&quot;;void handleInput(GLFWwindow* window) { if (glfwGetKey(window, GLFW_KEY_F1) == GLFW_PRESS) { std::cout &lt;&lt; &quot;F1 pressed\\n&quot;; line_type = line_type == GL_LINE ? GL_FILL : GL_LINE; glPolygonMode(GL_FRONT_AND_BACK, line_type); }}int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // Create a window object GLFWwindow* window = glfwCreateWindow(800, 600, &quot;Triangle&quot;, NULL, NULL); if (window == nullptr) { std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // Initialize GLAD before we call any OpenGL functions // glad: load all OpenGL function pointers if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1; } // Shader object unsigned int vertexShader; unsigned int fragmentShader; vertexShader = glCreateShader(GL_VERTEX_SHADER); fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, nullptr); glCompileShader(vertexShader); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, nullptr); glCompileShader(fragmentShader); // check shader compilation int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) { glGetShaderInfoLog(vertexShader, 512, nullptr, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; } glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) { glGetShaderInfoLog(fragmentShader, 512, nullptr, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; } // create Shader program unsigned int shaderProgram; shaderProgram = glCreateProgram(); // attach shaders to the program glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); // check link status glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) { glGetProgramInfoLog(shaderProgram, 512, nullptr, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; } // delete shader objs after linking glDeleteShader(vertexShader); glDeleteShader(fragmentShader); float vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left }; unsigned int indices[] = { // note that we start from 0! 0, 1, 3, // first triangle 1, 2, 3 // second triangle }; // vertex buffer objects (VBO) that can store a large number of vertices in the GPU's memory // VAO is an object that encapsulates a set of vertex array states, including the configuration of vertex attributes and their associated data. unsigned int VAO; unsigned int VBO; unsigned int EBO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); // bind VAO glBindVertexArray(VAO); // specify buffer type glBindBuffer(GL_ARRAY_BUFFER, VBO); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); // copy data // GL_STREAM_DRAW: the data is set only once and used by the GPU at most a few times. // GL_STATIC_DRAW: the data is set only once and used many times. // GL_DYNAMIC_DRAW: the data is changed a lot and used many times. glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); // tell opengl how to interpret the vertex data glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); while(!glfwWindowShouldClose(window)) { // handle user input handleInput(window); // render glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // draw triangle glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glfwSwapBuffers(window); glfwPollEvents(); } // de-allocate resources glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glDeleteProgram(shaderProgram); // glfw: terminate, clearing all previously allocated GLFW resources. glfwTerminate(); return 0;} References https://learnopengl.com/Getting-started/Hello-Triangle","link":"/CGV/misc-learn-opengl-3/"},{"title":"McDonald&#39;s Coke Tastes Better?","text":"A fun fact. Based on the two referenced articles, here are some reasons why McDonald’s coke stands out. Stainless Steel Syrup Storage – Unlike other restaurants that use plastic bags, McDonald’s partners with Coca-Cola and stores syrup in stainless steel tanks, keeping it fresher and better protected from external factors. High-Quality Water Filtration – McDonald’s filters its water thoroughly, ensuring a consistent and clean taste in every location. Pre-Chilled Syrup – The syrup is stored cold before being mixed, unlike other places where it sits at room temperature. Optimized Syrup-to-Water Ratio – McDonald’s adjusts the ratio to account for ice melt, preventing the drink from becoming too diluted. Pre-Chilled Water – Water used in the soda fountain is kept just above freezing through an insulated tube, maintaining cold temperatures for better carbonation (The colder temperatures allow for more CO2, keeping the Coke crisp and bubbly for longer.). Wider Straws – McDonald’s straws are slightly wider than average, enhancing the taste experience by allowing more flavor to hit your taste buds at once. References https://www.allrecipes.com/article/why-mcdonalds-coke-tastes-better-than-all-others/ https://www.mcdonalds.com/us/en-us/faq/why-does-coca-cola-taste-so-good-at-mcdonald-s.html","link":"/misc/misc-mcdonald-coke-tastes-better/"},{"title":"Repost&#96;:&#96; Leetcode 101","text":"source: https://github.com/changgyhub/leetcode_101","link":"/resource/misc-leetcode-101/"},{"title":"Learn OpenGL 7","text":"Coordinate Systems IntroductionOpenGL expects all the vertices to be normalized in order to be seen on the screen. Transforming coordinates to normal device coordinates requires several different transformations. Each transformation corresponds to a certain coordinate system. There are five different coordinate systems. local space world space view space clip space screen space local spaceLocal space is the coordinate space that is local to your object. All the transformations (translation, rotation and scale) mentioned in the previous tutorial apply to local space with model matrix. world spaceWorld space is where all the objects are located. The model matrix translates, scales and/or rotates your object to place it in the world at a location/orientation they belong to. A realistic example is: Think of it as transforming a house by scaling it down (it was a bit too large in local space), translating it to a suburbia town and rotating it a bit to the left on the y-axis so that it neatly fits with the neighboring houses. view spaceThe view space is the result of transforming your world-space coordinates to coordinates that are in front of the user’s view. The view space is thus the space as seen from the camera’s point of view. clip spaceIn clip space, coordinates that are outside of the specific range will be clipped. There are two types of projections: orthographic projection and perspective projection. Orthographic projection defines a cube-like frustum box. All the coordinates inside this frustum will be visible and within the range of NDC. In GLM, it defines as: 12// left right bottom top near farglm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f); The problem of orthographic projection is that it does not mimic the real world scenario. In real life, objects that are farther away appear much smaller. Homogeneous coordinates plays an important role in perspective projection. The projection matrix maps a given frustum range to clip space, but also manipulates the w value of each vertex coordinate in such a way that the further away a vertex coordinate is from the viewer, the higher this w component becomes. Each component of the vertex coordinate is divided by its w component giving smaller vertex coordinates the further away a vertex is from the viewer. In GLM, it defines as: 12// FOV aspect-ratio near farglm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f); Put all together Vclip=Mprojection⋅Mview⋅Mmodel⋅VlocalV_{clip} = M_{projection} \\cdot M_{view} \\cdot M_{model} \\cdot V_{local}Vclip​=Mprojection​⋅Mview​⋅Mmodel​⋅Vlocal​ vertex shader 123456789101112131415#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexture;out vec3 ourColor;out vec2 TexCoord;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main() { gl_Position = projection * view * model * vec4(aPos, 1.0); TexCoord = aTexture;} host program 123456789101112131415161718192021// activate shadershader.activate();// transform matrixglm::mat4 view = glm::mat4(1.0f);glm::mat4 projection = glm::mat4(1.0f);view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));projection = glm::perspective(glm::radians(45.0f), ((float)(screenWidth)) /((float)(screenHeight)), 0.1f, 100.0f);glUniformMatrix4fv(glGetUniformLocation(shader.getID(), &quot;view&quot;), 1, GL_FALSE, glm::value_ptr(view));glUniformMatrix4fv(glGetUniformLocation(shader.getID(), &quot;projection&quot;), 1, GL_FALSE, glm::value_ptr(projection));// drawglBindVertexArray(VAO);for (int i = 0; i &lt; 10; i++) { glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, cubePositions[i]); if (i % 3 || i == 0) model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(0.5f, 1.0f, 0.0f)); glUniformMatrix4fv(glGetUniformLocation(shader.getID(), &quot;model&quot;), 1, GL_FALSE, glm::value_ptr(model)); glDrawArrays(GL_TRIANGLES, 0, 36);} Z-bufferOpenGL stores all its depth information in a z-buffer. Whenever the fragment wants to output its color, OpenGL compares its depth values with the z-buffer. If the current fragment is behind the other fragment it is discarded, otherwise overwritten. This process is called depth testing. To enable depth testing: 1glEnable(GL_DEPTH_TEST); Make sure to clear depth buffer at the beginning of each rendering loop. 1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); Demo References https://learnopengl.com/Getting-started/Coordinate-Systems https://yihui.org/en/2018/07/latex-math-markdown/","link":"/CGV/misc-learn-opengl-7/"},{"title":"Android MediaCodec","text":"MediaCodec basics and how to decode a video with it. 1. IntroductionMediaCodec is a low-level API in Android used for encoding and decoding audio and video data. It provides access to hardware-accelerated codecs, allowing developers to process multimedia content efficiently. MediaCodec is a part of the Android framework and can be used for tasks like playing, recording, or streaming media. Key Features: Hardware Acceleration: Utilizes the device’s hardware for efficient media processing. Flexibility: Supports a wide range of media formats and configurations. Asynchronous Processing: Allows non-blocking operations with callbacks or a synchronous mode. Client(left) requests an empty input buffer from codec, fill it up wtih data and send it back to codec for processing. Codec uses the data and transform it into an output buffer. Client(right) receives a filled output buffer, consume its contents and release it back to the codec. MediaCodec exists in one of three states: stopped, executing and released. StoppedWhen a MediaCodec is created, it is in Uninitialized state. After we configure it via configure(...), it goes into Configured state. Then we can call start() to move it to the Executing state. ExecutingThe Executing state has three sub-states: Flushed, Running and End-of-Stream. Immediately after start() the codec is in the Flushed sub-state, where it holds all the buffers. As soon as the first input buffer is dequeued, the codec moves to the Running sub-state, where it spends most of its life. When you queue an input buffer with the end-of-stream marker, the codec transitions to the End-of-Stream sub-state. In this state the codec no longer accepts further input buffers, but still generates output buffers until the end-of-stream is reached on the output. ReleasedWhen you are done using a codec, you must release it by calling release(). 2. Synchronous ModeMediaCodec can operate in both synchronous and asynchronous modes. For synchronous mode(blocking mode), each operation blocks the thread until the operation completes or a timeout occurs. code example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void startDecoding() { isPlaying = true; Thread decodingThread = new Thread(() -&gt; { try { if (decoder == null || extractor == null) { runOnUiThread(() -&gt; Toast.makeText(MainActivity.this, &quot;Decoder or extractor is null&quot;, Toast.LENGTH_SHORT).show()); return; } MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); boolean isEOS = false; long startMs = System.currentTimeMillis(); while (!isEOS &amp;&amp; isPlaying) { // Handle pause state synchronized (pauseLock) { while (isPaused &amp;&amp; isPlaying) { try { pauseLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } if (!isEOS) { int inIndex = decoder.dequeueInputBuffer(10000); if (inIndex &gt;= 0) { ByteBuffer buffer = decoder.getInputBuffer(inIndex); buffer.clear(); int sampleSize = extractor.readSampleData(buffer, 0); if (sampleSize &lt; 0) { decoder.queueInputBuffer(inIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM); isEOS = true; } else { long presentationTimeUs = extractor.getSampleTime(); decoder.queueInputBuffer(inIndex, 0, sampleSize, presentationTimeUs, 0); extractor.advance(); } } } int outIndex = decoder.dequeueOutputBuffer(info, 10000); switch (outIndex) { case MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED: case MediaCodec.INFO_OUTPUT_FORMAT_CHANGED: case MediaCodec.INFO_TRY_AGAIN_LATER: break; default: if (outIndex &gt;= 0) { // Adjust presentation time when paused if (!isPaused) { long sleepTime = info.presentationTimeUs / 1000 - (System.currentTimeMillis() - startMs); if (sleepTime &gt; 0) { try { Thread.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } } decoder.releaseOutputBuffer(outIndex, !isPaused); } } if ((info.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) { break; } } } catch (Exception e) { e.printStackTrace(); runOnUiThread(() -&gt; Toast.makeText(MainActivity.this, &quot;Decoding error: &quot; + e.getMessage(), Toast.LENGTH_SHORT).show()); } finally { releaseResources(); } }, &quot;DecodingThread&quot;); decodingThread.start();} 3. Asynchronous ModeAccording to the Android official documentation, since Build.VERSION_CODES.LOLLIPOP, the preferred method is to process data asynchronously by setting a callback before calling configure. Input/output buffers are handled in callback methods. code example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private final MediaCodec.Callback callback = new MediaCodec.Callback() { @Override public void onInputBufferAvailable(MediaCodec codec, int index) { ByteBuffer inputBuffer = codec.getInputBuffer(index); if (inputBuffer == null) return; int sampleSize = extractor.readSampleData(inputBuffer, 0); long presentationTimeUs = 0; if (sampleSize &lt; 0) { codec.queueInputBuffer(index, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM); } else { presentationTimeUs = extractor.getSampleTime(); codec.queueInputBuffer(index, 0, sampleSize, presentationTimeUs, 0); extractor.advance(); } } @Override public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) { if (startMs == 0) { startMs = System.currentTimeMillis(); } long presentationTimeMs = info.presentationTimeUs / 1000; long elapsedTimeMs = System.currentTimeMillis() - startMs; long sleepTimeMs = presentationTimeMs - elapsedTimeMs; if (sleepTimeMs &gt; 0) { try { Thread.sleep(sleepTimeMs); } catch (InterruptedException e) { e.printStackTrace(); } } codec.releaseOutputBuffer(index, true); } @Override public void onError(MediaCodec codec, MediaCodec.CodecException e) { e.printStackTrace(); } @Override public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) { // Handle format changes if needed }};private void configureCodec(Surface surface) throws IOException { startMs = 0; for (int i = 0; i &lt; extractor.getTrackCount(); i++) { MediaFormat format = extractor.getTrackFormat(i); String mime = format.getString(MediaFormat.KEY_MIME); if (mime != null &amp;&amp; mime.startsWith(&quot;video/&quot;)) { extractor.selectTrack(i); if (format.containsKey(MediaFormat.KEY_WIDTH) &amp;&amp; format.containsKey(MediaFormat.KEY_HEIGHT)) { videoWidth = format.getInteger(MediaFormat.KEY_WIDTH); videoHeight = format.getInteger(MediaFormat.KEY_HEIGHT); adjustAspectRatio(); } decoder = MediaCodec.createDecoderByType(mime); decoder.setCallback(callback); // decoder mode decoder.configure(format, surface, null, 0); decoder.start(); return; } } Toast.makeText(this, &quot;No video track found&quot;, Toast.LENGTH_SHORT).show();} 4. Demo LinkSource code can be found on my github.Synchronous modeAsynchronous mode References https://developer.android.com/reference/android/media/MediaCodec https://www.jianshu.com/p/ff65ef5207ce","link":"/misc/misc-mediacodec-basics/"},{"title":"申请NIW记录帖","text":"Updating 06/10很早之前就听说过NIW，一直没把它当回事儿。在前公司的时候都是那些PhD毕业的同事在申请，当时偶然听到他们有在讨论审稿，论文，引用量之类的，想当然觉得与自己一Master毕业的毫无关系，也就没往这方面多想。偶然一次在现在公司和同事吃饭聊天，聊到了现在公司的绿卡政策，估摸算了下按照现在的排期就算一切进展顺利（比如PWD，PERM之类的），都得在现在公司待上个五六年才能最终拿到绿卡，而且一旦换公司，之前公司帮忙做的I140就相当于作废，需要从头来一遍所有申请过程，换句话就是说公司办绿卡所有的状态都需要和该公司绑定，一旦换了雇主，之前的都不算。如果没有这位同事切身的经历，我也不会意识到这里面的问题大的很。 硅谷的大厂美其名曰待遇好，work life balance好，但也禁不住在这几年裁员浪潮的影响下主动辞退了一大部分员工，其中有相当大一部分比例是核心的工程师岗位。撇开裁员不说，事情的真相是大厂员工的在职率其实比大部分人想象的要低得多。比如： Uber 1.8y Tesla 2.1y Facebook 2.5y Google 3.2y Apple 5y Adobe 5.3y 消息来源：https://www.inc.com/business-insider/tech-companies-employee-turnover-average-tenure-silicon-valley.html 不管出于什么原因，把自己带入到基于大数的统计值中，一个码农在科技公司很难待得很久，以至于都熬不到公司绿卡获批的那一天。强如Adobe这种养老厂，平均也就只有～5y，按照上面算的5-6年的时间跨度，真正能让你待上这么久的公司，真的少之又少。我个人以为我在入职前司的时候能在里面待很久，毕竟当时那会儿毕业找工作已经不太友好了，能找到我对口喜欢并且在行业有点名气的公司我还是能接受的，工资低就低了点，新人嘛，学习知识和技术为主。没想到公司直接在2023年关停，打了所有人一个措手不及。所以啊，人不能想当然，你永远不知道未来会发生什么。还有一个很重要的原因是由于裁员的影响，大厂纷纷停止了PERM，这可是绿卡申请至关重要的一步，停了PERM就基本宣告了大厂普通码农申请绿卡的通道关闭了。从我和目前市面上咨询过的律师来看，最近一两年律所接了大量来自一线大厂工程师NIW的申请，大家都开始意识到求人不如求己的重要性。 那为什么大家都开始换赛道尝试NIW了呢？首先我们要了解下什么是NIW。NIW全称国家利益豁免，是EB2绿卡的一种特例（一般公司给办的就是EB2），专门针对对美国国家利益有特殊贡献的人群。一般来说在公司办EB2/EB3需要走PERM，时间大概在1到2年。而NIW可以直接省掉这一过程，直接拿到I140，确定Priority Date，进入排期。另外一个很大的优势是，NIW一旦拿到I140，它是跟着你人走的，就算换了雇主，I140不用重新申请，排期也不影响，甚至可以用该I140无限续H1B，直到排到485，拿到绿卡。这样一来，大大缩短了整个拿绿卡的时间线，并且把换工作带来的风险降到最低。说到这真的好想抽自己一巴掌，为什么不早点开始申请NIW呢？那阻碍我的原因究竟是什么呢？我想是我想当然觉得NIW门槛太高，不适合我。但其实只要做了一定的调研就会发现，这个东西真的就是一半靠自身，一半靠包装。网上没有论文没有引用没有审稿，最终获批NIW的例子比比皆是。和他们一对比，瞬间觉得自己也行了💪。 作为来🇺🇸求学读研究生，后面又找到了工作留在🇺🇸的国际生，NIW的归宿大部分都是奔着科研的方向去的。我自己挺幸运在读Master期间发了一篇还不错的文章，加上之前的一篇水刊，凑在一起也有了100的引用。虽说引用量还看得过去，但短板在于论文数量太少，好在基础条件有了，不至于一开始就一棍子打死。在如今这种留美日益艰难的局势下，何不大胆尝试下NIW，说不定就行了呢💪。 说干就干，立马一顿搜索，在小红书和一亩三分地找各种NIW相关律师推荐和极弱case通过案例，给了我极大的信心。接下来就是化身海王，各种联系律所/律师，像做这些移民相关的律师，都有个免费评估的服务，几乎我看的所有律所都有。不嫖白不嫖，一顿噼里啪啦发简历+个人学术主页。就我个人体验而言，几乎所有的律师能都做到在一个工作日内回复，告诉你评估结果，你是否有机会申请NIW，然后会附上一些文档，里面有详细的申请过程和费用清单。有的律师还主动提出了可以约一个电话来进行答疑。我觉得前期选择律师这是非常重要的一步，这个过程不仅是能对各个律所进行很好的横向对比，而且还能通过高效的对话对一些知识盲区查漏补缺，不断完善对这个事情的一个认知程度。就像我第一次和一个律所打电话，才知道了NIW的I140可以用来续H1B，虽然这可能会是一个很常规的知识，但它就是我之前所不知道的。 由于个人时间和精力有限，在查阅了网友的总结之后，选了几家出镜率比较高的律所进行咨询。我是06/07开始咨询第一家律所的，直到今天06/10，大概问了有11家律所，结果各不相同，费用也是大相径庭。简单做了一个表进行总结，方便后续自己做决定。希望有缘人也能看到这条blog，或许能帮到一些。因为在Agreement里面有提到不能disclose相关评估信息，所以律所名字做了模糊处理。 写这条blog的时候刚做完这张表格，还在考虑用哪一家。除了太贵的那几个（过万），其他其实都能接受。我个人其实很看重整个case的准备时间，像有几个和我说要半年左右的，真的基本就想pass了。有问过几个做过NIW的朋友，都说这个时间太夸张了，最多三四个月就能搞定所有材料。然而很搞笑的是几乎所有律所都不会告诉你整个时间线，要花多久时间准备材料，需要你自己多问一嘴，他们才会告诉你一个历史数据。所以这也是为什么一定要多一步电话咨询的过程。有很多问题都是一开始隐性的，只有开始做了才会发现这不是我想要的，前期功课真的要做足才能避开所有对你不利的因素。看这个样子我很有可能会选比较便宜的那一家，如果他能给到一个合理的时间范围。这个帖子会持续更新NIW的申请进度，到时候再回来看看我到底选了谁。 正好在这儿记录一些和律师沟通可以问的一些问题，也算是给自己做个笔记了。 关于时间线，从开始准备材料到寄出材料平均一共要多久？ 几封推荐信？找哪些推荐人比较合适？ 谁来负责写推荐信，SoC，proposed endeavor？是律师写还是给模版自己写？ USCIS的filing fee是自己额外付吗？ 如果有RFE，额外收费吗？ 如果deny，重新filing收费吗？可以重新做filing多少次？ 如果deny，是否有退款？退款政策是什么？ 如果我一个月收集完成了所有我负责的材料，你们能多快寄出我的case？ 你们历史的通过率是多少？你觉得我的case通过几率如何？ Refile情况下filing fee是不是还要重新付？ 之前有咨询过一个律师，有提到我现在公司不是美国公司，写proposed endeavor可能不太好写，因为不太容易和美国国家利益扯上关系，这个你怎么看？ 产假结束前（06/17）希望能敲定律所，后面就专心准备材料了. 现在真的是每天晚上睡觉都在想这事儿，一想到每天都有那么多人提交NIW，队伍越来越长，越晚一天对自己越不利。所以啊，快点行动起来。 06/11确定了律师🎉，总算迈出了第一步💪。今天一共和三个律师通了电话，最终签合同的律师其实是第一个通话的，询问了上面所列到的一些问题。他提到我的case引用数量没什么问题，他之前做过很多引用才二三十的，短板在于文章数量不够多，给我估了个80%的通过率，说要是再有一篇paper，那就是100%了。行吧，80%我觉得也可以了。反正就算不过他可以重新提交，按照统计的概率，递交两次的通过概率就变成了96%。通完电话就立马签合同汇款。下午又和其他两个律师通了电话，其实也无意和他们签约了，只是想了解了解行情。价格方面都比第一家要贵，而且处理时间也没有第一家快。我还特别询问了关于我的这个case通过率怎么样，这两家给我的回复是：没有问题+qualified。莫名给自己增加了信心😂。 （为了不产生协议纠纷，以下过程以比较通俗的术语来描述，不会照搬通信过程中的某些关键词）签完第一家差不多是中午，等到下午6点多回的我。把双方签字的协议和一些相关材料发给了我。准备材料的第一件事是需要给律师提供一份自己的research highlight，之前讲过这个律师帮忙draft所有文书，但是前提是要对我的经历要足够了解。这个highlight也就是简单的两页来概括下以前的科研成果，以便律师对我整个人有个比较全面的了解。我准备最多两天时间来搞定这个发给他review，我觉得依靠chatgpt+txyz应该用不了多久。 06/12今天脑海里想了下推荐人名单，大致有五个候选人，而且都比较好联系到。我觉得推荐人应该ok。和律师要了联系推荐人的邮件模版，大致用chatgpt改了改。感觉只有其中一个美国教授需要用邮件联系，其他都有微信联系方式。邮件已发，等待回复。其他推荐人目前联系了一个而且答应了，反正后面都联系下，提前和他们说下推荐信的事儿。 今天下午集中精神把两页的highlight给写了，又用AI改了改，觉得差不多就发给了律师，顺带附上了五个推荐人的信息。等律师消息。 律师下班这么晚的嘛，六点半回我邮件说Highlight写的不错，于是又让我开始填Research Statement。看了看，感觉和highlight的区别在于需要更详细描述学术贡献，做了什么，发现是什么。虽然给了模版，但还是琢磨琢磨，手敲很多文字。 06/13早上起床收到导师微信，说可以做推荐人。 今天边带娃边起草Statement，这玩意儿自己写可真太痛苦了。直接把论文Pdf扔到chatgpt和Claude，按照要求让AI帮我写了写，还真别说，总结的相当可以。再适当给一些feedback，让AI稍微改进和润色下，已经非常有模有样了。AI大模型用来写文书感觉效率太高了，用词和语句组织真的完全不输专业文书写手。预计今晚和明天再改改就发给律师。 今天上午又和其中一个律所打了个电话。我为什么还要接电话呢，因为我还是想多了解了解整个申请过程和不同机构对我的评估。总结下来就是他们觉得我的通过率在六七成，并且愿意接受我的case。其实之前已经和这个律所通过电话，他们明确表示他们审核十分严格，只接受他们觉得可以通过的case。那这样一想，是不是他们觉得我其实好好包装下还是能过的？可人家收费太高了，而且高的离谱，本来也不是我的首选。我现在也差不多知道了自己几斤几两，要通过还是比较有希望的，现在能做的就是把所有材料尽量写的详细和专业些，后面好让律师帮忙draft更好一些。自此也让我明白了一个道理，人无论在什么时候都尽量把当下的事情尽力做好，指不定哪天以前的某些行为会对你后面的人生产生积极影响。就像如果没有当时费了老半天劲儿发了那几篇文章，现在也没有资格去申请NIW。 06/14把写好的Statement发了一个google doc的链接，结果让我又发一个单独的doc。于是发了过去。 06/15周末 06/16周末 06/17说收到文件，会仔细review一遍再联系我。 06/18 - 06/20No update. 06/21主动发了邮件询问timeline。催一催还是有效果的，把review的反馈给了我，周末准备改改看。 06/22周末 06/23周末 06/24由于修改的地方比较多，索性晚上一鼓作气把Research Statement重写了一遍。11点左右发了过去。看来以后要隔个两天就要去主动催一下，不催不回消息。四个推荐人三个回了我，还有一个教授迟迟不回我邮件，用了之前学校邮箱又发了一封，希望能回复。 06/25每次把材料发过去回复倒挺快，但都是模版回复。要是明天不给反馈准备发邮件跟进下。 06/27和律师简单follow up了一下，询问进度。同时还提到了8月要出的新规，有可能对现阶段NIW的审批有影响。 06/28律师问我消息来源是哪里，于是我就发了https://www.reginfo.gov/public/do/eAgendaViewRule?pubId=202310&amp;RIN=1615-AC85, 但是他还是说This does not mean anything for now.","link":"/misc/misc-niw/"},{"title":"Learn OpenGL 6","text":"Transformations Github source code: linklearning materials: learnopengl IntroductionTransformations contain translation, scale, rotation or a combination of one or more of these. One thing to note is that when combing multiple matrices, the order should be read from right-to-left. If we want to do scale first then translation, It should look like this: GLMGLM stands for OpenGL Mathematics and is a header-only library. It is an easy-to-use OpenGL math library. Download it from official website, put glm folder under your project, include needed headers. 123#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt; DemoTransformation matrices can be passed to vertex shader using uniform from host program. host 12345678// activate shadershader.activate();// transform matrixglm::mat4 trans = glm::mat4(1.0f);trans = glm::translate(trans, glm::vec3(-0.5f, 0.5f, 0.0f));trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f)); // axis needs to be unitglUniformMatrix4fv(glGetUniformLocation(shader.getID(), &quot;transform&quot;), 1, GL_FALSE, glm::value_ptr(trans)); vertex shader 123456789101112131415#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexture;out vec3 ourColor;out vec2 TexCoord;uniform mat4 transform;void main() { gl_Position = transform * vec4(aPos, 1.0); ourColor = aColor; TexCoord = aTexture;} References https://learnopengl.com/Getting-started/Transformations","link":"/CGV/misc-learn-opengl-6/"},{"title":"Integrate libpng in C++","text":"Integrate libpng to C++ projects and read external images. If you frequently work on image processing using C++, you likely need to read images from the local disk and apply post-processing to test your algorithms. Many of these images are in PNG format. This tutorial provides a straightforward method to integrate libpng into any C++ project, enabling developers to read PNG images. 1. Download and build zliblibpng depends on zlib. 1234567git clone https://github.com/madler/zlib.gitcd zlibmkdir buildcd buildcmake ..makesudo make install 2. Download and build libpng123456git clone https://github.com/glennrp/libpng.gitcd libpngmkdir buildcd buildcmake ..make 3. Copy files to project directory123456789101112.├── CMakeLists.txt├── example.png├── include│ ├── png.h│ ├── pngconf.h│ ├── pnglibconf.h│ └── zlib.h├── lib│ ├── libpng.a│ └── libz.a└── main.cpp main.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;png.h&gt;void read_png_file(const char* file_name, std::vector&lt;unsigned char&gt;&amp; image, unsigned&amp; width, unsigned&amp; height) { FILE *fp = fopen(file_name, &quot;rb&quot;); if (!fp) { std::cerr &lt;&lt; &quot;Error: Cannot open file &quot; &lt;&lt; file_name &lt;&lt; std::endl; return; } png_structp png = png_create_read_struct(PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr); if (!png) { std::cerr &lt;&lt; &quot;Error: Cannot create png read struct&quot; &lt;&lt; std::endl; fclose(fp); return; } png_infop info = png_create_info_struct(png); if (!info) { std::cerr &lt;&lt; &quot;Error: Cannot create png info struct&quot; &lt;&lt; std::endl; png_destroy_read_struct(&amp;png, nullptr, nullptr); fclose(fp); return; } if (setjmp(png_jmpbuf(png))) { std::cerr &lt;&lt; &quot;Error: png jump buffer error&quot; &lt;&lt; std::endl; png_destroy_read_struct(&amp;png, &amp;info, nullptr); fclose(fp); return; } png_init_io(png, fp); png_read_info(png, info); width = png_get_image_width(png, info); height = png_get_image_height(png, info); png_byte color_type = png_get_color_type(png, info); png_byte bit_depth = png_get_bit_depth(png, info); if (bit_depth == 16) png_set_strip_16(png); if (color_type == PNG_COLOR_TYPE_PALETTE) png_set_palette_to_rgb(png); if (color_type == PNG_COLOR_TYPE_GRAY &amp;&amp; bit_depth &lt; 8) png_set_expand_gray_1_2_4_to_8(png); if (png_get_valid(png, info, PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png); if (color_type == PNG_COLOR_TYPE_RGB || color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_PALETTE) png_set_filler(png, 0xFF, PNG_FILLER_AFTER); if (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA) png_set_gray_to_rgb(png); png_read_update_info(png, info); image.resize(png_get_rowbytes(png, info) * height); std::vector&lt;png_bytep&gt; row_pointers(height); for (unsigned i = 0; i &lt; height; ++i) row_pointers[i] = image.data() + i * png_get_rowbytes(png, info); png_read_image(png, row_pointers.data()); png_destroy_read_struct(&amp;png, &amp;info, nullptr); fclose(fp);}int main() { const char* file_name = &quot;../example.png&quot;; std::vector&lt;unsigned char&gt; image; unsigned width, height; read_png_file(file_name, image, width, height); std::cout &lt;&lt; &quot;Image width: &quot; &lt;&lt; width &lt;&lt; &quot;, height: &quot; &lt;&lt; height &lt;&lt; std::endl; // Now you can use the 'image' vector which contains the raw pixel data. return 0;} CMakeLists.txt 123456789101112131415161718192021222324cmake_minimum_required(VERSION 3.10)# Project nameproject(ReadPNG)# Specify the C++ standardset(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# Include directoriesinclude_directories(include)# Add the static librariesadd_library(png STATIC IMPORTED)set_target_properties(png PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/lib/libpng.a)add_library(z STATIC IMPORTED)set_target_properties(z PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/lib/libz.a)# Add the executableadd_executable(read_png main.cpp)# Link the librariestarget_link_libraries(read_png png z) 4. Compile and run12345mkdir buildcd buildcmake ..make./read_png 1Image width: 1568, height: 1712","link":"/misc/misc-read-png/"},{"title":"SIMD Intro","text":"SIMD introduction. 1. IntroductionSingle Instruction, Multiple Data (SIMD) is a parallel computing architecture that enhances the performance of processors by allowing them to execute a single instruction on multiple pieces of data simultaneously. SIMD is particularly effective for applications that perform the same operation on large data sets, such as multimedia processing, scientific computing, and machine learning. Common SIMD Instruction Sets SSE (Streaming SIMD Extensions): Developed by Intel for x86 processors. Introduced in 1999, SSE provides instructions for parallel processing of floating-point and integer data. AVX (Advanced Vector Extensions): Also developed by Intel, AVX is an advanced SIMD extension for x86 processors. AVX extends the capabilities of SSE with wider vector registers (256 bits in AVX, 512 bits in AVX-512) and additional instructions. ARM NEON: Developed for ARM architecture, NEON is a 128-bit SIMD extension. Widely used in mobile and embedded devices for multimedia processing and other compute-intensive tasks. AltiVec (also known as VMX): Developed for PowerPC processors, AltiVec is a 128-bit SIMD extension used for high-performance computing and multimedia applications. SVE (Scalable Vector Extension): Developed by ARM for high-performance and scientific computing. SVE supports variable vector lengths, providing flexibility and scalability. RISC-V Vector Extension: An open-source SIMD extension for the RISC-V architecture. Supports variable-length vector operations, similar to ARM’s SVE. 2. ARM NeonARM Neon is widely used in mobile devices, embedded systems, and increasingly in general-purpose computing platforms like Apple’s M1 and subsequent chips. ARM NEON is crucial for mobile computing as it provides significant performance improvements, energy efficiency, and enhanced capabilities for multimedia, gaming, machine learning, and real-time processing applications. Its ability to process multiple data elements in parallel makes it an essential feature for modern mobile devices, ensuring a responsive, efficient, and high-quality user experience. 2.1 ARMv8 Neon RegisterARMv8 is a 64-bit based architecture and was introduced in 2011. It applies to most of the modern smartphones, embeded devices. In addition, its higher bit capacity makes it suitable for high performance computing. ARMv8 architecture provides 32 NEON registers, named V0 to V31. Each NEON register is 128 bits wide. As the figure shown above, the 128-bit NEON registers can be accessed as sub-registers for different data types and vector lengths. This allows efficient packing of data for SIMD operations. One 128-bit quadword (Q) Q0-A31 Two 64-bit doublewords (D) D0-D31 Four 32-bit words (S) S0-S31 Eight 16-bit halfwords (H) H0-H31 Sixteen 8-bit bytes (B) B0-B31 2.2 Lanes and LoadIn ARM NEON, lanes refer to the individual elements within a vector register. Each vector register (V0-V31) is 128 bits wide and can be divided into lanes, depending on the data type: 16 lanes of 8-bit integers 8 lanes of 16-bit integers 4 lanes of 32-bit integers or single-precision floating-point numbers 2 lanes of 64-bit integers or double-precision floating-point numbers 123456789101112131415int32x4_t vec = vdupq_n_s32(0);// Load data[0] into lane 0 of vecvec = vld1q_lane_s32(&amp;data[0], vec, 0);// Load data[1] into lane 1 of vecvec = vld1q_lane_s32(&amp;data[1], vec, 1);// Load data[2] into lane 2 of vecvec = vld1q_lane_s32(&amp;data[2], vec, 2);// Load data[3] into lane 3 of vecvec = vld1q_lane_s32(&amp;data[3], vec, 3);// Now vec contains: [data[0], data[1], data[2], data[3]] 3. ConclusionUnderstanding these core concepts is essential for comprehending parallelism in ARM Neon and writing efficient code. We’ll continue to delve further into more aspects of ARM Neon intrinsics. References https://eclecticlight.co/2021/08/23/code-in-arm-assembly-lanes-and-loads-in-neon/","link":"/misc/misc-simd1/"},{"title":"更新护照","text":"记录下最近在中国驻旧金山领事馆更新护照的经历 1. 第一步下载“中国领事”APP，在APP里提起更新护照的申请，一步步按照指示来就行。这里面最tricky的部分就是上传一张新护照要用的证件照，首先需要是白底，大小也有规定33x48mm, 对于头顶留白，下巴的位置也有要求，还有不能有反光等一系列要求。一开始没什么经验，用手机的原相机拍了一张，然后随便找了一个免费网站处理了一下就提交了。后来被打回来重新提交，还好领事馆提醒可以在微信里面用小程序“智绘免费证件照制作”来拍证件照。亲身体验下来非常好用，强推。申请费用$23，可以直接跳转微信支付。好了之后等待审核材料就可以了，一般几个工作日就有结果。 2. 第二步提交完之后没问题过几天就会更新状态，这时候就可以约时间了，目前需要本人亲自去现场录指纹。去之前还要准备好四样东西： 旧护照 $23的Money Order或者Cashier Check（如果没有微信支付的话） 在USPS购买已经支付了邮费的信封，有两点需要注意：1. From和To都写自己的地址，防止寄错了可以返回给你。2. 要一个tracking number，可能需要多花一些钱（也不是很多），确保自己能够查到包裹的状态。 APP里预约的条形码打印 3. 第三步去旧金山中国领事馆排队录指纹，早上九点半开门，我们10:15到的时候已经大排长龙了。建议可以凑着开门的时间去，或者避开周五。停车有一个绝佳的选择地点：Parking Garage @ Japan Center, 步行去领事馆只要五分钟。个人经验：更新护照基本没什么人，进去取号之后一会儿就轮到了。最后，和工作人员确认了，新旧护照都会邮寄回来。","link":"/life/life-renew-passport/"},{"title":"Recursion Template","text":"Memorization Divide and conquer Backtracking 1. MemorizationTo avoid duplicate calculation in subproblems. 1234567891011121314151617181920212223class Solution {private: std::unordered_map&lt;int, int&gt; _map; // Use a map to keep previous results.public: int memorizatio(int n) { // Check if the answer has been calculated. if (_map.find(n) != _map.end()) return _map[n]; int ans = 0; // Base case // ans = ... // Recursion relation // ans = ... // Save results _map[n] = ans; return ans; }}; 2. Divide and Conquer Divide Divide the problem $S$ into subproblems ${S_1, S_2, …S_n}$, where $n &gt;= 2$. Conquer Solve each subproblem. Combine Combine the results of each subproblem. 12345678910111213bool divideAndConquer(S) { // Base case // 1. Null detection // 2. Solve the minimal subproblem // Divide the problem and solve subproblems bool res1 = divideAndConquer(S1); bool res2 = divideAndConquer(S2); // ... // Return combine results return combine(res1, res2);} 3. Backtracking123456789101112131415161718void backtracking(candidate) { // Return if candidate is valid. if (candidate) return; // Iterate all possible candidates. for (auto candi : candidates) { // Make sure candi is valid if (candi) { // 1. Modify candi modify(candi) // 2. Run backtracking backtracking(modified(candi)); // 3. Revert the change revert(candi); } }}","link":"/interview/misc-recursion/"},{"title":"Sliding Window Template","text":"A generic sliding window template. 1. Template1234567891011121314151617181920212223242526272829303132int sliding_window_template(const vector&lt;int&gt;&amp; arr, int k) { int n = arr.size(); int left = 0, right = 0; int max_result = 0; // variable to store the result // Optionally, you might need additional data structures like a map or set. unordered_map&lt;int, int&gt; window; // Expand the window by moving the 'right' pointer for (; right &lt; n; right++&gt;) { // Add the current element to the window window[arr[right]]++; // Shrink the window if necessary while (/* some condition related to the problem */) { // Remove the leftmost element from the window window[arr[left]]--; if (window[arr[left]] == 0) { window.erase(arr[left]); } left++; // Shrink the window from the left } // Calculate or update the result using the current window max_result = max(max_result, right - left + 1); // Move the 'right' pointer to expand the window right++; } return max_result; // return the result} A shorter version: 12345678910111213141516int fn(vector&lt;int&gt;&amp; arr) { int left = 0, ans = 0, curr = 0; for (int right = 0; right &lt; arr.size(); right++) { // do logic here to add arr[right] to curr while (WINDOW_CONDITION_BROKEN) { // remove arr[left] from curr left++; } // update ans } return ans;} 2. Examples2.1 LeetCode 3. Longest Substring Without Repeating CharactersProblem Statement: Given a string s, find the length of the longest substring without repeating characters. 12345678910111213141516171819202122int lengthOfLongestSubstring(string s) { unordered_map&lt;char, int&gt; window; int left = 0, right = 0; int max_len = 0; while (right &lt; s.size()) { char c = s[right]; window[c]++; // Shrink the window if there is a duplicate character while (window[c] &gt; 1) { char left_char = s[left]; window[left_char]--; left++; } max_len = max(max_len, right - left + 1); right++; } return max_len;} 2.2 LeetCode 209. Minimum Size Subarray SumProblem Statement: Given an array of positive integers nums and a positive integer target, find the minimal length of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. 12345678910111213141516int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int left = 0, sum = 0, min_len = INT_MAX; for (int right = 0; right &lt; nums.size(); ++right) { sum += nums[right]; // Shrink the window until the sum is smaller than the target while (sum &gt;= target) { min_len = min(min_len, right - left + 1); sum -= nums[left]; left++; } } return min_len == INT_MAX ? 0 : min_len;} 2.3 LeetCode 567. Permutation in StringProblem Statement: Given two strings s1 and s2, return true if s2 contains a permutation of s1. In other words, one of s1’s permutations is a substring of s2. 1234567891011121314151617181920212223bool checkInclusion(string s1, string s2) { if (s1.size() &gt; s2.size()) return false; vector&lt;int&gt; s1_count(26, 0), window(26, 0); // Initialize the character counts for s1 and the first window in s2 for (int i = 0; i &lt; s1.size(); ++i) { s1_count[s1[i] - 'a']++; window[s2[i] - 'a']++; } // Slide the window across s2 for (int i = s1.size(); i &lt; s2.size(); ++i) { if (window == s1_count) return true; // Slide the window: remove the left character and add the right one window[s2[i] - 'a']++; window[s2[i - s1.size()] - 'a']--; } // Check the final window return window == s1_count;}","link":"/interview/misc-sliding-window-template/"},{"title":"最近的一些感悟","text":"记录下最近生活，工作和学习的一些个人想法 1. 知识的增长不是线性的 最近在学一些新知识的过程中突然有所感受，隐约当中和记忆里的某些知识产生了联动，一下子把离散的点给连接了起来，形成了一种知识的拓展。这让我想到乔布斯曾经说的过的“You can’t connect the dots looking forward; you can only connect them looking backward”。一个人过去的经历和所积累的知识都将成为自身的一部分，并且持续给你的成长来带正反馈。学习新知识就是一个很好的“connect dots”的过程，可能在我们年少时期学习的知识看似都是特别分散的，毫无关系可言，但随着我们慢慢的成长，不断主动或者被动地了解这个世界的运行规则，提升认知和知识水平，那些曾经毫无相关的东西，在更高一个知识纬度都是互通的。而随着时间的推移，当你再学习一个新的知识的时候，你也不再是仅仅学习这个知识点本身，而是对于所有你脑海中的知识结构有了一个更加深刻的洞察和认识。 2. 人生没有路是白走的 讲一个最近的事，这周一把小孩送去了day care，前一天还在各种担心会不会不适应，会不会哭闹，会不会睡不好，会不会不爱吃饭，会不会生病…等等。但第一天体验下来，根据老师的反馈和照片上的活泼开心劲，感觉对孩子来说似乎就是去玩了一趟而已，到点了就回家吃饭睡觉。我们挺惊讶于他的适应能力。现在刚好过去一周，孩子的精气神和在家似乎没什么变化，看上去过度十分自然。现在回过头来看，我觉得本质原因在于在他很小的时候就会经常带着他四处跑，各种坐车，坐飞机，遇见不同的人，看到了不一样的世界。孩子虽然一岁不到，大概率记不得出去玩的细节，但是这个过程却是培养和塑造了他的一个性格和处事的mindset。我还记得每次旅行完回家都能明显感觉到他自主行动上的一些进步，比如第一次坐起来，双手撑地爬，独自扶着站立。 3. 如何快速学习一个新的知识领域 作为初学者，最重要的就是要对不熟悉的领域先建立一个全局的观念。比如最近比较热点的俄乌战争，假设一个完全不熟悉俄乌战争的人想要了解它，那上来第一件事就是要纵观整个战争历史从2014开始，知道大概战争的导火索，每年大概都发生了什么重大事件，以及全球各国都扮演了什么角色。而不是一开始就抠细节，一门心思在那研究为什么泽兰斯基不愿意签署矿产协议，为什么持续了这么久双方都不停火等。在学习专业知识的时候我对此也感受颇深，一开始对于整个知识架构的认识极为重要，而往往几乎所有你能找到的教学材料都是按照具体每条知识点来整理教学大纲。这样的教学材料只能说它全面，但没能做到知识转播的最大效率。在AI时代，我认为AI最大的一个机制就是筛选人的机制，知识都是免费摆在那儿给你获取，就看每个个体如何利用AI来最大程度提升自己的知识水平。一些人可能只有在问题找到你的时候才会用AI来帮他们解决问题。但厉害的人都在用AI给自己建立知识堡垒。 4. 软实力的重要性 这点感触我是受到两个方面的启发：一个是最近工作当中所涉及到的工作内容让我不得不大量阅读并且产出一些文档，另外一个是最近听的一个播客里面有提到一个OpenAI的大佬也提到类似的事情，大概就是对于非母语者阅读和写作速度和质量都无法达到公司内部母语者的水平，使他感受到这方面的skill会让工作效率大幅提升。我自己的一个感觉是作为一个写代码的工程师，代码能力固然重要，但是决定你在公司或者同事之间credit的一个更大的因素是你做的东西或者你的idea是否能impact到更多的人。一个好的knowledge sharing或者知识的散播能有更加深远的边际效益，能够大范围增加你的visibility，建立和他人的trust。写blog的一个很大原因也是想提升自己的writing skill，如何把现有的知识体系用文字精简并且具体地表达出来是一个十分重要的能力。还有一个软实力我觉得越来越重要的就是如何有效沟通，很多时候不管是在职场还是平时交流，很多人都是在自言自语说自己想说的，并没有消化并且反馈到对话的另外一个人。有效的沟通最重要的一点是“听懂”对方说的话，并且给予反馈。 5. 灵感很重要，不要让它溜走 从前几个月开始，我养成了一个习惯，无论什么时候突然脑子里有一个idea，或者是一个想要学习的点，又或者是看到听到一个我感兴趣的topic，我会及时把它们写下来。我简单维护了一个Google Doc用来记录这些想法，每天我都会反复翻阅几遍，其中有些东西我也不打算深究下去，但大部分想法回过头去看还是很有意义的，我会找时间学习并且整理，用文字的方式来描述我对于它们的理解。记得大概一个月前听Joe Rogan采访Mrs. Beast的播客, Mrs. Beast现在稳坐Youtube粉丝数量第一，他的视频主要题材比较新颖，所以粉丝特别多，他提到自己源源不断的灵感来源于他平时会将自己的想法汇总到一个文档里，还会用随机生成文字的方式探索新的idea。他会经常坐在电脑前，盯着文档看很久来以此寻找下一个视频的素材内容。灵感是一个很美妙的东西，大部分人其实是根本没有意识到灵感的重要性，当它被具像化的时候，我们才能发现它的宝贵之处。","link":"/misc/misc-some-random-thoughts/"},{"title":"Slow and Fast Pointers","text":"Commonly used to detect cycles or find the middle of a list. 1. Template12345678910111213int fn(ListNode* head) { ListNode* slow = head; ListNode* fast = head; int ans = 0; while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) { // do logic slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return ans;} 2. Detect Cycles, LeetCode 141123456789101112131415161718192021struct ListNode { int val; ListNode* next; ListNode(int x) : val(x), next(nullptr) {}};// Example: Detecting a cycle in a linked list using fast and slow pointersbool hasCycle(ListNode* head) { if (head == nullptr || head-&gt;next == nullptr) return false; ListNode* slow = head; ListNode* fast = head-&gt;next; while (slow != fast) { if (fast == nullptr || fast-&gt;next == nullptr) return false; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return true;} 3. Find the Middle of a Linked List, LeetCode 876Problem: Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 1234567891011ListNode* middleNode(ListNode* head) { ListNode* slow = head; ListNode* fast = head; while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return slow; // When fast reaches the end, slow will be at the middle} 4. Happy Number, LeetCode 202A number is considered happy if repeatedly summing the squares of its digits leads to 1. If it enters a cycle that doesn’t include 1, it’s not a happy number. 123456789101112131415161718192021int sumOfSquares(int n) { int sum = 0; while (n) { int digit = n % 10; sum += digit * digit; n /= 10; } return sum;}bool isHappy(int n) { int slow = n; int fast = sumOfSquares(n); while (fast != 1 &amp;&amp; slow != fast) { slow = sumOfSquares(slow); fast = sumOfSquares(sumOfSquares(fast)); } return fast == 1;}","link":"/interview/misc-slow-fast-pointers/"},{"title":"The Art of Linear Algebra","text":"From https://github.com/kenjihiranabe/The-Art-of-Linear-Algebra 1. EN Version 2. CN Version","link":"/resource/misc-the-art-of-linear-algebra/"},{"title":"STL Container Cheat Sheet","text":"Write error-free code for interviews.","link":"/interview/misc-stl-container-cpp-cheatsheet/"},{"title":"国内互联网公司黑话","text":"职场八股文 素材来源：https://github.com/justjavac/ali-words 二字词汇赋能, 抓手, 中台, 闭环, 落地, 漏斗, 沉淀, 给到, 平台, 响应, 同步, 对齐, 对标, 迭代, 优化, 跟进, 升级, 交付, 聚焦, 倒逼, 复盘, 梳理, 输出, 提炼, 包装, 上升, 方案, 摸索, 踩坑, 填坑, 报备, 串联, 协同, 联动, 透传, 打通, 打平, 抹平, 发力, 兼容, 量化, 细分, 重塑, 蓄能, 引爆, 挖掘, 背书, 背锅, 支持, 支撑, 协调, 支援, 加持, 加速, 共建, 共创, 融合, 拉通, 拉升, 洞察, 渗透, 咬合, 穿梭, 辐射, 扩展, 开拓, 兜底, 降级, 容错, 容灾, 解耦, 耦合, 复用, 封装, 抽象, 聚合, 集成, 拆解, 抓包, 观察, 监控, 上报, 捕获, 分发, 分层, 迁移, 回溯, 回归, 回流, 回跳, 通晒, 吃透, 死磕, 树立, 跨界, 共情, 演绎, 画饼, 打造, 反哺, 输血, 造血, 造势, 造市, 造事, 下沉, 拉新, 转化, 留存, 促活, 付费, 营收, 盈利, 获客, 邀请, 助力, 激励, 激活, 推广, 投放, 导流, 覆盖, 曝光, 裂变, 增长, 优秀, 感恩, 比心, 笔芯, 下跪, 致敬, 订阅, 认证, 推送, 唤醒, 流失, 召回, 授权, 接入, 铸造, 构筑, 构建, 搭建, 布局, 组局, 摸鱼, 划水, 众筹, 收割, 共享, 重组, 收口, 转型, 围绕, 出击, 证言, 确认, 明确, 评估, 评审, 务实, 夯实, 预判, 预言, 变迁, 返佣, 深入, 打磨, 攻坚, 击穿, 破冰, 破题, 解题, 破圈, 破局, 定量, 定性, 制约, 约束, 触及, 触达, 触发, 操盘, 思考, 反思, 精简, 深耕, 突围, 补位, 抽离, 履约, 进化, 进军, 起飞, 皮实, 本分, 重磅, 垂直, 真香, 自洽, 精准, 持续, 灵活, 稳定, 可控, 活跃, 风口, 打法, 玩法, 矩阵, 纽带, 刺激, 规模, 场景, 渠道, 入口, 维度, 格局, 形态, 生态, 体系, 认知, 体感, 感知, 心智, 调性, 战役, 合力, 心力, 赛道, 基石, 基因, 因子, 模型, 通道, 链路, 水位, 水准, 姿态, 卡点, 卡位, 头部, 腰部, 踝部, 痛点, 爽点, 痒点, 全域, 公域, 私域, 本我, 自我, 超我, 蓝海, 红海, 纵向, 横向, 上限, 下限, 上游, 下游, 阈值, 场域, 架构, 系统, 标配, 长尾, 态势, 锚点, 标杆, 壁垒, 变量, 期权, 边界, 品牌, 阵地, 高地, 洼地, 高空, 革命, 变革, 内卷, 外包, 福报, 脑暴, 脑洞, 圈层, 层级, 段位, 环节, 困局, 话术, 文案, 议程, 公关, 配称, 力场, 魔方, 触点, 势能, 流量, 资源, 排期, 延期, 弹窗, 浮层, 引导, 蒙层, 幕帘, 遮罩, 埋点, 坑位, 楼层, 按钮, 推送, 红包, 峰值, 漏洞, 风险, 瓶颈, 策略, 价值, 成本, 复利, 人性, 利器, 深度, 玩家, 小白, 韭菜, 羊毛, 福利, 套路, 情怀, 标准, 规范, 报备, 社群, 产业, 载体, 服务, 粘性, 属性, 地域, 终端, 版本, 口碑, 指标, 年框, 试点, 母体, 空白, 银弹 三字词汇对一下, 碰一下, 过一下, 抢品类, 卡认知, 占场景, 观行业, 明竞争, 洞自身, 开场子, 提调子, 冷启动, 秀肌肉, 借东风, 断舍离, 薅羊毛, 砍一刀, 走出去, 讲故事, 扁平化, 差异化, 平台化, 结构化, 精细化, 短平快, 常态化, 强依赖, 不可控, 有风险, 感知度, 颗粒度, 方法论, 组合拳, 引爆点, 护城河, 影响力, 资源位, 优先级, 制高点, 可用性, 易用性, 稳定性, 便捷性, 耦合性, 一致性, 系统性, 端到端, 点对点, 点线面, 上半场, 下半场, 主战场, 人货场, 基本面, 基本盘, 操盘手, 进化论, 解释权, 最优解, 执行力, 驱动力, 鄙视链, 生态链, 生态圈, 生态位, 全场景, 全渠道, 全方位, 全媒体, 流量池, 天花板, 传话筒, 转化率, 活跃度, 颗粒感, 登云梯, 冲击力, 视觉锤, 孵化器, 新零售, 新物种, 新品牌, 新篇章, 新局势, 新赛道, 新势能, 新国货, 新国潮, 新动力, 同理心, 气氛组, 竞争力, 存在感, 认同感, 参与感, 归属感, 使命感, 价值观, 忠诚度, 预热期, 高峰期, 高潮期, 上升期, 瓶颈期, 大数据, 云计算, 区块链, 比特币, 虚拟币, 天使轮, 自媒体, 新媒体, 价格门, 超预期, 小前台, 大中台, 凝聚力, 向心力, 元无知, 软夺权 四字词汇支棱起来, 快速响应, 小步快跑, 价值转化, 强化认知, 资源置换, 资源倾斜, 资源配置, 完善逻辑, 去中心化, 渠道下沉, 用户下沉, 降维打击, 体验度量, 高频触达, 快速迭代, 持续迭代, 持续集成, 持续交付, 持续观察, 躬身入局, 顺势而为, 打破结界, 升维定位, 有机结合, 起承转合, 存量维持, 增量博弈, 心智角逐, 抽离透传, 拨冗参会, 反复确认, 综合评估, 刻意练习, 打破制约, 绝境求生, 品牌露出, 拥抱变化, 重新定义, 借势营销, 内容创业, 归因分析, 逻辑推理, 建立范式, 总结沉淀, 解决问题, 占领心智, 高举高打, 高开低走, 高台跳水, 深入产业, 拉齐水位, 全情投入, 如何收口, 全面封锁, 协同作战, 剑走偏锋, 弹射起飞, 结果导向, 业务导向, 资源紧张, 人力不足, 体感不好, 风险可控, 逻辑自洽, 品效合一, 全球领先, 人无我有, 人有我优, 人优我变, 势如破竹, 势不可挡, 石破天惊, 生命周期, 复用打法, 商业模式, 平台战略, 集团战略, 战略引擎, 关键路径, 决策路径, 天使投资, 盈利模式, 底层逻辑, 顶层设计, 饥饿营销, 行业壁垒, 下沉市场, 消费认知, 人工智能, 赛博朋克, 智慧城市, 解决方案, 知识付费, 私域流量, 交付价值, 时间价值, 共享经济, 通证经济, 中央厨房, 先发优势, 真实场景, 临门一脚, 真香定律, 正态分布, 幂律分布, 二八定律, 长尾理论, 叠加效应, 马太效应, 沉没成本, 边际成本, 机会成本, 偏好植入, 蚂蚁市场, 场景占位, 产业集群, 产业服务, 标杆市场, 心动情境, 利基市场, 第二曲线, 垂直领域, 可持续性, 可替代性, 认知优势, 新增长点, 颠覆态势, 最高规制, 三位一体, 资深玩家, 不破不立, 用户心智, 用户粘性, 用户体验, 用户认知, 用户画像, 用户调研, 重度用户, 沉默用户, 活跃用户, 用户黏性, 千人千面, 千人一面, 信息茧房, 流量红利, 流量为王, 价格歧视, 意识形态, 心理账户, 情绪G点, 品牌势能, 服务产业, 关键时期, 沟通协作, 战略合力, 品牌航母, 品类战舰, 行军路线, 产品尖兵, 拳头产品, 超级符号, 挽留弹窗, 时间窗口, 定性定量, 战略支点, 声音印记, 社交货币, 付费社群, 神交已久, 财务自由, 微粒社会, 增强回路, 认知折叠, 代偿效应, 隐性玩家, 知识盲维, 信用系数, 行动轴心, 故乡策略, 回到母体, 无边棋盘, 飞轮效应, 合成真实, 逆火效应, 打开率高, 留存率高, 活跃度高 五字词汇精神SPA, 大数据分析, 大数据杀熟, 延迟满足感, 地毯式轰炸, 饱和式攻击, 四两拨千斤, 开辟新路径, 建立新习惯, 用户无感知, 叫好又叫座, 优先级很高, 拉新成本高, 颠覆式创新, 连续创业者, 投入产出比, 互联网思维, 互联网红利, 国民总时间, 最后一公里, 海豚湾模式, 最大公约数, 现象级事件, 沉浸式体验, 用户忠诚度, 自媒体矩阵, 病毒式营销, 风口上的猪, 战略性投资, 战略性亏损, 系统性风险, 意义炼金术, 共识性发展, 横向标准化, 符号私有化, 非理性异动, 方言化认知 六字词汇all in, 不跟风要造风, 多维矩阵闭环, 打开销售通路, 向下传递寒气 总结国内互联网公司的黑话风气刮到北美之后，让我们这些常年身居海外的打工人感到十分的不适应。总的来说，一段由黑话组成的话看上去格调拉满，装b范十足，听下来基本没有什么有用信息在里面。给人一种假大空的感觉。可能说话的人确实想表达某种观点，甚至是计划，但过于包装和故弄玄虚的措辞很难让人把握重点。对于我这种普通打工仔，秉承着打不过就加入的原则，准备好好复习下黑话集锦，下次好忽悠人。","link":"/misc/misc-tech-slang/"},{"title":"Union Find Template","text":"A generic template. 1. IntroductionThe algorithm has two main functions: find: find a root parent given a node. union: merge a smaller set to a larger one if they are disjoint. 2. Template1234567891011121314151617181920212223242526272829303132333435363738template&lt;typename T&gt;class UnionFindSet {public: UnionFindSet(T n) { _parents = std::vector&lt;T&gt;(n, 0); _ranks = std::vector&lt;T&gt;(n, 0); for (size_t i = 0; i &lt; n; ++i) _parents[i] = i; } bool unite(T u, T v) { T pu = find(u); T pv = find(v); if (pu == pv) return false; if (_ranks[pu] &gt; _ranks[pv]) { _parents[pv] = pu; } else if (_ranks[pv] &gt; _ranks[pu]) { _parents[pu] = pv; } else { _parents[pu] = pv; ++_ranks[pv]; } return true; } int find(T id) { if (id != _parents[id]) _parents[id] = find(_parents[id]); return _parents[id]; } private: std::vector&lt;T&gt; _parents; std::vector&lt;T&gt; _ranks;};","link":"/interview/misc-union-find/"},{"title":"Andrej Karpathy LLM Tutorial","text":"Hands on LLM tutorial by Andrej Karpathy github: https://github.com/karpathy Incoming LLM101: https://github.com/karpathy/LLM101n Neural Networks: Zero to Hero https://karpathy.ai/zero-to-hero.html","link":"/resource/resource-karpathy-llm/"},{"title":"HDR to SDR Tutorial","text":"An awesome tutorial on the topic of converting HDR to SDR. Only in Chinese. https://juejin.cn/column/7206577654933471292 Chapter 1: OverviewChapter 2: 10-bit YUV textureChapter 3: YUV420 to YUVChapter 4: YUV to RGBChapter 5: BT2020 to BT709Chapter 6: Transfer Function and Color CorrectionChapter 7: Gamma, HLG, PQChapter 8: Tone MappingChapter 9: HDR Resources","link":"/resource/resource-hdr-to-sdr-tutorial/"},{"title":"Pacifica State Beach","text":"Pacifica State Beach is the southernmost of Pacifica, California’s large beaches. 搜停车场 Pacifica State Beach Parking Lot A 居然下午还是雾蒙蒙一片 没过一会儿雾更大了 海边有个往山上走的trail， Trail走到一半向下看去 向对面Rockaway Beach方向看去，居然看到了海上彩虹 等到从山上走下来，雾也都散干净了 借助iphone强大的camera及其算法加持，本人有幸抓拍到美照一张","link":"/life/pacifica-state-beach/"},{"title":"Smart pointer in C++","text":"shared_ptr, unique_ptr, weak_ptr Problems with regular pointers in C++ Memory Leak: memory is repearedly allocated on the heap but never gets de-allocated, which leads to excessive memory. Dangling pointer: The memory location where a pointer is pointing to is deleted. However, the pointer remains the same and is not set to be nullptr. shared_ptr 123456789101112131415161718192021222324void print_shared_ptr(const std::shared_ptr&lt;int&gt;&amp; sptr) { std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; *sptr &lt;&lt; std::endl; std::cout &lt;&lt; &quot;addr: &quot; &lt;&lt; sptr.get() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;count: &quot; &lt;&lt; sptr.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;is unique? : &quot; &lt;&lt; sptr.unique() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;---------------------\\n&quot;;}int main() { std::shared_ptr&lt;int&gt; sp = std::make_shared&lt;int&gt;(1); print_shared_ptr(sp); *sp = 2; print_shared_ptr(sp); // remove sp ownership sp.reset(); sp = std::make_shared&lt;int&gt;(3); print_shared_ptr(sp); // a new pointer points to the same memory std::shared_ptr&lt;int&gt; another_ptr = sp; print_shared_ptr(sp);} code output: 1234567891011121314151617181920value: 1addr: 0x603000000020count: 1is unique? : 1---------------------value: 2addr: 0x603000000020count: 1is unique? : 1---------------------value: 3addr: 0x603000000050count: 1is unique? : 1---------------------value: 3addr: 0x603000000050count: 2is unique? : 0--------------------- unique_ptrOnly one pointer is granted the ownership of one memory space. If the ownership needs to be changed，use std::move semantic to transfer the ownership. 1234567891011121314151617181920212223242526void print_unique_ptr(const std::unique_ptr&lt;int&gt;&amp; sptr) { std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; *sptr &lt;&lt; std::endl; std::cout &lt;&lt; &quot;addr: &quot; &lt;&lt; sptr.get() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;---------------------\\n&quot;;}int main() { std::unique_ptr&lt;int&gt; sp = std::make_unique&lt;int&gt;(1); print_unique_ptr(sp); *sp = 2; print_unique_ptr(sp); sp.reset(); sp = std::make_unique&lt;int&gt;(3); print_unique_ptr(sp); // a new pointer points to the same memory std::unique_ptr&lt;int&gt; another_ptr = std::move(sp); std::cout &lt;&lt; &quot;-----\\n&quot;; std::cout &lt;&lt; sp.get() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;-----\\n&quot;; print_unique_ptr(another_ptr);} code output 123456789101112131415value: 1addr: 0x602000000010---------------------value: 2addr: 0x602000000010---------------------value: 3addr: 0x602000000030--------------------------0-----value: 3addr: 0x602000000030--------------------- weak_ptrweak_ptr is similar to shared_ptr, except that it does not hold Reference Counter. 1234567891011121314151617181920212223class Rectangle { int width; int height; public: Rectangle(int w, int h) : width(w), height(h) {} int area() { return width * height; }}; int main() { shared_ptr&lt;Rectangle&gt; P1(new Rectangle(10, 5)); // create weak ptr weak_ptr&lt;Rectangle&gt; P2 (P1); // This'll print 50 cout &lt;&lt; P1-&gt;area() &lt;&lt; endl; // This'll print 1 as Reference Counter is 1 cout &lt;&lt; P1.use_count() &lt;&lt; endl; return 0;} code output: 12501","link":"/cpp/smartpointer/"},{"title":"HEIC to JPG","text":"A tool to convert HEIC format to JPG. HEIC to JPG ConverterThis tool allows you to convert multiple HEIC images to JPG format directly in your browser and download them as a ZIP file. .converter-container { max-width: 600px; margin: 2rem auto; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); background-color: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; } .options-container { margin-bottom: 1rem; padding: 1rem; background-color: #f8f9fa; border-radius: 6px; } .number-input { width: 100px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-left: 8px; } .input-group { display: flex; align-items: center; gap: 8px; } .file-input-container { display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem; } .custom-file-input { display: none; } .file-label { display: inline-block; padding: 12px 24px; background-color: #f0f0f0; color: #333; border-radius: 6px; cursor: pointer; transition: background-color 0.3s; text-align: center; border: 2px dashed #ccc; } .file-label:hover { background-color: #e0e0e0; } .convert-button { width: 100%; padding: 12px 24px; background-color: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; font-weight: 500; transition: background-color 0.3s; } .convert-button:hover { background-color: #45a049; } .convert-button:disabled { background-color: #cccccc; cursor: not-allowed; } .status { margin-top: 1rem; padding: 1rem; border-radius: 6px; background-color: #f8f9fa; min-height: 50px; } .selected-files { margin-top: 0.5rem; font-size: 0.9rem; color: #666; } .progress-bar { width: 100%; height: 4px; background-color: #f0f0f0; border-radius: 2px; margin-top: 1rem; overflow: hidden; } .progress-bar-fill { height: 100%; background-color: #4CAF50; width: 0%; transition: width 0.3s ease; } .drop-zone { border: 2px dashed #ccc; border-radius: 6px; padding: 20px; text-align: center; transition: border-color 0.3s; } .drop-zone.dragover { border-color: #4CAF50; background-color: rgba(76, 175, 80, 0.1); } Start numbering from: Drop HEIC files here or click to select Convert to JPG and Download ZIP const dropZone = document.getElementById('dropZone'); const fileInput = document.getElementById('fileInput'); const selectedFiles = document.getElementById('selectedFiles'); const convertButton = document.getElementById('convertButton'); const statusDiv = document.getElementById('status'); const progressBar = document.getElementById('progressBar'); // Drag and drop handlers dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); }); dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('dragover'); }); dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); const files = e.dataTransfer.files; fileInput.files = files; updateFileSelection(files); }); fileInput.addEventListener('change', (e) => { updateFileSelection(e.target.files); }); function updateFileSelection(files) { if (files.length > 0) { selectedFiles.textContent = `Selected ${files.length} file(s): ${Array.from(files).map(f => f.name).join(', ')}`; convertButton.disabled = false; } else { selectedFiles.textContent = ''; convertButton.disabled = true; } } async function convertFiles() { const files = fileInput.files; const zip = new JSZip(); const startIndex = parseInt(document.getElementById('startIndex').value) || 1; if (files.length === 0) { alert('Please select HEIC files to convert'); return; } convertButton.disabled = true; statusDiv.textContent = 'Converting files...'; progressBar.style.width = '0%'; try { for (let i = 0; i < files.length; i++) { const file = files[i]; try { statusDiv.textContent = `Converting ${file.name} (${i + 1}/${files.length})...`; progressBar.style.width = `${(i / files.length) * 100}%`; const jpegBlob = await heic2any({ blob: file, toType: \"image/jpeg\", quality: 0.8 }); // Use the starting index to name files const currentIndex = startIndex + i; const jpegFilename = `${currentIndex}.jpg`; zip.file(jpegFilename, jpegBlob); } catch (error) { console.error(`Error converting ${file.name}:`, error); statusDiv.textContent += `\\nFailed to convert ${file.name}`; } } statusDiv.textContent = 'Creating ZIP file...'; progressBar.style.width = '90%'; const zipBlob = await zip.generateAsync({type: 'blob'}); const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); const downloadLink = document.createElement('a'); downloadLink.href = URL.createObjectURL(zipBlob); downloadLink.download = `converted_images_${timestamp}.zip`; document.body.appendChild(downloadLink); downloadLink.click(); document.body.removeChild(downloadLink); URL.revokeObjectURL(downloadLink.href); progressBar.style.width = '100%'; statusDiv.textContent = '✅ Conversion complete! ZIP file downloaded.'; } catch (error) { console.error('Error creating ZIP:', error); statusDiv.textContent = '❌ Error creating ZIP file'; } finally { convertButton.disabled = false; setTimeout(() => { progressBar.style.width = '0%'; }, 2000); } } Features Drag and drop HEIC files or use file selector Convert multiple files at once Progress tracking for conversion Automatic ZIP file download Clean, modern interface Sequential naming of converted files (0.jpg, 1.jpg, etc.) Notes The conversion is done entirely in the browser - no files are uploaded to any server The quality of the output JPG is set to 0.8 (80%) by default Original HEIC files are not modified or deleted The ZIP file name includes a timestamp to prevent overwriting Converted images are named sequentially starting from 0.jpg","link":"/tool/tool-heci-to-jpg/"},{"title":"Photo Editor","text":"A web-based photo editor. Suppport adding text, rectangle and arrow. Web-based Image EditorThis is a simple web-based image editor that allows you to: Add text with adjustable color and size Add rectangles with adjustable color and size Add arrows with adjustable color and size Upload Text Rectangle Arrow Delete Download Color: Size: #editor-container { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; max-width: 850px; margin: 0 auto; } .button-group { display: flex; flex-wrap: wrap; gap: 8px; } .ios-btn { background-color: #ffffff; border: none; color: #007aff; padding: 8px 12px; text-align: center; text-decoration: none; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 500; margin: 0; cursor: pointer; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); transition: all 0.2s ease; min-width: 80px; flex-direction: column; gap: 5px; } .ios-btn svg { margin-bottom: 2px; } .ios-btn:hover { background-color: #f0f0f0; } .ios-btn.active { background-color: #e6f2ff; box-shadow: 0 0 0 2px #007aff40; } .ios-btn-primary { background-color: #007aff; color: white; } .ios-btn-primary:hover { background-color: #0069d9; } .ios-btn-danger { color: #ff3b30; } .ios-btn-danger:hover { background-color: #fff0f0; } #canvas-container { background-color: #f8f8f8; overflow: hidden; } #main-canvas { background-color: white; } /* Custom range slider styling */ input[type=range] { -webkit-appearance: none; height: 6px; background: #e0e0e0; border-radius: 3px; outline: none; } input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #007aff; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); } input[type=range]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #007aff; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); border: none; } document.addEventListener('DOMContentLoaded', function() { const canvas = document.getElementById('main-canvas'); const ctx = canvas.getContext('2d'); const uploadBtn = document.getElementById('upload-btn'); const uploadInput = document.getElementById('upload-input'); const textBtn = document.getElementById('text-btn'); const rectBtn = document.getElementById('rect-btn'); const arrowBtn = document.getElementById('arrow-btn'); const deleteBtn = document.getElementById('delete-btn'); const downloadBtn = document.getElementById('download-btn'); const colorPicker = document.getElementById('color-picker'); const sizeSlider = document.getElementById('size-slider'); // Update color preview when color changes colorPicker.addEventListener('input', function() { this.parentElement.style.backgroundColor = this.value; }); // Set initial color colorPicker.parentElement.style.backgroundColor = colorPicker.value; let backgroundImage = null; let objects = []; let selectedObject = null; let isDragging = false; let isResizing = false; let resizeHandle = null; let startX, startY; let currentTool = null; let isDrawing = false; let tempObject = null; const handleSize = 8; // Size of resize handles // Initialize canvas with white background ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height); // Function to reset tool buttons visual state function resetToolButtons() { textBtn.classList.remove('active'); rectBtn.classList.remove('active'); arrowBtn.classList.remove('active'); currentTool = null; } // Upload image functionality uploadBtn.addEventListener('click', function() { uploadInput.click(); }); uploadInput.addEventListener('change', function(e) { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = function(event) { const img = new Image(); img.onload = function() { // Resize canvas to fit image const aspectRatio = img.width / img.height; if (img.width > 800) { canvas.width = 800; canvas.height = 800 / aspectRatio; } else if (img.height > 600) { canvas.height = 600; canvas.width = 600 * aspectRatio; } else { canvas.width = img.width; canvas.height = img.height; } backgroundImage = img; redraw(); }; img.src = event.target.result; }; reader.readAsDataURL(file); } }); // Tool selection textBtn.addEventListener('click', function() { resetToolButtons(); currentTool = 'text'; textBtn.classList.add('active'); }); rectBtn.addEventListener('click', function() { resetToolButtons(); currentTool = 'rect'; rectBtn.classList.add('active'); }); arrowBtn.addEventListener('click', function() { resetToolButtons(); currentTool = 'arrow'; arrowBtn.classList.add('active'); }); deleteBtn.addEventListener('click', function() { if (selectedObject) { const index = objects.indexOf(selectedObject); if (index > -1) { objects.splice(index, 1); selectedObject = null; redraw(); } } }); downloadBtn.addEventListener('click', function() { // Temporarily remove selection highlight const tempSelected = selectedObject; selectedObject = null; redraw(); // Create download link const link = document.createElement('a'); link.download = 'edited-image.png'; link.href = canvas.toDataURL('image/png'); link.click(); // Restore selection selectedObject = tempSelected; redraw(); }); // Get resize handles for an object function getResizeHandles(obj) { const handles = []; if (obj.type === 'text') { const width = obj.width || ctx.measureText(obj.text).width; const height = obj.height || obj.size; // Bottom right corner handles.push({ x: obj.x + width, y: obj.y + height, cursor: 'nwse-resize', action: function(dx, dy) { obj.size = Math.max(10, obj.size + dy / 2); obj.width = Math.max(20, width + dx); obj.height = Math.max(10, height + dy); } }); } else if (obj.type === 'rect') { // Bottom right corner handles.push({ x: obj.x + obj.width, y: obj.y + obj.height, cursor: 'nwse-resize', action: function(dx, dy) { obj.width = Math.max(10, obj.width + dx); obj.height = Math.max(10, obj.height + dy); } }); } else if (obj.type === 'arrow') { // End point of arrow handles.push({ x: obj.x2, y: obj.y2, cursor: 'move', action: function(dx, dy) { obj.x2 += dx; obj.y2 += dy; } }); // Start point of arrow handles.push({ x: obj.x1, y: obj.y1, cursor: 'move', action: function(dx, dy) { obj.x1 += dx; obj.y1 += dy; } }); // Size handle (middle of arrow) const midX = (obj.x1 + obj.x2) / 2; const midY = (obj.y1 + obj.y2) / 2; handles.push({ x: midX, y: midY, cursor: 'pointer', action: function(dx, dy) { // Adjust thickness obj.size = Math.max(1, obj.size + dy / 10); } }); } return handles; } // Check if point is on a resize handle function getHandleAtPoint(x, y) { if (!selectedObject) return null; const handles = getResizeHandles(selectedObject); for (let i = 0; i < handles.length; i++) { const handle = handles[i]; const dx = handle.x - x; const dy = handle.y - y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance = 0; i--) { if (isPointInObject(x, y, objects[i])) { selectedObject = objects[i]; isDragging = true; startX = x; startY = y; redraw(); return; } } // If not clicking on an object and a tool is selected, start drawing if (currentTool) { isDrawing = true; startX = x; startY = y; if (currentTool === 'text') { const text = prompt('Enter text:', 'Sample Text'); if (text) { ctx.font = `${parseInt(sizeSlider.value)}px Arial`; const textWidth = ctx.measureText(text).width; const newText = { type: 'text', x: x, y: y, text: text, color: colorPicker.value, size: parseInt(sizeSlider.value), width: textWidth, height: parseInt(sizeSlider.value) }; objects.push(newText); selectedObject = newText; redraw(); } isDrawing = false; resetToolButtons(); // Reset after adding text } else if (currentTool === 'rect') { tempObject = { type: 'rect', x: x, y: y, width: 0, height: 0, color: colorPicker.value, size: parseInt(sizeSlider.value) }; } else if (currentTool === 'arrow') { tempObject = { type: 'arrow', x1: x, y1: y, x2: x, y2: y, color: colorPicker.value, size: parseInt(sizeSlider.value) }; } } else { // Deselect if clicking on empty space selectedObject = null; redraw(); } }); canvas.addEventListener('mousemove', function(e) { const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top; // Update cursor based on what's under it const handle = getHandleAtPoint(x, y); if (handle) { canvas.style.cursor = handle.cursor; } else if (isPointInAnyObject(x, y)) { canvas.style.cursor = 'move'; } else { canvas.style.cursor = 'default'; } if (isResizing && resizeHandle) { const dx = x - startX; const dy = y - startY; resizeHandle.action(dx, dy); startX = x; startY = y; redraw(); } else if (isDragging && selectedObject) { const dx = x - startX; const dy = y - startY; if (selectedObject.type === 'text' || selectedObject.type === 'rect') { selectedObject.x += dx; selectedObject.y += dy; } else if (selectedObject.type === 'arrow') { selectedObject.x1 += dx; selectedObject.y1 += dy; selectedObject.x2 += dx; selectedObject.y2 += dy; } startX = x; startY = y; redraw(); } else if (isDrawing && tempObject) { if (tempObject.type === 'rect') { tempObject.width = x - tempObject.x; tempObject.height = y - tempObject.y; } else if (tempObject.type === 'arrow') { tempObject.x2 = x; tempObject.y2 = y; } redraw(); drawTempObject(); } }); canvas.addEventListener('mouseup', function() { if (isDrawing && tempObject) { if (tempObject.type === 'rect' || tempObject.type === 'arrow') { objects.push(tempObject); selectedObject = tempObject; resetToolButtons(); // Reset tool after completing drawing } tempObject = null; } isDragging = false; isResizing = false; resizeHandle = null; isDrawing = false; redraw(); }); // Helper functions function isPointInObject(x, y, obj) { if (obj.type === 'text' || obj.type === 'rect') { return x >= obj.x && x = obj.y && y","link":"/tool/tool-photo-editor/"},{"title":"Spanish Vocabulary Trainer","text":"Online Spanish vocabulary trainer. Covers 1000 basic words. .vocab-app { font-family: -apple-system, system-ui, sans-serif; max-width: 600px; margin: 20px auto; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } .vocab-app .word-display { text-align: center; margin: 20px 0; min-height: 120px; } .vocab-app .spanish-word { font-size: 2.5em; font-weight: bold; margin: 10px 0; } .vocab-app .english-word { font-size: 1.8em; color: #666; margin: 10px 0; } .vocab-app .button-container { display: flex; justify-content: center; gap: 10px; margin: 20px 0; } .vocab-app button { background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 1em; transition: all 0.2s ease; } .vocab-app button:hover { background-color: #0056b3; } .vocab-app button.outline { background-color: transparent; border: 1px solid #007bff; color: #007bff; } .vocab-app .progress { text-align: center; /* Changed from right to center */ font-size: 0.9em; color: #666; margin: 20px 0 10px 0; /* Added more margin */ padding: 0 10px; /* Added padding */ min-height: 20px; /* Added minimum height */ } Spanish Vocabulary Trainer Show Translation Next Word (function() { const vocabulary = [ { \"spanish\": \"como\", \"english\": \"as\" }, { \"spanish\": \"yo\", \"english\": \"I\" }, { \"spanish\": \"su\", \"english\": \"his\" }, { \"spanish\": \"que\", \"english\": \"that\" }, { \"spanish\": \"él\", \"english\": \"he\" }, { \"spanish\": \"era\", \"english\": \"was\" }, { \"spanish\": \"para\", \"english\": \"for\" }, { \"spanish\": \"en\", \"english\": \"on\" }, { \"spanish\": \"son\", \"english\": \"are\" }, { \"spanish\": \"con\", \"english\": \"with\" }, { \"spanish\": \"ellos\", \"english\": \"they\" }, { \"spanish\": \"ser\", \"english\": \"be\" }, { \"spanish\": \"en\", \"english\": \"at\" }, { \"spanish\": \"uno\", \"english\": \"one\" }, { \"spanish\": \"tener\", \"english\": \"have\" }, { \"spanish\": \"este\", \"english\": \"this\" }, { \"spanish\": \"desde\", \"english\": \"from\" }, { \"spanish\": \"por\", \"english\": \"by\" }, { \"spanish\": \"caliente\", \"english\": \"hot\" }, { \"spanish\": \"palabra\", \"english\": \"word\" }, { \"spanish\": \"pero\", \"english\": \"but\" }, { \"spanish\": \"qué\", \"english\": \"what\" }, { \"spanish\": \"algunos\", \"english\": \"some\" }, { \"spanish\": \"es\", \"english\": \"is\" }, { \"spanish\": \"lo\", \"english\": \"it\" }, { \"spanish\": \"usted\", \"english\": \"you\" }, { \"spanish\": \"o\", \"english\": \"or\" }, { \"spanish\": \"tenido\", \"english\": \"had\" }, { \"spanish\": \"la\", \"english\": \"the\" }, { \"spanish\": \"de\", \"english\": \"of\" }, { \"spanish\": \"a\", \"english\": \"to\" }, { \"spanish\": \"y\", \"english\": \"and\" }, { \"spanish\": \"un\", \"english\": \"a\" }, { \"spanish\": \"en\", \"english\": \"in\" }, { \"spanish\": \"nos\", \"english\": \"we\" }, { \"spanish\": \"lata\", \"english\": \"can\" }, { \"spanish\": \"fuera\", \"english\": \"out\" }, { \"spanish\": \"otros\", \"english\": \"other\" }, { \"spanish\": \"eran\", \"english\": \"were\" }, { \"spanish\": \"que\", \"english\": \"which\" }, { \"spanish\": \"hacer\", \"english\": \"do\" }, { \"spanish\": \"su\", \"english\": \"their\" }, { \"spanish\": \"tiempo\", \"english\": \"time\" }, { \"spanish\": \"si\", \"english\": \"if\" }, { \"spanish\": \"lo hará\", \"english\": \"will\" }, { \"spanish\": \"cómo\", \"english\": \"how\" }, { \"spanish\": \"dicho\", \"english\": \"said\" }, { \"spanish\": \"un\", \"english\": \"an\" }, { \"spanish\": \"cada\", \"english\": \"each\" }, { \"spanish\": \"decir\", \"english\": \"tell\" }, { \"spanish\": \"hace\", \"english\": \"does\" }, { \"spanish\": \"conjunto\", \"english\": \"set\" }, { \"spanish\": \"tres\", \"english\": \"three\" }, { \"spanish\": \"querer\", \"english\": \"want\" }, { \"spanish\": \"aire\", \"english\": \"air\" }, { \"spanish\": \"así\", \"english\": \"well\" }, { \"spanish\": \"también\", \"english\": \"also\" }, { \"spanish\": \"jugar\", \"english\": \"play\" }, { \"spanish\": \"pequeño\", \"english\": \"small\" }, { \"spanish\": \"fin\", \"english\": \"end\" }, { \"spanish\": \"poner\", \"english\": \"put\" }, { \"spanish\": \"casa\", \"english\": \"home\" }, { \"spanish\": \"leer\", \"english\": \"read\" }, { \"spanish\": \"mano\", \"english\": \"hand\" }, { \"spanish\": \"puerto\", \"english\": \"port\" }, { \"spanish\": \"grande\", \"english\": \"large\" }, { \"spanish\": \"deletrear\", \"english\": \"spell\" }, { \"spanish\": \"añadir\", \"english\": \"add\" }, { \"spanish\": \"incluso\", \"english\": \"even\" }, { \"spanish\": \"tierra\", \"english\": \"land\" }, { \"spanish\": \"aquí\", \"english\": \"here\" }, { \"spanish\": \"debe\", \"english\": \"must\" }, { \"spanish\": \"grande\", \"english\": \"big\" }, { \"spanish\": \"alto\", \"english\": \"high\" }, { \"spanish\": \"tal\", \"english\": \"such\" }, { \"spanish\": \"siga\", \"english\": \"follow\" }, { \"spanish\": \"acto\", \"english\": \"act\" }, { \"spanish\": \"por qué\", \"english\": \"why\" }, { \"spanish\": \"preguntar\", \"english\": \"ask\" }, { \"spanish\": \"hombres\", \"english\": \"men\" }, { \"spanish\": \"cambio\", \"english\": \"change\" }, { \"spanish\": \"se fue\", \"english\": \"went\" }, { \"spanish\": \"luz\", \"english\": \"light\" }, { \"spanish\": \"tipo\", \"english\": \"kind\" }, { \"spanish\": \"fuera\", \"english\": \"off\" }, { \"spanish\": \"necesitará\", \"english\": \"need\" }, { \"spanish\": \"casa\", \"english\": \"house\" }, { \"spanish\": \"imagen\", \"english\": \"picture\" }, { \"spanish\": \"tratar\", \"english\": \"try\" }, { \"spanish\": \"nosotros\", \"english\": \"us\" }, { \"spanish\": \"de nuevo\", \"english\": \"again\" }, { \"spanish\": \"animal\", \"english\": \"animal\" }, { \"spanish\": \"punto\", \"english\": \"point\" }, { \"spanish\": \"madre\", \"english\": \"mother\" }, { \"spanish\": \"mundo\", \"english\": \"world\" }, { \"spanish\": \"cerca\", \"english\": \"near\" }, { \"spanish\": \"construir\", \"english\": \"build\" }, { \"spanish\": \"auto\", \"english\": \"self\" }, { \"spanish\": \"tierra\", \"english\": \"earth\" }, { \"spanish\": \"padre\", \"english\": \"father\" }, { \"spanish\": \"cualquier\", \"english\": \"any\" }, { \"spanish\": \"nuevo\", \"english\": \"new\" }, { \"spanish\": \"trabajo\", \"english\": \"work\" }, { \"spanish\": \"parte\", \"english\": \"part\" }, { \"spanish\": \"tomar\", \"english\": \"take\" }, { \"spanish\": \"conseguir\", \"english\": \"get\" }, { \"spanish\": \"lugar\", \"english\": \"place\" }, { \"spanish\": \"hecho\", \"english\": \"made\" }, { \"spanish\": \"vivir\", \"english\": \"live\" }, { \"spanish\": \"donde\", \"english\": \"where\" }, { \"spanish\": \"después\", \"english\": \"after\" }, { \"spanish\": \"espalda\", \"english\": \"back\" }, { \"spanish\": \"poco\", \"english\": \"little\" }, { \"spanish\": \"sólo\", \"english\": \"only\" }, { \"spanish\": \"ronda\", \"english\": \"round\" }, { \"spanish\": \"hombre\", \"english\": \"man\" }, { \"spanish\": \"años\", \"english\": \"year\" }, { \"spanish\": \"vino\", \"english\": \"came\" }, { \"spanish\": \"show\", \"english\": \"show\" }, { \"spanish\": \"cada\", \"english\": \"every\" }, { \"spanish\": \"buena\", \"english\": \"good\" }, { \"spanish\": \"me\", \"english\": \"me\" }, { \"spanish\": \"dar\", \"english\": \"give\" }, { \"spanish\": \"nuestro\", \"english\": \"our\" }, { \"spanish\": \"bajo\", \"english\": \"under\" }, { \"spanish\": \"nombre\", \"english\": \"name\" }, { \"spanish\": \"muy\", \"english\": \"very\" }, { \"spanish\": \"a través de\", \"english\": \"through\" }, { \"spanish\": \"sólo\", \"english\": \"just\" }, { \"spanish\": \"forma\", \"english\": \"form\" }, { \"spanish\": \"frase\", \"english\": \"sentence\" }, { \"spanish\": \"gran\", \"english\": \"great\" }, { \"spanish\": \"pensar\", \"english\": \"think\" }, { \"spanish\": \"decir\", \"english\": \"say\" }, { \"spanish\": \"ayudar\", \"english\": \"help\" }, { \"spanish\": \"bajo\", \"english\": \"low\" }, { \"spanish\": \"línea\", \"english\": \"line\" }, { \"spanish\": \"ser distinto\", \"english\": \"differ\" }, { \"spanish\": \"a su vez,\", \"english\": \"turn\" }, { \"spanish\": \"causa\", \"english\": \"cause\" }, { \"spanish\": \"mucho\", \"english\": \"much\" }, { \"spanish\": \"significará\", \"english\": \"mean\" }, { \"spanish\": \"antes\", \"english\": \"before\" }, { \"spanish\": \"movimiento\", \"english\": \"move\" }, { \"spanish\": \"derecho\", \"english\": \"right\" }, { \"spanish\": \"niño\", \"english\": \"boy\" }, { \"spanish\": \"viejo\", \"english\": \"old\" }, { \"spanish\": \"demasiado\", \"english\": \"too\" }, { \"spanish\": \"misma\", \"english\": \"same\" }, { \"spanish\": \"ella\", \"english\": \"she\" }, { \"spanish\": \"todo\", \"english\": \"all\" }, { \"spanish\": \"hay\", \"english\": \"there\" }, { \"spanish\": \"cuando\", \"english\": \"when\" }, { \"spanish\": \"hasta\", \"english\": \"up\" }, { \"spanish\": \"uso\", \"english\": \"use\" }, { \"spanish\": \"su\", \"english\": \"your\" }, { \"spanish\": \"camino\", \"english\": \"way\" }, { \"spanish\": \"acerca\", \"english\": \"about\" }, { \"spanish\": \"muchos\", \"english\": \"many\" }, { \"spanish\": \"entonces\", \"english\": \"then\" }, { \"spanish\": \"ellos\", \"english\": \"them\" }, { \"spanish\": \"escribir\", \"english\": \"write\" }, { \"spanish\": \"haría\", \"english\": \"would\" }, { \"spanish\": \"como\", \"english\": \"like\" }, { \"spanish\": \"así\", \"english\": \"so\" }, { \"spanish\": \"éstos\", \"english\": \"these\" }, { \"spanish\": \"su\", \"english\": \"her\" }, { \"spanish\": \"largo\", \"english\": \"long\" }, { \"spanish\": \"hacer\", \"english\": \"make\" }, { \"spanish\": \"cosa\", \"english\": \"thing\" }, { \"spanish\": \"ver\", \"english\": \"see\" }, { \"spanish\": \"él\", \"english\": \"him\" }, { \"spanish\": \"dos\", \"english\": \"two\" }, { \"spanish\": \"tiene\", \"english\": \"has\" }, { \"spanish\": \"buscar\", \"english\": \"look\" }, { \"spanish\": \"más\", \"english\": \"more\" }, { \"spanish\": \"día\", \"english\": \"day\" }, { \"spanish\": \"podía\", \"english\": \"could\" }, { \"spanish\": \"ir\", \"english\": \"go\" }, { \"spanish\": \"venir\", \"english\": \"come\" }, { \"spanish\": \"hizo\", \"english\": \"did\" }, { \"spanish\": \"número\", \"english\": \"number\" }, { \"spanish\": \"sonar\", \"english\": \"sound\" }, { \"spanish\": \"no\", \"english\": \"no\" }, { \"spanish\": \"más\", \"english\": \"most\" }, { \"spanish\": \"personas\", \"english\": \"people\" }, { \"spanish\": \"mi\", \"english\": \"my\" }, { \"spanish\": \"sobre\", \"english\": \"over\" }, { \"spanish\": \"saber\", \"english\": \"know\" }, { \"spanish\": \"agua\", \"english\": \"water\" }, { \"spanish\": \"que\", \"english\": \"than\" }, { \"spanish\": \"llamada\", \"english\": \"call\" }, { \"spanish\": \"primero\", \"english\": \"first\" }, { \"spanish\": \"que\", \"english\": \"who\" }, { \"spanish\": \"puede\", \"english\": \"may\" }, { \"spanish\": \"abajo\", \"english\": \"down\" }, { \"spanish\": \"lado\", \"english\": \"side\" }, { \"spanish\": \"estado\", \"english\": \"been\" }, { \"spanish\": \"ahora\", \"english\": \"now\" }, { \"spanish\": \"encontrar\", \"english\": \"find\" }, { \"spanish\": \"cabeza\", \"english\": \"head\" }, { \"spanish\": \"de pie\", \"english\": \"stand\" }, { \"spanish\": \"propio\", \"english\": \"own\" }, { \"spanish\": \"página\", \"english\": \"page\" }, { \"spanish\": \"debería\", \"english\": \"should\" }, { \"spanish\": \"país\", \"english\": \"country\" }, { \"spanish\": \"encontrado\", \"english\": \"found\" }, { \"spanish\": \"respuesta\", \"english\": \"answer\" }, { \"spanish\": \"escuela\", \"english\": \"school\" }, { \"spanish\": \"crecer\", \"english\": \"grow\" }, { \"spanish\": \"estudio\", \"english\": \"study\" }, { \"spanish\": \"todavía\", \"english\": \"still\" }, { \"spanish\": \"aprender\", \"english\": \"learn\" }, { \"spanish\": \"planta\", \"english\": \"plant\" }, { \"spanish\": \"cubierta\", \"english\": \"cover\" }, { \"spanish\": \"alimentos\", \"english\": \"food\" }, { \"spanish\": \"sol\", \"english\": \"sun\" }, { \"spanish\": \"cuatro\", \"english\": \"four\" }, { \"spanish\": \"entre\", \"english\": \"between\" }, { \"spanish\": \"estado\", \"english\": \"state\" }, { \"spanish\": \"mantener\", \"english\": \"keep\" }, { \"spanish\": \"ojo\", \"english\": \"eye\" }, { \"spanish\": \"nunca\", \"english\": \"never\" }, { \"spanish\": \"último\", \"english\": \"last\" }, { \"spanish\": \"dejar\", \"english\": \"let\" }, { \"spanish\": \"pensado\", \"english\": \"thought\" }, { \"spanish\": \"ciudad\", \"english\": \"city\" }, { \"spanish\": \"árbol\", \"english\": \"tree\" }, { \"spanish\": \"cruzar\", \"english\": \"cross\" }, { \"spanish\": \"granja\", \"english\": \"farm\" }, { \"spanish\": \"duro\", \"english\": \"hard\" }, { \"spanish\": \"inicio\", \"english\": \"start\" }, { \"spanish\": \"podría\", \"english\": \"might\" }, { \"spanish\": \"historia\", \"english\": \"story\" }, { \"spanish\": \"sierra\", \"english\": \"saw\" }, { \"spanish\": \"ahora\", \"english\": \"far\" }, { \"spanish\": \"mar\", \"english\": \"sea\" }, { \"spanish\": \"dibujar\", \"english\": \"draw\" }, { \"spanish\": \"izquierda\", \"english\": \"left\" }, { \"spanish\": \"tarde\", \"english\": \"late\" }, { \"spanish\": \"ejecutar\", \"english\": \"run\" }, { \"spanish\": \"no\", \"english\": \"don’t\" }, { \"spanish\": \"mientras\", \"english\": \"while\" }, { \"spanish\": \"prensa\", \"english\": \"press\" }, { \"spanish\": \"Cerrar\", \"english\": \"close\" }, { \"spanish\": \"noche\", \"english\": \"night\" }, { \"spanish\": \"reales\", \"english\": \"real\" }, { \"spanish\": \"vida\", \"english\": \"life\" }, { \"spanish\": \"pocos\", \"english\": \"few\" }, { \"spanish\": \"norte\", \"english\": \"north\" }, { \"spanish\": \"libro\", \"english\": \"book\" }, { \"spanish\": \"llevar\", \"english\": \"carry\" }, { \"spanish\": \"tomó\", \"english\": \"took\" }, { \"spanish\": \"ciencia\", \"english\": \"science\" }, { \"spanish\": \"comer\", \"english\": \"eat\" }, { \"spanish\": \"habitación\", \"english\": \"room\" }, { \"spanish\": \"amigo\", \"english\": \"friend\" }, { \"spanish\": \"comenzó\", \"english\": \"began\" }, { \"spanish\": \"gusta\", \"english\": \"idea\" }, { \"spanish\": \"peces\", \"english\": \"fish\" }, { \"spanish\": \"montaña\", \"english\": \"mountain\" }, { \"spanish\": \"Deténgase\", \"english\": \"stop\" }, { \"spanish\": \"una vez\", \"english\": \"once\" }, { \"spanish\": \"base de\", \"english\": \"base\" }, { \"spanish\": \"escuchar\", \"english\": \"hear\" }, { \"spanish\": \"caballo\", \"english\": \"horse\" }, { \"spanish\": \"cortada\", \"english\": \"cut\" }, { \"spanish\": \"seguro\", \"english\": \"sure\" }, { \"spanish\": \"ver\", \"english\": \"watch\" }, { \"spanish\": \"colores\", \"english\": \"color\" }, { \"spanish\": \"cara\", \"english\": \"face\" }, { \"spanish\": \"madera\", \"english\": \"wood\" }, { \"spanish\": \"principal\", \"english\": \"main\" }, { \"spanish\": \"abierta\", \"english\": \"open\" }, { \"spanish\": \"parecer\", \"english\": \"seem\" }, { \"spanish\": \"juntos\", \"english\": \"together\" }, { \"spanish\": \"próximo\", \"english\": \"next\" }, { \"spanish\": \"blanco\", \"english\": \"white\" }, { \"spanish\": \"niños\", \"english\": \"children\" }, { \"spanish\": \"comenzar\", \"english\": \"begin\" }, { \"spanish\": \"conseguido\", \"english\": \"got\" }, { \"spanish\": \"caminar\", \"english\": \"walk\" }, { \"spanish\": \"ejemplo\", \"english\": \"example\" }, { \"spanish\": \"aliviar\", \"english\": \"ease\" }, { \"spanish\": \"papel\", \"english\": \"paper\" }, { \"spanish\": \"grupo\", \"english\": \"group\" }, { \"spanish\": \"siempre\", \"english\": \"always\" }, { \"spanish\": \"música\", \"english\": \"music\" }, { \"spanish\": \"los\", \"english\": \"those\" }, { \"spanish\": \"ambos\", \"english\": \"both\" }, { \"spanish\": \"marca\", \"english\": \"mark\" }, { \"spanish\": \"menudo\", \"english\": \"often\" }, { \"spanish\": \"carta\", \"english\": \"letter\" }, { \"spanish\": \"hasta\", \"english\": \"until\" }, { \"spanish\": \"milla\", \"english\": \"mile\" }, { \"spanish\": \"río\", \"english\": \"river\" }, { \"spanish\": \"coche\", \"english\": \"car\" }, { \"spanish\": \"pies\", \"english\": \"feet\" }, { \"spanish\": \"cuidado\", \"english\": \"care\" }, { \"spanish\": \"segundo\", \"english\": \"second\" }, { \"spanish\": \"suficiente\", \"english\": \"enough\" }, { \"spanish\": \"llano\", \"english\": \"plain\" }, { \"spanish\": \"chica\", \"english\": \"girl\" }, { \"spanish\": \"habitual\", \"english\": \"usual\" }, { \"spanish\": \"joven\", \"english\": \"young\" }, { \"spanish\": \"listo\", \"english\": \"ready\" }, { \"spanish\": \"por encima de\", \"english\": \"above\" }, { \"spanish\": \"nunca\", \"english\": \"ever\" }, { \"spanish\": \"rojo\", \"english\": \"red\" }, { \"spanish\": \"lista\", \"english\": \"list\" }, { \"spanish\": \"aunque\", \"english\": \"though\" }, { \"spanish\": \"sentir\", \"english\": \"feel\" }, { \"spanish\": \"charla\", \"english\": \"talk\" }, { \"spanish\": \"pájaro\", \"english\": \"bird\" }, { \"spanish\": \"pronto\", \"english\": \"soon\" }, { \"spanish\": \"cuerpo\", \"english\": \"body\" }, { \"spanish\": \"perro\", \"english\": \"dog\" }, { \"spanish\": \"familia\", \"english\": \"family\" }, { \"spanish\": \"directa\", \"english\": \"direct\" }, { \"spanish\": \"plantear\", \"english\": \"pose\" }, { \"spanish\": \"dejar\", \"english\": \"leave\" }, { \"spanish\": \"canción\", \"english\": \"song\" }, { \"spanish\": \"medir\", \"english\": \"measure\" }, { \"spanish\": \"puerta\", \"english\": \"door\" }, { \"spanish\": \"producto\", \"english\": \"product\" }, { \"spanish\": \"negro\", \"english\": \"black\" }, { \"spanish\": \"corto\", \"english\": \"short\" }, { \"spanish\": \"numeral\", \"english\": \"numeral\" }, { \"spanish\": \"clase\", \"english\": \"class\" }, { \"spanish\": \"viento\", \"english\": \"wind\" }, { \"spanish\": \"pregunta\", \"english\": \"question\" }, { \"spanish\": \"suceder\", \"english\": \"happen\" }, { \"spanish\": \"completo\", \"english\": \"complete\" }, { \"spanish\": \"buque\", \"english\": \"ship\" }, { \"spanish\": \"zona\", \"english\": \"area\" }, { \"spanish\": \"medio\", \"english\": \"half\" }, { \"spanish\": \"roca\", \"english\": \"rock\" }, { \"spanish\": \"orden\", \"english\": \"order\" }, { \"spanish\": \"fuego\", \"english\": \"fire\" }, { \"spanish\": \"sur\", \"english\": \"south\" }, { \"spanish\": \"problema\", \"english\": \"problem\" }, { \"spanish\": \"pieza\", \"english\": \"piece\" }, { \"spanish\": \"dicho\", \"english\": \"told\" }, { \"spanish\": \"sabía\", \"english\": \"knew\" }, { \"spanish\": \"pasar\", \"english\": \"pass\" }, { \"spanish\": \"desde\", \"english\": \"since\" }, { \"spanish\": \"cima\", \"english\": \"top\" }, { \"spanish\": \"todo\", \"english\": \"whole\" }, { \"spanish\": \"rey\", \"english\": \"king\" }, { \"spanish\": \"calle\", \"english\": \"street\" }, { \"spanish\": \"pulgadas\", \"english\": \"inch\" }, { \"spanish\": \"multiplicar\", \"english\": \"multiply\" }, { \"spanish\": \"nada\", \"english\": \"nothing\" }, { \"spanish\": \"curso\", \"english\": \"course\" }, { \"spanish\": \"quedarse\", \"english\": \"stay\" }, { \"spanish\": \"rueda\", \"english\": \"wheel\" }, { \"spanish\": \"completo\", \"english\": \"full\" }, { \"spanish\": \"fuerza\", \"english\": \"force\" }, { \"spanish\": \"azul\", \"english\": \"blue\" }, { \"spanish\": \"objeto\", \"english\": \"object\" }, { \"spanish\": \"decidir\", \"english\": \"decide\" }, { \"spanish\": \"superficie\", \"english\": \"surface\" }, { \"spanish\": \"profunda\", \"english\": \"deep\" }, { \"spanish\": \"luna\", \"english\": \"moon\" }, { \"spanish\": \"isla\", \"english\": \"island\" }, { \"spanish\": \"pie\", \"english\": \"foot\" }, { \"spanish\": \"sistema\", \"english\": \"system\" }, { \"spanish\": \"ocupado\", \"english\": \"busy\" }, { \"spanish\": \"prueba\", \"english\": \"test\" }, { \"spanish\": \"registro\", \"english\": \"record\" }, { \"spanish\": \"barco\", \"english\": \"boat\" }, { \"spanish\": \"común\", \"english\": \"common\" }, { \"spanish\": \"oro\", \"english\": \"gold\" }, { \"spanish\": \"posible\", \"english\": \"possible\" }, { \"spanish\": \"plano\", \"english\": \"plane\" }, { \"spanish\": \"lugar\", \"english\": \"stead\" }, { \"spanish\": \"seco\", \"english\": \"dry\" }, { \"spanish\": \"maravilla\", \"english\": \"wonder\" }, { \"spanish\": \"risa\", \"english\": \"laugh\" }, { \"spanish\": \"mil\", \"english\": \"thousand\" }, { \"spanish\": \"hace\", \"english\": \"ago\" }, { \"spanish\": \"corrió\", \"english\": \"ran\" }, { \"spanish\": \"comprobar\", \"english\": \"check\" }, { \"spanish\": \"juego\", \"english\": \"game\" }, { \"spanish\": \"forma\", \"english\": \"shape\" }, { \"spanish\": \"equiparar\", \"english\": \"equate\" }, { \"spanish\": \"caliente\", \"english\": \"hot\" }, { \"spanish\": \"señorita\", \"english\": \"miss\" }, { \"spanish\": \"traído\", \"english\": \"brought\" }, { \"spanish\": \"calor\", \"english\": \"heat\" }, { \"spanish\": \"nieve\", \"english\": \"snow\" }, { \"spanish\": \"neumáticos\", \"english\": \"tire\" }, { \"spanish\": \"traer\", \"english\": \"bring\" }, { \"spanish\": \"sí\", \"english\": \"yes\" }, { \"spanish\": \"distante\", \"english\": \"distant\" }, { \"spanish\": \"llenar\", \"english\": \"fill\" }, { \"spanish\": \"al este\", \"english\": \"east\" }, { \"spanish\": \"pintar\", \"english\": \"paint\" }, { \"spanish\": \"idioma\", \"english\": \"language\" }, { \"spanish\": \"entre\", \"english\": \"among\" }, { \"spanish\": \"unidad\", \"english\": \"unit\" }, { \"spanish\": \"potencia\", \"english\": \"power\" }, { \"spanish\": \"ciudad\", \"english\": \"town\" }, { \"spanish\": \"fina\", \"english\": \"fine\" }, { \"spanish\": \"cierto\", \"english\": \"certain\" }, { \"spanish\": \"volar\", \"english\": \"fly\" }, { \"spanish\": \"caer\", \"english\": \"fall\" }, { \"spanish\": \"conducir\", \"english\": \"lead\" }, { \"spanish\": \"grito\", \"english\": \"cry\" }, { \"spanish\": \"oscuro\", \"english\": \"dark\" }, { \"spanish\": \"máquina\", \"english\": \"machine\" }, { \"spanish\": \"nota\", \"english\": \"note\" }, { \"spanish\": \"espere\", \"english\": \"wait\" }, { \"spanish\": \"plan de\", \"english\": \"plan\" }, { \"spanish\": \"figura\", \"english\": \"figure\" }, { \"spanish\": \"estrella\", \"english\": \"star\" }, { \"spanish\": \"caja\", \"english\": \"box\" }, { \"spanish\": \"sustantivo\", \"english\": \"noun\" }, { \"spanish\": \"campo\", \"english\": \"field\" }, { \"spanish\": \"resto\", \"english\": \"rest\" }, { \"spanish\": \"correcta\", \"english\": \"correct\" }, { \"spanish\": \"capaz\", \"english\": \"able\" }, { \"spanish\": \"libra\", \"english\": \"pound\" }, { \"spanish\": \"hecho\", \"english\": \"done\" }, { \"spanish\": \"belleza\", \"english\": \"beauty\" }, { \"spanish\": \"unidad\", \"english\": \"drive\" }, { \"spanish\": \"destacado\", \"english\": \"stood\" }, { \"spanish\": \"contener\", \"english\": \"contain\" }, { \"spanish\": \"delante\", \"english\": \"front\" }, { \"spanish\": \"enseñar\", \"english\": \"teach\" }, { \"spanish\": \"semana\", \"english\": \"week\" }, { \"spanish\": \"último\", \"english\": \"final\" }, { \"spanish\": \"dio\", \"english\": \"gave\" }, { \"spanish\": \"verde\", \"english\": \"green\" }, { \"spanish\": \"oh\", \"english\": \"oh\" }, { \"spanish\": \"rápido\", \"english\": \"quick\" }, { \"spanish\": \"desarrollar\", \"english\": \"develop\" }, { \"spanish\": \"océano\", \"english\": \"ocean\" }, { \"spanish\": \"caliente\", \"english\": \"warm\" }, { \"spanish\": \"libre\", \"english\": \"free\" }, { \"spanish\": \"minuto\", \"english\": \"minute\" }, { \"spanish\": \"fuerte\", \"english\": \"strong\" }, { \"spanish\": \"especial\", \"english\": \"special\" }, { \"spanish\": \"mente\", \"english\": \"mind\" }, { \"spanish\": \"detrás\", \"english\": \"behind\" }, { \"spanish\": \"claro\", \"english\": \"clear\" }, { \"spanish\": \"cola\", \"english\": \"tail\" }, { \"spanish\": \"Produce\", \"english\": \"produce\" }, { \"spanish\": \"hecho\", \"english\": \"fact\" }, { \"spanish\": \"espacio\", \"english\": \"space\" }, { \"spanish\": \"oído\", \"english\": \"heard\" }, { \"spanish\": \"mejor\", \"english\": \"best\" }, { \"spanish\": \"horas\", \"english\": \"hour\" }, { \"spanish\": \"mejor\", \"english\": \"better\" }, { \"spanish\": \"verdadero\", \"english\": true }, { \"spanish\": \"durante\", \"english\": \"during\" }, { \"spanish\": \"cien\", \"english\": \"hundred\" }, { \"spanish\": \"cinco\", \"english\": \"five\" }, { \"spanish\": \"recordar\", \"english\": \"remember\" }, { \"spanish\": \"paso\", \"english\": \"step\" }, { \"spanish\": \"temprana\", \"english\": \"early\" }, { \"spanish\": \"mantenga\", \"english\": \"hold\" }, { \"spanish\": \"oeste\", \"english\": \"west\" }, { \"spanish\": \"suelo\", \"english\": \"ground\" }, { \"spanish\": \"interés\", \"english\": \"interest\" }, { \"spanish\": \"llegar\", \"english\": \"reach\" }, { \"spanish\": \"rápido\", \"english\": \"fast\" }, { \"spanish\": \"verbo\", \"english\": \"verb\" }, { \"spanish\": \"cantar\", \"english\": \"sing\" }, { \"spanish\": \"escuchar\", \"english\": \"listen\" }, { \"spanish\": \"seis\", \"english\": \"six\" }, { \"spanish\": \"mesa\", \"english\": \"table\" }, { \"spanish\": \"viajes\", \"english\": \"travel\" }, { \"spanish\": \"menos\", \"english\": \"less\" }, { \"spanish\": \"mañana\", \"english\": \"morning\" }, { \"spanish\": \"diez\", \"english\": \"ten\" }, { \"spanish\": \"sencilla\", \"english\": \"simple\" }, { \"spanish\": \"varios\", \"english\": \"several\" }, { \"spanish\": \"vocal\", \"english\": \"vowel\" }, { \"spanish\": \"hacia\", \"english\": \"toward\" }, { \"spanish\": \"guerra\", \"english\": \"war\" }, { \"spanish\": \"sentar\", \"english\": \"lay\" }, { \"spanish\": \"contra\", \"english\": \"against\" }, { \"spanish\": \"patrón\", \"english\": \"pattern\" }, { \"spanish\": \"lenta\", \"english\": \"slow\" }, { \"spanish\": \"centro\", \"english\": \"center\" }, { \"spanish\": \"amar\", \"english\": \"love\" }, { \"spanish\": \"persona\", \"english\": \"person\" }, { \"spanish\": \"dinero\", \"english\": \"money\" }, { \"spanish\": \"servir\", \"english\": \"serve\" }, { \"spanish\": \"aparecerá\", \"english\": \"appear\" }, { \"spanish\": \"carretera\", \"english\": \"road\" }, { \"spanish\": \"mapa\", \"english\": \"map\" }, { \"spanish\": \"lluvia\", \"english\": \"rain\" }, { \"spanish\": \"regla\", \"english\": \"rule\" }, { \"spanish\": \"gobernar\", \"english\": \"govern\" }, { \"spanish\": \"Halar\", \"english\": \"pull\" }, { \"spanish\": \"frío\", \"english\": \"cold\" }, { \"spanish\": \"aviso\", \"english\": \"notice\" }, { \"spanish\": \"voz\", \"english\": \"voice\" }, { \"spanish\": \"energía\", \"english\": \"energy\" }, { \"spanish\": \"caza\", \"english\": \"hunt\" }, { \"spanish\": \"probable\", \"english\": \"probable\" }, { \"spanish\": \"cama\", \"english\": \"bed\" }, { \"spanish\": \"hermano\", \"english\": \"brother\" }, { \"spanish\": \"huevo\", \"english\": \"egg\" }, { \"spanish\": \"paseo\", \"english\": \"ride\" }, { \"spanish\": \"celular\", \"english\": \"cell\" }, { \"spanish\": \"creer\", \"english\": \"believe\" }, { \"spanish\": \"quizás\", \"english\": \"perhaps\" }, { \"spanish\": \"recoger\", \"english\": \"pick\" }, { \"spanish\": \"repentina\", \"english\": \"sudden\" }, { \"spanish\": \"contar\", \"english\": \"count\" }, { \"spanish\": \"plaza\", \"english\": \"square\" }, { \"spanish\": \"razón\", \"english\": \"reason\" }, { \"spanish\": \"longitud\", \"english\": \"length\" }, { \"spanish\": \"representar\", \"english\": \"represent\" }, { \"spanish\": \"arte\", \"english\": \"art\" }, { \"spanish\": \"sujeto\", \"english\": \"subject\" }, { \"spanish\": \"región\", \"english\": \"region\" }, { \"spanish\": \"tamaño\", \"english\": \"size\" }, { \"spanish\": \"variar\", \"english\": \"vary\" }, { \"spanish\": \"resolver\", \"english\": \"settle\" }, { \"spanish\": \"hablar\", \"english\": \"speak\" }, { \"spanish\": \"peso\", \"english\": \"weight\" }, { \"spanish\": \"general\", \"english\": \"general\" }, { \"spanish\": \"hielo\", \"english\": \"ice\" }, { \"spanish\": \"materia\", \"english\": \"matter\" }, { \"spanish\": \"círculo\", \"english\": \"circle\" }, { \"spanish\": \"par\", \"english\": \"pair\" }, { \"spanish\": \"incluir\", \"english\": \"include\" }, { \"spanish\": \"brecha\", \"english\": \"divide\" }, { \"spanish\": \"sílaba\", \"english\": \"syllable\" }, { \"spanish\": \"sentido\", \"english\": \"felt\" }, { \"spanish\": \"gran\", \"english\": \"grand\" }, { \"spanish\": \"bola\", \"english\": \"ball\" }, { \"spanish\": \"aún\", \"english\": \"yet\" }, { \"spanish\": \"ola\", \"english\": \"wave\" }, { \"spanish\": \"caer\", \"english\": \"drop\" }, { \"spanish\": \"corazón\", \"english\": \"heart\" }, { \"spanish\": \"am\", \"english\": \"am\" }, { \"spanish\": \"presente\", \"english\": \"present\" }, { \"spanish\": \"pesada\", \"english\": \"heavy\" }, { \"spanish\": \"danza\", \"english\": \"dance\" }, { \"spanish\": \"motor\", \"english\": \"engine\" }, { \"spanish\": \"posición\", \"english\": \"position\" }, { \"spanish\": \"brazo\", \"english\": \"arm\" }, { \"spanish\": \"amplio\", \"english\": \"wide\" }, { \"spanish\": \"vela\", \"english\": \"sail\" }, { \"spanish\": \"materiales\", \"english\": \"material\" }, { \"spanish\": \"fracción\", \"english\": \"fraction\" }, { \"spanish\": \"bosque\", \"english\": \"forest\" }, { \"spanish\": \"sentarse\", \"english\": \"sit\" }, { \"spanish\": \"carrera\", \"english\": \"race\" }, { \"spanish\": \"ventana\", \"english\": \"window\" }, { \"spanish\": \"tienda\", \"english\": \"store\" }, { \"spanish\": \"verano\", \"english\": \"summer\" }, { \"spanish\": \"tren\", \"english\": \"train\" }, { \"spanish\": \"sueño\", \"english\": \"sleep\" }, { \"spanish\": \"demostrar\", \"english\": \"prove\" }, { \"spanish\": \"solitario\", \"english\": \"lone\" }, { \"spanish\": \"pierna\", \"english\": \"leg\" }, { \"spanish\": \"ejercicio\", \"english\": \"exercise\" }, { \"spanish\": \"pared\", \"english\": \"wall\" }, { \"spanish\": \"capturas\", \"english\": \"catch\" }, { \"spanish\": \"monte\", \"english\": \"mount\" }, { \"spanish\": \"desear\", \"english\": \"wish\" }, { \"spanish\": \"cielo\", \"english\": \"sky\" }, { \"spanish\": \"bordo\", \"english\": \"board\" }, { \"spanish\": \"alegría\", \"english\": \"joy\" }, { \"spanish\": \"invierno\", \"english\": \"winter\" }, { \"spanish\": \"satélite\", \"english\": \"sat\" }, { \"spanish\": \"escrito\", \"english\": \"written\" }, { \"spanish\": \"salvaje\", \"english\": \"wild\" }, { \"spanish\": \"instrumento\", \"english\": \"instrument\" }, { \"spanish\": \"guardado\", \"english\": \"kept\" }, { \"spanish\": \"vidrio\", \"english\": \"glass\" }, { \"spanish\": \"hierba\", \"english\": \"grass\" }, { \"spanish\": \"vaca\", \"english\": \"cow\" }, { \"spanish\": \"trabajo\", \"english\": \"job\" }, { \"spanish\": \"borde\", \"english\": \"edge\" }, { \"spanish\": \"signo\", \"english\": \"sign\" }, { \"spanish\": \"visita\", \"english\": \"visit\" }, { \"spanish\": \"pasado\", \"english\": \"past\" }, { \"spanish\": \"suave\", \"english\": \"soft\" }, { \"spanish\": \"diversión\", \"english\": \"fun\" }, { \"spanish\": \"brillante\", \"english\": \"bright\" }, { \"spanish\": \"gas\", \"english\": \"gas\" }, { \"spanish\": \"tiempo\", \"english\": \"weather\" }, { \"spanish\": \"mes\", \"english\": \"month\" }, { \"spanish\": \"millones\", \"english\": \"million\" }, { \"spanish\": \"soportar\", \"english\": \"bear\" }, { \"spanish\": \"acabado\", \"english\": \"finish\" }, { \"spanish\": \"feliz\", \"english\": \"happy\" }, { \"spanish\": \"esperanza\", \"english\": \"hope\" }, { \"spanish\": \"flor\", \"english\": \"flower\" }, { \"spanish\": \"vestir\", \"english\": \"clothe\" }, { \"spanish\": \"extraño\", \"english\": \"strange\" }, { \"spanish\": \"se ha ido\", \"english\": \"gone\" }, { \"spanish\": \"comercio\", \"english\": \"trade\" }, { \"spanish\": \"melodía\", \"english\": \"melody\" }, { \"spanish\": \"viaje\", \"english\": \"trip\" }, { \"spanish\": \"oficina\", \"english\": \"office\" }, { \"spanish\": \"recibir\", \"english\": \"receive\" }, { \"spanish\": \"fila\", \"english\": \"row\" }, { \"spanish\": \"boca\", \"english\": \"mouth\" }, { \"spanish\": \"exacta\", \"english\": \"exact\" }, { \"spanish\": \"símbolo\", \"english\": \"symbol\" }, { \"spanish\": \"morir\", \"english\": \"die\" }, { \"spanish\": \"menos\", \"english\": \"least\" }, { \"spanish\": \"problema\", \"english\": \"trouble\" }, { \"spanish\": \"grito\", \"english\": \"shout\" }, { \"spanish\": \"excepto\", \"english\": \"except\" }, { \"spanish\": \"escribió\", \"english\": \"wrote\" }, { \"spanish\": \"semilla\", \"english\": \"seed\" }, { \"spanish\": \"tono\", \"english\": \"tone\" }, { \"spanish\": \"unirse\", \"english\": \"join\" }, { \"spanish\": \"sugerir\", \"english\": \"suggest\" }, { \"spanish\": \"limpia\", \"english\": \"clean\" }, { \"spanish\": \"rotura\", \"english\": \"break\" }, { \"spanish\": \"dama\", \"english\": \"lady\" }, { \"spanish\": \"patio\", \"english\": \"yard\" }, { \"spanish\": \"aumentando\", \"english\": \"rise\" }, { \"spanish\": \"mal\", \"english\": \"bad\" }, { \"spanish\": \"golpe\", \"english\": \"blow\" }, { \"spanish\": \"aceite\", \"english\": \"oil\" }, { \"spanish\": \"sangre\", \"english\": \"blood\" }, { \"spanish\": \"tocar\", \"english\": \"touch\" }, { \"spanish\": \"creció\", \"english\": \"grew\" }, { \"spanish\": \"ciento\", \"english\": \"cent\" }, { \"spanish\": \"mezclar\", \"english\": \"mix\" }, { \"spanish\": \"equipo\", \"english\": \"team\" }, { \"spanish\": \"alambre\", \"english\": \"wire\" }, { \"spanish\": \"costo\", \"english\": \"cost\" }, { \"spanish\": \"perdido\", \"english\": \"lost\" }, { \"spanish\": \"marrón\", \"english\": \"brown\" }, { \"spanish\": \"desgaste\", \"english\": \"wear\" }, { \"spanish\": \"jardín\", \"english\": \"garden\" }, { \"spanish\": \"igual\", \"english\": \"equal\" }, { \"spanish\": \"enviado\", \"english\": \"sent\" }, { \"spanish\": \"elegir\", \"english\": \"choose\" }, { \"spanish\": \"cayó\", \"english\": \"fell\" }, { \"spanish\": \"encajar\", \"english\": \"fit\" }, { \"spanish\": \"fluir\", \"english\": \"flow\" }, { \"spanish\": \"justo\", \"english\": \"fair\" }, { \"spanish\": \"banco\", \"english\": \"bank\" }, { \"spanish\": \"recoger\", \"english\": \"collect\" }, { \"spanish\": \"guardar\", \"english\": \"save\" }, { \"spanish\": \"el control\", \"english\": \"control\" }, { \"spanish\": \"decimal\", \"english\": \"decimal\" }, { \"spanish\": \"oído\", \"english\": \"ear\" }, { \"spanish\": \"demás\", \"english\": \"else\" }, { \"spanish\": \"bastante\", \"english\": \"quite\" }, { \"spanish\": \"rompió\", \"english\": \"broke\" }, { \"spanish\": \"caso\", \"english\": \"case\" }, { \"spanish\": \"medio\", \"english\": \"middle\" }, { \"spanish\": \"matar\", \"english\": \"kill\" }, { \"spanish\": \"hijo\", \"english\": \"son\" }, { \"spanish\": \"lago\", \"english\": \"lake\" }, { \"spanish\": \"momento\", \"english\": \"moment\" }, { \"spanish\": \"escala\", \"english\": \"scale\" }, { \"spanish\": \"fuerte\", \"english\": \"loud\" }, { \"spanish\": \"primavera\", \"english\": \"spring\" }, { \"spanish\": \"observar\", \"english\": \"observe\" }, { \"spanish\": \"niño\", \"english\": \"child\" }, { \"spanish\": \"recta\", \"english\": \"straight\" }, { \"spanish\": \"consonante\", \"english\": \"consonant\" }, { \"spanish\": \"nación\", \"english\": \"nation\" }, { \"spanish\": \"diccionario\", \"english\": \"dictionary\" }, { \"spanish\": \"leche\", \"english\": \"milk\" }, { \"spanish\": \"velocidad\", \"english\": \"speed\" }, { \"spanish\": \"método\", \"english\": \"method\" }, { \"spanish\": \"órgano\", \"english\": \"organ\" }, { \"spanish\": \"pagar\", \"english\": \"pay\" }, { \"spanish\": \"edad\", \"english\": \"age\" }, { \"spanish\": \"sección\", \"english\": \"section\" }, { \"spanish\": \"vestido\", \"english\": \"dress\" }, { \"spanish\": \"nube\", \"english\": \"cloud\" }, { \"spanish\": \"sorpresa\", \"english\": \"surprise\" }, { \"spanish\": \"tranquila\", \"english\": \"quiet\" }, { \"spanish\": \"piedra\", \"english\": \"stone\" }, { \"spanish\": \"pequeño\", \"english\": \"tiny\" }, { \"spanish\": \"ascenso\", \"english\": \"climb\" }, { \"spanish\": \"fresco\", \"english\": \"cool\" }, { \"spanish\": \"diseño\", \"english\": \"design\" }, { \"spanish\": \"pobre\", \"english\": \"poor\" }, { \"spanish\": \"mucho\", \"english\": \"lot\" }, { \"spanish\": \"experimento\", \"english\": \"experiment\" }, { \"spanish\": \"inferior\", \"english\": \"bottom\" }, { \"spanish\": \"clave\", \"english\": \"key\" }, { \"spanish\": \"hierro\", \"english\": \"iron\" }, { \"spanish\": \"sola\", \"english\": \"single\" }, { \"spanish\": \"palillo\", \"english\": \"stick\" }, { \"spanish\": \"plana\", \"english\": \"flat\" }, { \"spanish\": \"veinte\", \"english\": \"twenty\" }, { \"spanish\": \"piel\", \"english\": \"skin\" }, { \"spanish\": \"sonrisa\", \"english\": \"smile\" }, { \"spanish\": \"pliegue\", \"english\": \"crease\" }, { \"spanish\": \"agujero\", \"english\": \"hole\" }, { \"spanish\": \"saltar\", \"english\": \"jump\" }, { \"spanish\": \"bebé\", \"english\": \"baby\" }, { \"spanish\": \"ocho\", \"english\": \"eight\" }, { \"spanish\": \"pueblo\", \"english\": \"village\" }, { \"spanish\": \"se reúnen\", \"english\": \"meet\" }, { \"spanish\": \"raíz\", \"english\": \"root\" }, { \"spanish\": \"comprar\", \"english\": \"buy\" }, { \"spanish\": \"aumentar\", \"english\": \"raise\" }, { \"spanish\": \"resolver\", \"english\": \"solve\" }, { \"spanish\": \"de metal\", \"english\": \"metal\" }, { \"spanish\": \"si\", \"english\": \"whether\" }, { \"spanish\": \"empujar\", \"english\": \"push\" }, { \"spanish\": \"siete\", \"english\": \"seven\" }, { \"spanish\": \"párrafo\", \"english\": \"paragraph\" }, { \"spanish\": \"tercero\", \"english\": \"third\" }, { \"spanish\": \"deberá\", \"english\": \"shall\" }, { \"spanish\": \"en espera\", \"english\": \"held\" }, { \"spanish\": \"pelo\", \"english\": \"hair\" }, { \"spanish\": \"describir\", \"english\": \"describe\" }, { \"spanish\": \"cocinero\", \"english\": \"cook\" }, { \"spanish\": \"piso\", \"english\": \"floor\" }, { \"spanish\": \"ya sea\", \"english\": \"either\" }, { \"spanish\": \"resultado\", \"english\": \"result\" }, { \"spanish\": \"quemar\", \"english\": \"burn\" }, { \"spanish\": \"colina\", \"english\": \"hill\" }, { \"spanish\": \"seguro\", \"english\": \"safe\" }, { \"spanish\": \"gato\", \"english\": \"cat\" }, { \"spanish\": \"siglo\", \"english\": \"century\" }, { \"spanish\": \"considerar\", \"english\": \"consider\" }, { \"spanish\": \"tipo\", \"english\": \"type\" }, { \"spanish\": \"ley\", \"english\": \"law\" }, { \"spanish\": \"bit\", \"english\": \"bit\" }, { \"spanish\": \"costa\", \"english\": \"coast\" }, { \"spanish\": \"copia\", \"english\": \"copy\" }, { \"spanish\": \"frase\", \"english\": \"phrase\" }, { \"spanish\": \"silencio\", \"english\": \"silent\" }, { \"spanish\": \"de altura\", \"english\": \"tall\" }, { \"spanish\": \"arena\", \"english\": \"sand\" }, { \"spanish\": \"suelo\", \"english\": \"soil\" }, { \"spanish\": \"rollo\", \"english\": \"roll\" }, { \"spanish\": \"temperatura\", \"english\": \"temperature\" }, { \"spanish\": \"dedo\", \"english\": \"finger\" }, { \"spanish\": \"industria\", \"english\": \"industry\" }, { \"spanish\": \"valor\", \"english\": \"value\" }, { \"spanish\": \"lucha\", \"english\": \"fight\" }, { \"spanish\": \"mentira\", \"english\": \"lie\" }, { \"spanish\": \"batir\", \"english\": \"beat\" }, { \"spanish\": \"excitar\", \"english\": \"excite\" }, { \"spanish\": \"naturales\", \"english\": \"natural\" }, { \"spanish\": \"vista\", \"english\": \"view\" }, { \"spanish\": \"sentido\", \"english\": \"sense\" }, { \"spanish\": \"de capital\", \"english\": \"capital\" }, { \"spanish\": \"no lo hará\", \"english\": \"won’t\" }, { \"spanish\": \"silla\", \"english\": \"chair\" }, { \"spanish\": \"peligro\", \"english\": \"danger\" }, { \"spanish\": \"fruta\", \"english\": \"fruit\" }, { \"spanish\": \"rica\", \"english\": \"rich\" }, { \"spanish\": \"de espesor\", \"english\": \"thick\" }, { \"spanish\": \"soldado\", \"english\": \"soldier\" }, { \"spanish\": \"proceso\", \"english\": \"process\" }, { \"spanish\": \"operar\", \"english\": \"operate\" }, { \"spanish\": \"práctica\", \"english\": \"practice\" }, { \"spanish\": \"separada\", \"english\": \"separate\" }, { \"spanish\": \"difícil\", \"english\": \"difficult\" }, { \"spanish\": \"médico\", \"english\": \"doctor\" }, { \"spanish\": \"por favor\", \"english\": \"please\" }, { \"spanish\": \"proteger\", \"english\": \"protect\" }, { \"spanish\": \"mediodía\", \"english\": \"noon\" }, { \"spanish\": \"de cultivos\", \"english\": \"crop\" }, { \"spanish\": \"moderno\", \"english\": \"modern\" }, { \"spanish\": \"elemento\", \"english\": \"element\" }, { \"spanish\": \"golpear\", \"english\": \"hit\" }, { \"spanish\": \"estudiante\", \"english\": \"student\" }, { \"spanish\": \"esquina\", \"english\": \"corner\" }, { \"spanish\": \"partido\", \"english\": \"party\" }, { \"spanish\": \"suministro\", \"english\": \"supply\" }, { \"spanish\": \"cuya\", \"english\": \"whose\" }, { \"spanish\": \"localizar\", \"english\": \"locate\" }, { \"spanish\": \"anillo\", \"english\": \"ring\" }, { \"spanish\": \"carácter\", \"english\": \"character\" }, { \"spanish\": \"insecto\", \"english\": \"insect\" }, { \"spanish\": \"capturado\", \"english\": \"caught\" }, { \"spanish\": \"período\", \"english\": \"period\" }, { \"spanish\": \"indicar\", \"english\": \"indicate\" }, { \"spanish\": \"Radio\", \"english\": \"radio\" }, { \"spanish\": \"habló\", \"english\": \"spoke\" }, { \"spanish\": \"átomo\", \"english\": \"atom\" }, { \"spanish\": \"humana\", \"english\": \"human\" }, { \"spanish\": \"historia\", \"english\": \"history\" }, { \"spanish\": \"efecto\", \"english\": \"effect\" }, { \"spanish\": \"eléctrica\", \"english\": \"electric\" }, { \"spanish\": \"esperar\", \"english\": \"expect\" }, { \"spanish\": \"hueso\", \"english\": \"bone\" }, { \"spanish\": \"ferrocarril\", \"english\": \"rail\" }, { \"spanish\": \"imaginar\", \"english\": \"imagine\" }, { \"spanish\": \"proporcionar\", \"english\": \"provide\" }, { \"spanish\": \"acuerdo\", \"english\": \"agree\" }, { \"spanish\": \"por tanto,\", \"english\": \"thus\" }, { \"spanish\": \"suave\", \"english\": \"gentle\" }, { \"spanish\": \"mujer\", \"english\": \"woman\" }, { \"spanish\": \"capitán\", \"english\": \"captain\" }, { \"spanish\": \"adivinar\", \"english\": \"guess\" }, { \"spanish\": \"necesario\", \"english\": \"necessary\" }, { \"spanish\": \"agudo\", \"english\": \"sharp\" }, { \"spanish\": \"ala\", \"english\": \"wing\" }, { \"spanish\": \"crear\", \"english\": \"create\" }, { \"spanish\": \"vecino\", \"english\": \"neighbor\" }, { \"spanish\": \"lavado\", \"english\": \"wash\" }, { \"spanish\": \"bate\", \"english\": \"bat\" }, { \"spanish\": \"más bien\", \"english\": \"rather\" }, { \"spanish\": \"multitud\", \"english\": \"crowd\" }, { \"spanish\": \"maíz\", \"english\": \"corn\" }, { \"spanish\": \"comparar\", \"english\": \"compare\" }, { \"spanish\": \"poema\", \"english\": \"poem\" }, { \"spanish\": \"cadena\", \"english\": \"string\" }, { \"spanish\": \"campana\", \"english\": \"bell\" }, { \"spanish\": \"dependerá\", \"english\": \"depend\" }, { \"spanish\": \"carne\", \"english\": \"meat\" }, { \"spanish\": \"frotar\", \"english\": \"rub\" }, { \"spanish\": \"tubo\", \"english\": \"tube\" }, { \"spanish\": \"famoso\", \"english\": \"famous\" }, { \"spanish\": \"dólar\", \"english\": \"dollar\" }, { \"spanish\": \"corriente\", \"english\": \"stream\" }, { \"spanish\": \"miedo\", \"english\": \"fear\" }, { \"spanish\": \"vista\", \"english\": \"sight\" }, { \"spanish\": \"delgado\", \"english\": \"thin\" }, { \"spanish\": \"triángulo\", \"english\": \"triangle\" }, { \"spanish\": \"planeta\", \"english\": \"planet\" }, { \"spanish\": \"prisa\", \"english\": \"hurry\" }, { \"spanish\": \"jefe\", \"english\": \"chief\" }, { \"spanish\": \"colonia\", \"english\": \"colony\" }, { \"spanish\": \"reloj\", \"english\": \"clock\" }, { \"spanish\": \"mina\", \"english\": \"mine\" }, { \"spanish\": \"empate\", \"english\": \"tie\" }, { \"spanish\": \"entrar\", \"english\": \"enter\" }, { \"spanish\": \"importante\", \"english\": \"major\" }, { \"spanish\": \"fresco\", \"english\": \"fresh\" }, { \"spanish\": \"búsqueda\", \"english\": \"search\" }, { \"spanish\": \"enviar\", \"english\": \"send\" }, { \"spanish\": \"amarillo\", \"english\": \"yellow\" }, { \"spanish\": \"pistola\", \"english\": \"gun\" }, { \"spanish\": \"permitir\", \"english\": \"allow\" }, { \"spanish\": \"print\", \"english\": \"print\" }, { \"spanish\": \"muerto\", \"english\": \"dead\" }, { \"spanish\": \"lugar\", \"english\": \"spot\" }, { \"spanish\": \"desierto\", \"english\": \"desert\" }, { \"spanish\": \"traje\", \"english\": \"suit\" }, { \"spanish\": \"actual\", \"english\": \"current\" }, { \"spanish\": \"ascensor\", \"english\": \"lift\" }, { \"spanish\": \"rosa\", \"english\": \"rose\" }, { \"spanish\": \"llegar\", \"english\": \"arrive\" }, { \"spanish\": \"master\", \"english\": \"master\" }, { \"spanish\": \"pista\", \"english\": \"track\" }, { \"spanish\": \"padre\", \"english\": \"parent\" }, { \"spanish\": \"orilla\", \"english\": \"shore\" }, { \"spanish\": \"división\", \"english\": \"division\" }, { \"spanish\": \"hoja\", \"english\": \"sheet\" }, { \"spanish\": \"sustancia\", \"english\": \"substance\" }, { \"spanish\": \"favorecer\", \"english\": \"favor\" }, { \"spanish\": \"conectar\", \"english\": \"connect\" }, { \"spanish\": \"mensaje\", \"english\": \"post\" }, { \"spanish\": \"pasar\", \"english\": \"spend\" }, { \"spanish\": \"acorde\", \"english\": \"chord\" }, { \"spanish\": \"grasa\", \"english\": \"fat\" }, { \"spanish\": \"contento\", \"english\": \"glad\" }, { \"spanish\": \"originales\", \"english\": \"original\" }, { \"spanish\": \"cuota\", \"english\": \"share\" }, { \"spanish\": \"estación\", \"english\": \"station\" }, { \"spanish\": \"papá\", \"english\": \"dad\" }, { \"spanish\": \"pan\", \"english\": \"bread\" }, { \"spanish\": \"cobrar\", \"english\": \"charge\" }, { \"spanish\": \"adecuada\", \"english\": \"proper\" }, { \"spanish\": \"barra\", \"english\": \"bar\" }, { \"spanish\": \"oferta\", \"english\": \"offer\" }, { \"spanish\": \"segmento\", \"english\": \"segment\" }, { \"spanish\": \"esclavo\", \"english\": \"slave\" }, { \"spanish\": \"pato\", \"english\": \"duck\" }, { \"spanish\": \"instantánea\", \"english\": \"instant\" }, { \"spanish\": \"mercado\", \"english\": \"market\" }, { \"spanish\": \"grado\", \"english\": \"degree\" }, { \"spanish\": \"poblar\", \"english\": \"populate\" }, { \"spanish\": \"polluelo\", \"english\": \"chick\" }, { \"spanish\": \"querido\", \"english\": \"dear\" }, { \"spanish\": \"enemigo\", \"english\": \"enemy\" }, { \"spanish\": \"responder\", \"english\": \"reply\" }, { \"spanish\": \"bebida\", \"english\": \"drink\" }, { \"spanish\": \"producirse\", \"english\": \"occur\" }, { \"spanish\": \"apoyo\", \"english\": \"support\" }, { \"spanish\": \"discurso\", \"english\": \"speech\" }, { \"spanish\": \"naturaleza\", \"english\": \"nature\" }, { \"spanish\": \"alcance\", \"english\": \"range\" }, { \"spanish\": \"vapor\", \"english\": \"steam\" }, { \"spanish\": \"movimiento\", \"english\": \"motion\" }, { \"spanish\": \"camino\", \"english\": \"path\" }, { \"spanish\": \"líquido\", \"english\": \"liquid\" }, { \"spanish\": \"log\", \"english\": \"log\" }, { \"spanish\": \"significado\", \"english\": \"meant\" }, { \"spanish\": \"cociente\", \"english\": \"quotient\" }, { \"spanish\": \"dientes\", \"english\": \"teeth\" }, { \"spanish\": \"concha\", \"english\": \"shell\" }, { \"spanish\": \"cuello\", \"english\": \"neck\" }, { \"spanish\": \"oxígeno\", \"english\": \"oxygen\" }, { \"spanish\": \"azúcar\", \"english\": \"sugar\" }, { \"spanish\": \"muerte\", \"english\": \"death\" }, { \"spanish\": \"bastante\", \"english\": \"pretty\" }, { \"spanish\": \"habilidad\", \"english\": \"skill\" }, { \"spanish\": \"mujeres\", \"english\": \"women\" }, { \"spanish\": \"temporada\", \"english\": \"season\" }, { \"spanish\": \"solución\", \"english\": \"solution\" }, { \"spanish\": \"imán\", \"english\": \"magnet\" }, { \"spanish\": \"plata\", \"english\": \"silver\" }, { \"spanish\": \"gracias\", \"english\": \"thank\" }, { \"spanish\": \"rama\", \"english\": \"branch\" }, { \"spanish\": \"partido\", \"english\": \"match\" }, { \"spanish\": \"sufijo\", \"english\": \"suffix\" }, { \"spanish\": \"especialmente\", \"english\": \"especially\" }, { \"spanish\": \"higo\", \"english\": \"fig\" }, { \"spanish\": \"miedo\", \"english\": \"afraid\" }, { \"spanish\": \"enorme\", \"english\": \"huge\" }, { \"spanish\": \"hermana\", \"english\": \"sister\" }, { \"spanish\": \"acero\", \"english\": \"steel\" }, { \"spanish\": \"discutir\", \"english\": \"discuss\" }, { \"spanish\": \"adelante\", \"english\": \"forward\" }, { \"spanish\": \"similar\", \"english\": \"similar\" }, { \"spanish\": \"guiar\", \"english\": \"guide\" }, { \"spanish\": \"experiencia\", \"english\": \"experience\" }, { \"spanish\": \"puntuación\", \"english\": \"score\" }, { \"spanish\": \"manzana\", \"english\": \"apple\" }, { \"spanish\": \"comprado\", \"english\": \"bought\" }, { \"spanish\": \"llevado\", \"english\": \"led\" }, { \"spanish\": \"pitch\", \"english\": \"pitch\" }, { \"spanish\": \"abrigo\", \"english\": \"coat\" }, { \"spanish\": \"masa\", \"english\": \"mass\" }, { \"spanish\": \"tarjeta\", \"english\": \"card\" }, { \"spanish\": \"banda\", \"english\": \"band\" }, { \"spanish\": \"cuerda\", \"english\": \"rope\" }, { \"spanish\": \"deslizamiento\", \"english\": \"slip\" }, { \"spanish\": \"ganar\", \"english\": \"win\" }, { \"spanish\": \"soñar\", \"english\": \"dream\" }, { \"spanish\": \"noche\", \"english\": \"evening\" }, { \"spanish\": \"condición\", \"english\": \"condition\" }, { \"spanish\": \"pienso\", \"english\": \"feed\" }, { \"spanish\": \"herramienta\", \"english\": \"tool\" }, { \"spanish\": \"totales\", \"english\": \"total\" }, { \"spanish\": \"básico\", \"english\": \"basic\" }, { \"spanish\": \"olor\", \"english\": \"smell\" }, { \"spanish\": \"valle\", \"english\": \"valley\" }, { \"spanish\": \"ni\", \"english\": \"nor\" }, { \"spanish\": \"doble\", \"english\": \"double\" }, { \"spanish\": \"asiento\", \"english\": \"seat\" }, { \"spanish\": \"continuar\", \"english\": \"continue\" }, { \"spanish\": \"bloque\", \"english\": \"block\" }, { \"spanish\": \"tabla\", \"english\": \"chart\" }, { \"spanish\": \"sombrero\", \"english\": \"hat\" }, { \"spanish\": \"vender\", \"english\": \"sell\" }, { \"spanish\": \"éxito\", \"english\": \"success\" }, { \"spanish\": \"empresa\", \"english\": \"company\" }, { \"spanish\": \"restar\", \"english\": \"subtract\" }, { \"spanish\": \"evento\", \"english\": \"event\" }, { \"spanish\": \"particular,\", \"english\": \"particular\" }, { \"spanish\": \"acuerdo\", \"english\": \"deal\" }, { \"spanish\": \"nadar\", \"english\": \"swim\" }, { \"spanish\": \"plazo\", \"english\": \"term\" }, { \"spanish\": \"opuesta\", \"english\": \"opposite\" }, { \"spanish\": \"esposa\", \"english\": \"wife\" }, { \"spanish\": \"zapato\", \"english\": \"shoe\" }, { \"spanish\": \"hombro\", \"english\": \"shoulder\" }, { \"spanish\": \"propagación\", \"english\": \"spread\" }, { \"spanish\": \"organizar\", \"english\": \"arrange\" }, { \"spanish\": \"campamento\", \"english\": \"camp\" }, { \"spanish\": \"inventar\", \"english\": \"invent\" }, { \"spanish\": \"algodón\", \"english\": \"cotton\" }, { \"spanish\": \"nacido\", \"english\": \"born\" }, { \"spanish\": \"determinar\", \"english\": \"determine\" }, { \"spanish\": \"cuarto de galón\", \"english\": \"quart\" }, { \"spanish\": \"nueve\", \"english\": \"nine\" }, { \"spanish\": \"camión\", \"english\": \"truck\" }, { \"spanish\": \"ruido\", \"english\": \"noise\" }, { \"spanish\": \"nivel\", \"english\": \"level\" }, { \"spanish\": \"oportunidad\", \"english\": \"chance\" }, { \"spanish\": \"reunir\", \"english\": \"gather\" }, { \"spanish\": \"tienda\", \"english\": \"shop\" }, { \"spanish\": \"tramo\", \"english\": \"stretch\" }, { \"spanish\": \"lanzar\", \"english\": \"throw\" }, { \"spanish\": \"brillo\", \"english\": \"shine\" }, { \"spanish\": \"propiedad\", \"english\": \"property\" }, { \"spanish\": \"columna\", \"english\": \"column\" }, { \"spanish\": \"molécula\", \"english\": \"molecule\" }, { \"spanish\": \"seleccionar\", \"english\": \"select\" }, { \"spanish\": \"mal\", \"english\": \"wrong\" }, { \"spanish\": \"gris\", \"english\": \"gray\" }, { \"spanish\": \"repita\", \"english\": \"repeat\" }, { \"spanish\": \"exigir\", \"english\": \"require\" }, { \"spanish\": \"amplio\", \"english\": \"broad\" }, { \"spanish\": \"preparar\", \"english\": \"prepare\" }, { \"spanish\": \"sal\", \"english\": \"salt\" }, { \"spanish\": \"nariz\", \"english\": \"nose\" }, { \"spanish\": \"plurales\", \"english\": \"plural\" }, { \"spanish\": \"cólera\", \"english\": \"anger\" }, { \"spanish\": \"reclamación\", \"english\": \"claim\" }, { \"spanish\": \"continente\", \"english\": \"continent\" } ]; let seenWords = new Set(); function getNewWord() { let availableWords = vocabulary.filter(word => !seenWords.has(word.spanish)); if (availableWords.length === 0) { seenWords.clear(); availableWords = vocabulary; } const word = availableWords[Math.floor(Math.random() * availableWords.length)]; seenWords.add(word.spanish); document.getElementById('vocab-spanish').textContent = word.spanish; document.getElementById('vocab-english').textContent = word.english; document.getElementById('vocab-english').style.display = 'none'; document.getElementById('vocab-toggle').textContent = 'Show Translation'; document.getElementById('vocab-progress').textContent = `Progress: ${seenWords.size} of ${vocabulary.length}`; // Modified text format } document.getElementById('vocab-toggle').onclick = function() { const englishWord = document.getElementById('vocab-english'); const isHidden = englishWord.style.display === 'none'; englishWord.style.display = isHidden ? 'block' : 'none'; this.textContent = isHidden ? 'Hide Translation' : 'Show Translation'; }; document.getElementById('vocab-next').onclick = getNewWord; // Initialize with first word getNewWord(); })();","link":"/tool/tool-spanish-vocabulary-app/"},{"title":"Understanding APY &amp; APR","text":"In this post, we will discuss APY &amp; APR in depth. 1. APYAPY (Annual Percentage Yield) is the actual return on an investment or savings account, including the effects of compounding over a year. Compounding means that interest is calculated and added to the principal balance once per month. This means that each month, interest is earned not only on the original deposit but also on the interest that has accumulated from previous months. To calculate APY, we can start with compounding interest. Compound interest means that interest is earned on both the initial principal and previously earned interest. The formula for compound interest is: $$\\begin{equation}A_{1} = P \\times (1 + \\frac{r}{n}) \\\\A_{2} = A_{1} \\times (1 + \\frac{r}{n}) = P \\times (1 + \\frac{r}{n}) \\times (1 + \\frac{r}{n}) \\\\… \\\\A_{12} = A_{11} \\times (1 + \\frac{r}{n}) = P \\times (1 + \\frac{r}{n})^n\\end{equation}$$ where: $A$ is the final amount. $P$ is the initial principal. $r$ is the interest rate. $n$ is the number of compounding periods per year. $r/n$ is the interest rate every month. For APY, we are interested in how much $1 will grow after 1 year. So $P=1$. $$\\begin{equation}APY = (1 + \\frac{r}{n})^n - 1\\end{equation}$$ 2. APRAPR (Annual Percentage Rate) is the annual cost of borrowing money, expressed as a percentage of the loan amount. It includes the interest rate plus certain fees but does not account for the effects of compounding. You probably see a lot on car dealership advertisement mentioning 4.99% APR. It means you will be charged 4.99% of the loan amount per year in interest and fees. Given total loan amount, APR and total number of payments(months), how can we estimate the monthly loan payment? Let’s derive the calculation step by step. Step 1: Understanding Load Payment A loan consists of principal and interest. Each month, the borrower makes a fixed payment, which covers: Interest on the remaining loan balance A portion that reduces the principal The lender applies the interest first, and the remaining part reduces the principal. Step 2: Calculate Load Balance Over Time At the start, you borrow $P$. After one month, the loan balance grows due to interest:$$\\begin{equation}\\text{New Balance} = P + P \\times r = P(1 + r)\\end{equation}$$ Since you make $M$ payment, the remaining balance becomes:$$\\begin{equation}\\text{BalanceAfterFirstMonth} = P(1 + r) - M\\end{equation}$$ After the second month, interest applies again and $M$ payment is made.$$\\begin{equation}\\begin{aligned}\\text{BalanceAfterSecondMonth} &amp;= (P(1 + r) - M)(1 + r) - M \\\\&amp;= P(1 + r)^{2} - M(1 + r) - M\\end{aligned}\\end{equation}$$ Following this pattern, after $n$ months, the loan should be fully paid off, meaning the balance reaches zero:$$\\begin{equation}P(1 + r)^{n} - M[(1 + r)^{n-1} + (1 + r)^{n-2}+…+1] = 0\\end{equation}$$ Step 3: Summing the Series The bracketed term is a geometric series:$$\\begin{equation}S = (1 + r)^{n-1} + (1 + r)^{n-2}+…+1\\end{equation}$$ The sum of a finite geometric series is:$$\\begin{equation}S = \\frac{1 - (1 + r)^{n}}{1 - (1 + r)} = \\frac{1 - (1 + r)^{n}}{-r}\\end{equation}$$ We rewrite the equation:$$\\begin{equation}P(1 + r)^{n} = M \\frac{1 - (1 + r)^{n}}{-r} = M \\frac{(1 + r)^{n} - 1}{r}\\end{equation}$$ Solving for $M$:$$\\begin{equation}M = \\frac{P(1 + r)^{n}r}{(1 + r)^{n} - 1} = \\frac{P \\times r}{1 - (1 + r)^{-n}}\\end{equation}$$ where: $M$ is the monthly payment. $P$ is the loan amount. $r$ is the month interest (APY/12) $n$ is the number of months. This is the standard amortization formula used for fixed-rate loans. For instance, if my car loan amount is $19,000, the dealership guarantees a fixed APR of 4.99%, and I choose a repayment term of 60 months, then my monthly payment is: $$\\begin{equation}M = \\frac{P \\times r}{1 - (1 + r)^{-n}} = \\frac{19000 \\times \\frac{0.0499}{12}}{(1 - (1 + \\frac{0.0499}{12})^{-60})} \\approx 358.466\\end{equation}$$ One key feature of amortized loans is that most of your payment goes toward interest at the beginning of the loan. This happens because of how loan interest is calculated and how principal payments are structured in the early stages of the loan. Interest is Calculated on the Remaining Balance: In an amortized loan, each payment is split into two parts: one portion pays off the interest and the other pays down the principal (the amount you originally borrowed). The interest portion is calculated on the remaining balance of the loan, so when you first take out the loan, the remaining balance is the full amount you borrowed (e.g., $20,000). Larger Interest Payment at the Start: The amount of interest you owe each month is based on the remaining balance of the loan. At the beginning, when your loan balance is high, the interest portion is larger. For example, if you borrow $20,000 at 5% APR, the interest charged for the first month is calculated on the full $20,000. $$\\begin{equation}\\text{Interest for 1st month} = 20000 \\times 0.05 / 12 = 83.33\\end{equation}$$ As you make payments, the loan balance decreases, so the interest portion decreases over time. Smaller Principal Payment Initially: Since the interest portion is higher at the start, the portion of your monthly payment that goes toward the principal is relatively small at first. Over time, as you pay down the loan balance, the interest amount reduces, allowing a larger portion of your payment to go toward the principal. Amortization Schedule: This is why lenders often create an amortization schedule, showing how each payment is split into principal and interest. In the early months, most of your payment goes to interest, and as the loan balance decreases, more of your payment goes toward reducing the principal. Let’s say you have a $20,000 loan at 5% APR, with a 60-month term. Your first few payments might look like this: Payment # Payment Amount Interest Payment Principal Payment Remaining Balance 1 $377.42 $83.33 $294.09 $19,705.91 2 $377.42 $82.60 $294.82 $19,411.09 3 $377.42 $81.53 $295.89 $19,115.20 References https://www.investopedia.com/terms/a/apy.asp https://www.investopedia.com/terms/a/amortization.asp","link":"/wealth/wealth-apy/"},{"title":"Starbucks Under $5","text":"Customized Starbucks drinks under $5 Everything in the Bay Area is soooooo expensive, especially boba. Hopefully, this helps you discover some affordable boba alternatives. 1. 海盐生椰拿铁 2. 豆乳抹茶拿铁 3. 芝士奶盖红茶","link":"/tool/tool-starbucks-under-5/"},{"title":"A Collection of Useful Scripts","text":"Simple but useful scripts to handle basic needs. 1. Reanme FilesThis script is to sort and rename image files from 1.jpg to n.jpg. rename.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/bin/bash# Directory to process (default is current directory)DIR=&quot;.&quot;# Check if a directory is provided as an argumentif [ $# -eq 1 ]; then DIR=&quot;$1&quot;fi# Check if the directory existsif [ ! -d &quot;$DIR&quot; ]; then echo &quot;Error: Directory '$DIR' does not exist.&quot; exit 1fi# Change to the specified directorycd &quot;$DIR&quot; || exit 1# Create a temporary directory for intermediate filesTEMP_DIR=$(mktemp -d)if [ ! -d &quot;$TEMP_DIR&quot; ]; then echo &quot;Error: Could not create temporary directory.&quot; exit 1fi# Counter for renamingcount=1# Find all image files, sort them by name, and rename# Using ls without -t for alphabetical sortingfor file in $(ls *.{jpg,jpeg,png,JPG,JPEG,PNG} 2&gt;/dev/null); do # Skip if not a regular file if [ ! -f &quot;$file&quot; ]; then continue fi # Generate new filename new_name=&quot;$count.jpg&quot; # Move to temp directory first to avoid overwriting mv &quot;$file&quot; &quot;$TEMP_DIR/$new_name&quot; || { echo &quot;Error: Failed to move $file to temp directory.&quot; exit 1 } # Increment counter ((count++))done# Move files back from temp directory to original directorymv &quot;$TEMP_DIR&quot;/* . 2&gt;/dev/nullif [ $? -ne 0 ]; then echo &quot;Warning: Some files may not have been moved back.&quot;fi# Clean up temp directoryrmdir &quot;$TEMP_DIR&quot;# Check if any files were renamedif [ $count -eq 1 ]; then echo &quot;No image files found in '$DIR'.&quot;else echo &quot;Renamed $((count-1)) image files in '$DIR'.&quot;fiexit 0 123usage:./rename [target folder]","link":"/tool/tool-useful-scripts/"},{"title":"Numeric Data Representation in Modern Computer System","text":"Integer, fix-point number, floating-point number This is a summary of MIT6.5940, lecture 5, data types part. 1. Integer1.1 Unsigned IntegerFor an N-bit unsigned integer, its range is $[0, 2^N - 1]$ 1.2 Signed Integer1.2.1 Sign-Magnitude RepresentationFor N-bit, the most left(highest) bit is a sign bit. Its range is $[-(2^{n-1}-1), 2^{n-1}-1]$ There are two ways to represent 0 10000000 00000000 1.2.2 Two’s Complement Representationsign bit Most significant bit (MSB) is the sign bit. if MSB is 0, the number is positive or zero. if MSB is 1, the number is negative. range(for N-bit) The min is where MSB is 1 and the rest is 0, which is $-2^{n-1}$. The max is where MSB is 0 and the rest is 1, which is $2^{n-1}-1$. Two’s complement has only one representation for zero: 00000000. Steps to obtain Two’s complement: Positive Numbers: Represent the number in binary as usual. Negative Numbers: Start with the binary representation of the absolute value. Invert all the bits (change 0s to 1s and 1s to 0s). Add 1 to the least significant bit (LSB). For example: Positive Number (e.g., +5): Convert +5 to binary: 0101 The result is 0101, which is the binary representation in two’s complement. Negative Number (e.g., -5): Convert 5 to binary: 0101 Invert the bits: 1010 Add 1: 1010 + 1 = 1011 The result is 1011, which is the binary representation of -5 in two’s complement. Two’s complement makes the arithmetic simpler and hardware implementation friendly. 12345678910111213Addition of 4-bit Two's complement numbers3+(-5)3 is &quot;0011&quot;5 is &quot;1011&quot; 0011+ 1011------ 1110&quot;1110&quot; is -2 in Two's complement representation. 2. Fixed-Point Number source: https://www.dropbox.com/scl/fi/eos92o2fgys6gk0gizogl/lec05.pdf?rlkey=2hohvi8jcvjw3f8m8vugfa2mz&e=1&dl=0 Example with negative numbers. 1234567-5.5In 8 bit representation, one possible representation could be 0101.1000Invert bits: 1010.0111Add 1 to the LSB: 1010.0111 + 0.0001 = 1010.10001010.1000 -&gt; 1x(-2^(3)) + 1x2^(1) + 1x2^(-1) = -8 + 2 + 0.5 = -5.5 3. Floating-Point Number3.1 32-bit floating point number The number it can represent:$$(-1)^{sign} \\times (1 + mantissa) \\times 2^{exponent-127}$$ Q: How can we represent zero in 32-bit floating point number? The equation above only applies to cases where exponent is not all zeros. If exponent is all zeros, then it follows another equation.$$(-1)^{sign} \\times mantissa \\times 2^{1-127}$$So, we have two ways to represent zero, where we let mantissa part to be 0. 3.2 Half Precision (FP16) $$(-1)^{sign} \\times (1 + mantissa) \\times 2^{exponent-15}$$ 4. INT4 Negative numbers are represented using Two’s complement. Binary | Decimal 0000 -&gt; 0 0001 -&gt; 1 0010 -&gt; 2 0011 -&gt; 3 0100 -&gt; 4 0101 -&gt; 5 0110 -&gt; 6 0111 -&gt; 7 1000 -&gt; -8 1001 -&gt; -7 1010 -&gt; -6 1011 -&gt; -5 1100 -&gt; -4 1101 -&gt; -3 1110 -&gt; -2 1111 -&gt; -1 5. FP4 References https://www.dropbox.com/scl/fi/eos92o2fgys6gk0gizogl/lec05.pdf?rlkey=2hohvi8jcvjw3f8m8vugfa2mz&amp;e=1&amp;dl=0","link":"/misc/misc-numeric-data-representation/"},{"title":"Medicare vs Medicaid","text":"On Tuesday(01/28/2025), the Medicaid system was shut down across all 50 US states. This seems to be related to the Trump’s administration order on freezing of federal grants and loans. But later, White House said it expected the system to be back online shortly. As of Octorber 2024, nearly 79 million Americans were enrolled in Medicaid program. The program is a significant source of funding for medical and health-related services for people with low income in the United States. There is also another program called Medicare, which people often confuse it with Medicaid. In this post, we will discuss their differences. 1. IntroductionMedicaid and Medicare are both government programs in the US that provide health coverage, but they serve different populations and have distinct characteristics. Medicare is mainly designed for those 65 and older or people with disabilities. Medicaid is for people with qualifying low-income. 2. MedicareA brieft history: Medicare’s Beginnings (1965): Aimed to provide health insurance to elderly Americans. Expansion (1972): Eligibility extended to people with disabilities and ESRD. Prescription Drugs (2003): Introduction of Part D for prescription drug coverage. Reforms (2010s-Present): Additional provisions from the ACA to reduce costs and expand coverage. ➡️ Eligibility: Medicare is a federal program that primarily provides health coverage for people aged 65 or older, as well as certain younger individuals with disabilities or specific medical conditions, like End-Stage Renal Disease (ESRD). ➡️ Funding: It is funded by the federal government through payroll taxes and premiums paid by beneficiaries. ➡️ Coverage: Medicare has different parts: 📌 Part A (Hospital Insurance) covers inpatient hospital care, skilled nursing facility care, hospice care, and some home health care. 📌 Part B (Medical Insurance) covers outpatient services like doctor visits, preventive services, and medical equipment. 📌 Part C (Medicare Advantage) is an alternative that offers both Part A and Part B coverage through private health insurance companies. 📌 Part D (Prescription Drug Coverage) helps cover the cost of prescription medications. 3. MedicaidMedicaid is a joint federal and state program in the United States that provides health coverage to low-income individuals and families. Unlike Medicare, which primarily serves the elderly and people with disabilities, Medicaid is designed to assist those who cannot afford healthcare due to financial constraints. A Brieft history:Medicaid was created in 1965 to help low-income populations access healthcare and has evolved through expansions and reforms, including the ACA in 2010. ➡️ Eligibility: 📌 Medicaid is primarily aimed at low-income individuals and families, but eligibility varies by state. 📌 It covers groups such as: Children, Pregnant women, Elderly individuals, People with disabilities, Low-income adults. 📌 Each state sets its own income limits and requirements, meaning eligibility differs based on where you live. ➡️ Funding: 📌 Medicaid is funded jointly by the federal government and individual states. 📌 The federal government provides a percentage of the funding (the federal match rate), and states fund the remaining portion. The match rate varies by state, depending on the state’s average income level. ➡️ Coverage: Medicaid covers a wide range of healthcare services, including hospital visits, doctor’s appointments, prescription drugs, and long-term care. States may offer additional benefits beyond the federal requirements. ➡️ Medicaid Expansion (ACA, 2010): 📌 The Affordable Care Act (ACA) allowed for the expansion of Medicaid to cover more low-income adults. Under this expansion, states could extend Medicaid eligibility to people who earn up to 138% of the federal poverty level (FPL). 📌 However, states could choose whether or not to expand Medicaid, and not all states chose to do so, leading to differences in Medicaid coverage across the country. 4. Dual EligibilityA person with dual eligibility qualifies for both Medicare and Medicaid. These individuals, often referred to as “dual-eligible beneficiaries,” are typically low-income seniors or people with disabilities who meet the income and resource limits for Medicaid while also being eligible for Medicare (usually due to age or disability). Usually, Medicare serves as the primary insurance and covers hospital care (Part A) and medical services (Part B). Medicaid covers costs not paid by Medicare, such as Medicare premiums, deductibles, copayments, and coinsurance. It may also cover additional services not included in Medicare, such as long-term care, nursing home care, and some home/community-based services. For more detailed information, you can check the revised official document on CMS website: link References https://www.theguardian.com/us-news/2025/jan/29/medicaid-trump-funding https://www.cnbc.com/2025/01/28/trump-funding-freeze-medicaid-state-portals-omb.html https://www.wellpoint.com/medicare/understanding-medicare/medicare-vs-medicaid https://www.cms.gov/medicare-medicaid-coordination/medicare-and-medicaid-coordination/medicare-medicaid-coordination-office/downloads/medicaremedicaidenrolleecategories.pdf","link":"/wealth/wealth-medicaid-medicare-medicaid/"},{"title":"US Imposes Tariffs on Other Countries","text":"On February 1, 2025, President Donald Trump signed executive orders imposing new tariffs on imports from Canada, Mexico, and China, effective February 4, 2025. The tariffs are set at 25% for Canadian and Mexican imports, and 10% for Chinese imports. Notably, Canadian energy exports to the U.S. will face a reduced tariff of 10%. During his previous term, President Trump had already imposed tariffs on China, so why is he doing it again? In this post, we will explore the implications of higher tariffs and why politicians often use them as a strategic tool against other countries. There is a common misunderstanding that tariffs are a tax paid by China when, in reality, the cost burden falls primarily on U.S. importers, businesses, and consumers. If the U.S. imposes a 25% tariff on Chinese goods, it means that any affected products imported from China will have an additional 25% tax on their declared value. Here’s what this means in practice: Higher Costs for Importers: U.S. companies that import goods from China will have to pay an extra 25% on top of the original price. Potential Price Increases for Consumers: If businesses pass the higher costs to customers, products like electronics, clothing, and machinery could become more expensive in the U.S. Impact on Chinese Exporters: Chinese manufacturers may experience reduced demand from U.S. buyers due to higher prices. Trade Tensions: Such tariffs often lead to trade disputes, and China might retaliate with tariffs on U.S. goods. Shifts in Supply Chains: Companies may seek alternative suppliers from other countries to avoid tariffs, affecting global trade dynamics. The U.S. government imposes high tariffs on China for several strategic reasons, primarily driven by economic, political, and national security considerations. Protecting Domestic Industries High tariffs make Chinese imports more expensive, encouraging American consumers and businesses to buy U.S.-made products instead. This is meant to support domestic manufacturing, preserve jobs, and reduce reliance on foreign supply chains. Reducing Trade Deficit The U.S. has a large trade deficit with China (i.e., it imports far more from China than it exports). Tariffs are intended to reduce this imbalance by making Chinese goods costlier, thereby decreasing U.S. imports from China. Strengthening National Security The U.S. government sees reliance on Chinese goods—especially in critical industries like defense, telecommunications, and medicine—as a national security risk. For example, this time, President Donald J. Trump has imposed tariffs on imports from Canada, Mexico, and China, citing a national emergency related to illegal immigration and the influx of drugs, particularly fentanyl, into the United States. By imposing tariffs, the U.S. seeks to diversify supply chains and reduce dependence on China for essential goods. Political Strategy Tariffs can be politically popular, especially among American workers and industries affected by outsourcing to China. A notable example is former U.S. President Donald Trump’s trade war with China (2018-2020), where he imposed high tariffs on Chinese goods as part of his “America First” economic policy. U.S. politicians often use tariffs as a campaign promise to show they are protecting American jobs and industries Overall, a higher tariff on foreign imports, has far-reaching consequences for both economies. In the short term, it raises costs for U.S. businesses and consumers, leading to higher prices and potential inflation. It also disrupts supply chains, forcing companies to seek alternative suppliers. In the long run, tariffs can encourage domestic production and reduce reliance on import goods, but they may also strain trade relations, leading to retaliation and global economic instability. Ultimately, while tariffs can serve as a tool for economic leverage, they often result in unintended consequences, affecting businesses, consumers, and global markets. References https://www.foxnews.com/politics/trump-signs-tariffs-imports-canada-mexico-china-national-emergency https://knowledge.wharton.upenn.edu/podcast/knowledge-at-wharton-podcast/u-s-china-tariffs/","link":"/wealth/wealth-trump-imposes-tariff/"},{"title":"Maximize Roth401k","text":"In this post, I will perform a thorough mathematical analysis to demonstrate how to maximize your 401(k) contributions. Since the contribution limit varies in different year, I will use 2024 for demonstration purpose. 1. Some Basic DataFor 2024 calendar year, the contribution limits: ➡️ $23000: pre-tax and roth employee contribution➡️ $69000: employee + employer contribution➡️ $76500: employee + employer contribution if 50 or older source from IRS We have some basic assumptions as follows: ➡️ Jack (27 years old) with annual base salary of A, he chooses to contribute B% to Roth 401k in each paycheck.➡️ Jack’s employer matches C% of Jack’s contribution➡️ Assume that his employer offers the option of after-tax contribution (but no matching), and Jack chooses to contribute D%.➡️ Jack’s employer offers annual target bonus, which is E% of the base salary. In our assumptions, some numbers are fixed such as A, C and E. 2. Maximize Employee Contributionit is important to note that your Roth 401(k) contributions are calculated based on your before-tax (gross) income, even though they are made with after-tax dollars. $$\\begin{equation}Bonus = \\frac{E}{100} \\times A\\end{equation}$$ To maximize the personal contribution: $$\\begin{equation}B\\% \\times A + B\\% \\times (\\frac{E}{100} \\times A) = 23000\\end{equation}$$ We can get B as: $$\\begin{equation}B = \\frac{23000}{A \\times (1 + \\frac{E}{100}) } \\times 100\\end{equation}$$ For example, if Jack earns $200000 a year with target bonus of 25%, to reach maximum contribution, he needs to set contribution percentage to be: $$\\begin{equation}\\frac{23000}{200000 \\times (1 + \\frac{25}{100}) } \\times 100 = 9.2\\end{equation}$$ 3. Maximize Employee + Employer ContributionReaching the maximum total contribution limit can be a bit complex, as companies have different employer matching policies. For instance, some employers may cap their match at a specific amount or percentage. Common examples include phrases like, “The company will match 50% of your contribution, up to a maximum of 5% of your eligible pay,” or “The company’s match will not exceed 50% of the IRS limit,” and so on. To simplify the calculation, we assume Jack’s employer is very generous and willing to set no restriction on the employer matching limit. In order to reach the maximum of $69000, there is still a big gap. So, Jack has to do after-tax contribution. Then, the equation would be: Jack’s Contributions + Employer Match + After-Tax Contributions = 69000 The employer matches C% of Jack’s $23000 contribution. Therefore, the employer’s match is: $$\\begin{equation}Employer Match = \\frac{C}{100} \\times 23000\\end{equation}$$ Since Jack has maximized personal contribution, the total remaining contribution required after Jack’s Roth contribution is: $$\\begin{equation}69000−23000=46000\\end{equation}$$ Jack will contribute D% of his salary A as after-tax contributions. Therefore: $$\\begin{equation}D\\% \\times A = 46000 − \\frac{C}{100} \\times 23000\\end{equation}$$ Therefore, D can be obtained as: $$\\begin{equation}D = \\frac{46000 - \\frac{C}{100} \\times 23000}{A} \\times 100\\end{equation}$$ If Jack’s employer matches 6% of Jack’s contribution, then Jack needs to contribute additional 17.25% to reach the limit. $$\\begin{equation}\\frac{46000 - \\frac{50}{100} \\times 23000}{200000} \\times 100 = 17.25\\end{equation}$$ 4. Conclusion Reaching the personal contribution limit is relatively straightforward, but we may also need to account for other factors, such as one-time bonuses. Reaching the total contribution limit can be more complicated, as different companies have varying rules for matching contributions. The analysis above is based on general assumptions, so be sure to carefully review your company’s matching policies for accurate contribution percentages. References https://www.irs.gov/newsroom/401k-limit-increases-to-23000-for-2024-ira-limit-rises-to-7000#:~:text=401(k)%20limit%20increases%20to,Internal%20Revenue%20Service","link":"/wealth/wealth-maximize-roth-401k/"}],"tags":[{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"baby","slug":"baby","link":"/tags/baby/"},{"name":"camera","slug":"camera","link":"/tags/camera/"},{"name":"rasterization","slug":"rasterization","link":"/tags/rasterization/"},{"name":"vulkan","slug":"vulkan","link":"/tags/vulkan/"},{"name":"shader","slug":"shader","link":"/tags/shader/"},{"name":"color transfer function","slug":"color-transfer-function","link":"/tags/color-transfer-function/"},{"name":"sdr","slug":"sdr","link":"/tags/sdr/"},{"name":"hdr","slug":"hdr","link":"/tags/hdr/"},{"name":"exposure value","slug":"exposure-value","link":"/tags/exposure-value/"},{"name":"opengles","slug":"opengles","link":"/tags/opengles/"},{"name":"atomic","slug":"atomic","link":"/tags/atomic/"},{"name":"image processing","slug":"image-processing","link":"/tags/image-processing/"},{"name":"opengl","slug":"opengl","link":"/tags/opengl/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"color","slug":"color","link":"/tags/color/"},{"name":"yuv","slug":"yuv","link":"/tags/yuv/"},{"name":"rgb","slug":"rgb","link":"/tags/rgb/"},{"name":"gtest","slug":"gtest","link":"/tags/gtest/"},{"name":"allocator","slug":"allocator","link":"/tags/allocator/"},{"name":"SFINEA","slug":"SFINEA","link":"/tags/SFINEA/"},{"name":"asan","slug":"asan","link":"/tags/asan/"},{"name":"memory","slug":"memory","link":"/tags/memory/"},{"name":"bitfields","slug":"bitfields","link":"/tags/bitfields/"},{"name":"union","slug":"union","link":"/tags/union/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"inline","slug":"inline","link":"/tags/inline/"},{"name":"builder","slug":"builder","link":"/tags/builder/"},{"name":"design pattern","slug":"design-pattern","link":"/tags/design-pattern/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"concept","slug":"concept","link":"/tags/concept/"},{"name":"constexpr","slug":"constexpr","link":"/tags/constexpr/"},{"name":"consteval","slug":"consteval","link":"/tags/consteval/"},{"name":"thread","slug":"thread","link":"/tags/thread/"},{"name":"crtp","slug":"crtp","link":"/tags/crtp/"},{"name":"decltype","slug":"decltype","link":"/tags/decltype/"},{"name":"function pointers","slug":"function-pointers","link":"/tags/function-pointers/"},{"name":"template","slug":"template","link":"/tags/template/"},{"name":"ood","slug":"ood","link":"/tags/ood/"},{"name":"coroutine","slug":"coroutine","link":"/tags/coroutine/"},{"name":"parameter pack","slug":"parameter-pack","link":"/tags/parameter-pack/"},{"name":"fold expressions","slug":"fold-expressions","link":"/tags/fold-expressions/"},{"name":"extern","slug":"extern","link":"/tags/extern/"},{"name":"visibility","slug":"visibility","link":"/tags/visibility/"},{"name":"initializer","slug":"initializer","link":"/tags/initializer/"},{"name":"json parser","slug":"json-parser","link":"/tags/json-parser/"},{"name":"lvalue","slug":"lvalue","link":"/tags/lvalue/"},{"name":"rvalue","slug":"rvalue","link":"/tags/rvalue/"},{"name":"memory layout","slug":"memory-layout","link":"/tags/memory-layout/"},{"name":"nullptr","slug":"nullptr","link":"/tags/nullptr/"},{"name":"cpp style","slug":"cpp-style","link":"/tags/cpp-style/"},{"name":"observer","slug":"observer","link":"/tags/observer/"},{"name":"commit id","slug":"commit-id","link":"/tags/commit-id/"},{"name":"variadic","slug":"variadic","link":"/tags/variadic/"},{"name":"rtti","slug":"rtti","link":"/tags/rtti/"},{"name":"rule of 035","slug":"rule-of-035","link":"/tags/rule-of-035/"},{"name":"scope resolution operator","slug":"scope-resolution-operator","link":"/tags/scope-resolution-operator/"},{"name":"shared library","slug":"shared-library","link":"/tags/shared-library/"},{"name":"singleton","slug":"singleton","link":"/tags/singleton/"},{"name":"static assertion","slug":"static-assertion","link":"/tags/static-assertion/"},{"name":"type trait","slug":"type-trait","link":"/tags/type-trait/"},{"name":"polymorphism","slug":"polymorphism","link":"/tags/polymorphism/"},{"name":"static library","slug":"static-library","link":"/tags/static-library/"},{"name":"threading","slug":"threading","link":"/tags/threading/"},{"name":"threadpool","slug":"threadpool","link":"/tags/threadpool/"},{"name":"static cast","slug":"static-cast","link":"/tags/static-cast/"},{"name":"dynamic cast","slug":"dynamic-cast","link":"/tags/dynamic-cast/"},{"name":"performance","slug":"performance","link":"/tags/performance/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"virtual function","slug":"virtual-function","link":"/tags/virtual-function/"},{"name":"inheritance","slug":"inheritance","link":"/tags/inheritance/"},{"name":"volatile","slug":"volatile","link":"/tags/volatile/"},{"name":"vtable","slug":"vtable","link":"/tags/vtable/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"Halloween","slug":"Halloween","link":"/tags/Halloween/"},{"name":"birthday","slug":"birthday","link":"/tags/birthday/"},{"name":"father&#39;s day","slug":"father-s-day","link":"/tags/father-s-day/"},{"name":"Hawaii","slug":"Hawaii","link":"/tags/Hawaii/"},{"name":"newark","slug":"newark","link":"/tags/newark/"},{"name":"park","slug":"park","link":"/tags/park/"},{"name":"farm","slug":"farm","link":"/tags/farm/"},{"name":"ardenwood","slug":"ardenwood","link":"/tags/ardenwood/"},{"name":"funny","slug":"funny","link":"/tags/funny/"},{"name":"halfmoon bay","slug":"halfmoon-bay","link":"/tags/halfmoon-bay/"},{"name":"museum","slug":"museum","link":"/tags/museum/"},{"name":"hiking","slug":"hiking","link":"/tags/hiking/"},{"name":"trip","slug":"trip","link":"/tags/trip/"},{"name":"library","slug":"library","link":"/tags/library/"},{"name":"zoo","slug":"zoo","link":"/tags/zoo/"},{"name":"animal","slug":"animal","link":"/tags/animal/"},{"name":"christmas","slug":"christmas","link":"/tags/christmas/"},{"name":"chinese new year","slug":"chinese-new-year","link":"/tags/chinese-new-year/"},{"name":"chinatown","slug":"chinatown","link":"/tags/chinatown/"},{"name":"table tennis","slug":"table-tennis","link":"/tags/table-tennis/"},{"name":"collage","slug":"collage","link":"/tags/collage/"},{"name":"lightshow","slug":"lightshow","link":"/tags/lightshow/"},{"name":"movie","slug":"movie","link":"/tags/movie/"},{"name":"easter","slug":"easter","link":"/tags/easter/"},{"name":"fourth of july","slug":"fourth-of-july","link":"/tags/fourth-of-july/"},{"name":"hotpot","slug":"hotpot","link":"/tags/hotpot/"},{"name":"filoli","slug":"filoli","link":"/tags/filoli/"},{"name":"waterpark","slug":"waterpark","link":"/tags/waterpark/"},{"name":"flower","slug":"flower","link":"/tags/flower/"},{"name":"festival","slug":"festival","link":"/tags/festival/"},{"name":"jury service","slug":"jury-service","link":"/tags/jury-service/"},{"name":"hike","slug":"hike","link":"/tags/hike/"},{"name":"holiday","slug":"holiday","link":"/tags/holiday/"},{"name":"cord","slug":"cord","link":"/tags/cord/"},{"name":"child","slug":"child","link":"/tags/child/"},{"name":"newborn","slug":"newborn","link":"/tags/newborn/"},{"name":"productivity","slug":"productivity","link":"/tags/productivity/"},{"name":"ping pong","slug":"ping-pong","link":"/tags/ping-pong/"},{"name":"paddle","slug":"paddle","link":"/tags/paddle/"},{"name":"mulberry","slug":"mulberry","link":"/tags/mulberry/"},{"name":"thinking","slug":"thinking","link":"/tags/thinking/"},{"name":"rear-ended","slug":"rear-ended","link":"/tags/rear-ended/"},{"name":"seattle","slug":"seattle","link":"/tags/seattle/"},{"name":"bellevue","slug":"bellevue","link":"/tags/bellevue/"},{"name":"rv","slug":"rv","link":"/tags/rv/"},{"name":"retro game","slug":"retro-game","link":"/tags/retro-game/"},{"name":"safari","slug":"safari","link":"/tags/safari/"},{"name":"rapeseed","slug":"rapeseed","link":"/tags/rapeseed/"},{"name":"santacruz","slug":"santacruz","link":"/tags/santacruz/"},{"name":"sealion","slug":"sealion","link":"/tags/sealion/"},{"name":"sf","slug":"sf","link":"/tags/sf/"},{"name":"sleep","slug":"sleep","link":"/tags/sleep/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"super dad","slug":"super-dad","link":"/tags/super-dad/"},{"name":"tea","slug":"tea","link":"/tags/tea/"},{"name":"team build","slug":"team-build","link":"/tags/team-build/"},{"name":"segway","slug":"segway","link":"/tags/segway/"},{"name":"tiktok","slug":"tiktok","link":"/tags/tiktok/"},{"name":"open house","slug":"open-house","link":"/tags/open-house/"},{"name":"traffic","slug":"traffic","link":"/tags/traffic/"},{"name":"court","slug":"court","link":"/tags/court/"},{"name":"tummy time","slug":"tummy-time","link":"/tags/tummy-time/"},{"name":"aircraft carrier","slug":"aircraft-carrier","link":"/tags/aircraft-carrier/"},{"name":"waygu","slug":"waygu","link":"/tags/waygu/"},{"name":"circus","slug":"circus","link":"/tags/circus/"},{"name":"cat","slug":"cat","link":"/tags/cat/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"film","slug":"film","link":"/tags/film/"},{"name":"binary search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"insertion","slug":"insertion","link":"/tags/insertion/"},{"name":"special member functions","slug":"special-member-functions","link":"/tags/special-member-functions/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"libjpeg","slug":"libjpeg","link":"/tags/libjpeg/"},{"name":"cross compile","slug":"cross-compile","link":"/tags/cross-compile/"},{"name":"resources","slug":"resources","link":"/tags/resources/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"ffmpeg","slug":"ffmpeg","link":"/tags/ffmpeg/"},{"name":"opencl","slug":"opencl","link":"/tags/opencl/"},{"name":"jni","slug":"jni","link":"/tags/jni/"},{"name":"fixed point","slug":"fixed-point","link":"/tags/fixed-point/"},{"name":"coke","slug":"coke","link":"/tags/coke/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"mediacodec","slug":"mediacodec","link":"/tags/mediacodec/"},{"name":"niw","slug":"niw","link":"/tags/niw/"},{"name":"green card","slug":"green-card","link":"/tags/green-card/"},{"name":"png","slug":"png","link":"/tags/png/"},{"name":"simd","slug":"simd","link":"/tags/simd/"},{"name":"passport","slug":"passport","link":"/tags/passport/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"sliding window","slug":"sliding-window","link":"/tags/sliding-window/"},{"name":"thoughts","slug":"thoughts","link":"/tags/thoughts/"},{"name":"slow fast pointers","slug":"slow-fast-pointers","link":"/tags/slow-fast-pointers/"},{"name":"linear algebra","slug":"linear-algebra","link":"/tags/linear-algebra/"},{"name":"stl","slug":"stl","link":"/tags/stl/"},{"name":"tech slang","slug":"tech-slang","link":"/tags/tech-slang/"},{"name":"union find","slug":"union-find","link":"/tags/union-find/"},{"name":"llm","slug":"llm","link":"/tags/llm/"},{"name":"beach","slug":"beach","link":"/tags/beach/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"heic","slug":"heic","link":"/tags/heic/"},{"name":"jpg","slug":"jpg","link":"/tags/jpg/"},{"name":"editor","slug":"editor","link":"/tags/editor/"},{"name":"spanish","slug":"spanish","link":"/tags/spanish/"},{"name":"apy","slug":"apy","link":"/tags/apy/"},{"name":"apr","slug":"apr","link":"/tags/apr/"},{"name":"starbucks","slug":"starbucks","link":"/tags/starbucks/"},{"name":"scripts","slug":"scripts","link":"/tags/scripts/"},{"name":"numeric data","slug":"numeric-data","link":"/tags/numeric-data/"},{"name":"medicare","slug":"medicare","link":"/tags/medicare/"},{"name":"medicaid","slug":"medicaid","link":"/tags/medicaid/"},{"name":"tariff","slug":"tariff","link":"/tags/tariff/"},{"name":"roth","slug":"roth","link":"/tags/roth/"},{"name":"401k","slug":"401k","link":"/tags/401k/"}],"categories":[{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"life","slug":"life","link":"/categories/life/"},{"name":"CGV","slug":"CGV","link":"/categories/CGV/"},{"name":"cpp","slug":"cpp","link":"/categories/cpp/"},{"name":"misc","slug":"misc","link":"/categories/misc/"},{"name":"resource","slug":"resource","link":"/categories/resource/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"wealth","slug":"wealth","link":"/categories/wealth/"}],"pages":[{"title":"about","text":"Interested AreasHigh Performance Computing, Mobile Computing, Computational Photography, Low-Level Computer Vision, Mobile Development, Deep Learning, GPU Programming ByteDance(TikTok), (2023-12 to Present)Software EngineerSan Jose, CA • Developed TikTok’s in-app camera stabilization feature and launched global A/B testing to select the best strategy that maximized user publishing gains.• Implemented in-app camera HDR capture based on the OpenGL ES rendering pipeline, handling HDR to SDR conversion and HDR color space transformation.• Upgraded TikTok’s in-app camera to support High Resolution image capture, replacing previewed frame screenshots with the system’s native camera API for improved image quality.• Optimized camera start latency. SenseBrain, (2022-03 to 2023-11)Senior Software EngineerSan Jose, CA • Designed and developed high performance mobile imaging pipeline on Qualcomm and MediaTek platform.• Optimized algorithms for mobile CPUs using C++ and ARM Neon intrinsics.• Optimized algorithms for mobile GPUs using OpenCL.• On-device deep neural networks deployment with neural inference engines such as SNPE, QNN, PPL and libTorch.• Compressed Generative AI model (stable diffusion) for mobile devices by implementing quantization and deployed it on Android devices featuring the Qualcomm 8550 SoC using QNN, resulting in a runtime of 12 seconds.• Developed customized application for camera sensor data acquisition and processing, enabling features like burst raw image capture with 3A control, multi-camera streaming and dual-camera fusion on the Android platform. SenseBrain, (2021-11 to 2022-03)Software EngineerSan Jose, CA • Managed the maintenance and enhancement of NightSight and rawHDR imaging pipelines for mobile platforms• Enhanced algorithm efficiency and performance on mobile GPUs and CPUs using OpenCL and SIMD techniques.• Developed learning-based image denoising methods based on UNet and SGN architecture under low-light condition.• Improved denoising performance by applying controllable priors such as segmentation maps and variance maps duringtraining and inference.• Camera sensor noise modeling, calibration and synthesis under low-light condition.• Developed multi-frame noise reduction and multi-scale DCT denoising algorithm for Bayer and RGBW sensor. SenseBrain, (2021-05 to 2021-11)Research InternSan Jose, CA • Developed and experimented lightweight deep networks for raw domain image denoising.• Synthetic noise modeling and calibration under low-light condition. Publicationgoogle scholar Purdue University2018 - 2020Master of ScienceComputer GraphicsAdvisor: Yingjie Chen","link":"/about/"}]}